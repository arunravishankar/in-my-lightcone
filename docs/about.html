<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>about â€“ In My Lightcone</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./imlc_logo.jpg" rel="icon" type="image/jpeg">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-6f6599830d51be977da3b6af758f8eff.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-b14658aefa774ec5e37167111b7179fa.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-879af782b1d9f9e0b0c0f39f6193d39a.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-b14658aefa774ec5e37167111b7179fa.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">In My Lightcone</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./about.html" aria-current="page"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./ramblings.html"> 
<span class="menu-text">Ramblings</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/arunravishankar"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/arunravishankar"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://bsky.app/profile/arunravishankar.bsky.social"> <i class="bi bi-bluesky" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><h1 class="title display-7">Arun's Knowledge Graph</h1></header>





<style>
#title-block-header {
    display: none !important;
}
</style>
<div class="hero-section">

        <div id="kg_c86fdab8_wrapper" class="kg-hero-wrapper" style="position: relative; width: 100%; height: 75vh; margin: 0;">
            <div id="kg_c86fdab8" style="width: 100%; height: 100%; border: none; background-color: #f9f9f9;">
                <div style="padding: 20px; text-align: center; color: #666;">Loading graph...</div>
            </div>
            
            <div class="kg-title-overlay" id="kg_c86fdab8_title_overlay">
                
            </div>
        </div>

        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script>
        // utils/CoordinateTransform.js
/**
 * Coordinate Transformation Utilities for Knowledge Graph Explorer
 * Handles coordinate transformations between screen space and graph space
 * Provides clean abstraction for zoom/pan coordinate calculations
 */
class CoordinateTransform {
  constructor() {
    this.currentTransform = d3.zoomIdentity;
    this.viewportWidth = 800;
    this.viewportHeight = 600;
  }

  /**
   * Update the current transform (called during zoom events)
   * @param {Object} transform - D3 zoom transform object
   */
  updateTransform(transform) {
    this.currentTransform = transform;
  }

  /**
   * Update viewport dimensions
   * @param {number} width - Viewport width
   * @param {number} height - Viewport height
   */
  updateViewport(width, height) {
    this.viewportWidth = width;
    this.viewportHeight = height;
  }

  /**
   * Convert screen coordinates to graph coordinates
   * @param {Array|Object} screenPosition - [x, y] array or {x, y} object in screen space
   * @param {Object} transform - Optional transform override
   * @returns {Object} - {x, y} in graph space
   */
  screenToGraph(screenPosition, transform = null) {
    const t = transform || this.currentTransform;
    
    // Handle both array and object input
    const screenX = Array.isArray(screenPosition) ? screenPosition[0] : screenPosition.x;
    const screenY = Array.isArray(screenPosition) ? screenPosition[1] : screenPosition.y;
    
    return {
      x: (screenX - t.x) / t.k,
      y: (screenY - t.y) / t.k
    };
  }

  /**
   * Convert graph coordinates to screen coordinates
   * @param {Object|Array} graphPosition - {x, y} object or [x, y] array in graph space
   * @param {Object} transform - Optional transform override
   * @returns {Array} - [x, y] in screen space
   */
  graphToScreen(graphPosition, transform = null) {
    const t = transform || this.currentTransform;
    
    // Handle both object and array input
    const graphX = Array.isArray(graphPosition) ? graphPosition[0] : graphPosition.x;
    const graphY = Array.isArray(graphPosition) ? graphPosition[1] : graphPosition.y;
    
    return [
      graphX * t.k + t.x,
      graphY * t.k + t.y
    ];
  }

  /**
   * Convert screen coordinates relative to SVG element to graph coordinates
   * Useful for mouse event handling
   * @param {Event} event - Mouse event
   * @param {Element} svgElement - SVG DOM element
   * @param {Object} transform - Optional transform override
   * @returns {Object} - {x, y} in graph space
   */
  eventToGraph(event, svgElement, transform = null) {
    const [svgX, svgY] = d3.pointer(event, svgElement);
    return this.screenToGraph([svgX, svgY], transform);
  }

  /**
   * Calculate Euclidean distance between two points
   * @param {Object} point1 - {x, y} coordinates
   * @param {Object} point2 - {x, y} coordinates
   * @returns {number} - Distance between points
   */
  calculateDistance(point1, point2) {
    const dx = point1.x - point2.x;
    const dy = point1.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * Calculate distance between a point and multiple targets, return closest
   * @param {Object} point - {x, y} source point
   * @param {Array} targets - Array of {x, y} target points with id property
   * @param {number} maxDistance - Maximum distance to consider
   * @returns {Object|null} - Closest target with distance, or null if none within maxDistance
   */
  findClosestPoint(point, targets, maxDistance = Infinity) {
    let closest = null;
    let minDistance = maxDistance;

    targets.forEach(target => {
      const distance = this.calculateDistance(point, target);
      if (distance < minDistance) {
        minDistance = distance;
        closest = { target, distance };
      }
    });

    return closest;
  }

  /**
   * Get the current zoom scale
   * @returns {number} - Current zoom scale factor
   */
  getScale() {
    return this.currentTransform.k;
  }

  /**
   * Get the current translation
   * @returns {Object} - {x, y} translation offset
   */
  getTranslation() {
    return {
      x: this.currentTransform.x,
      y: this.currentTransform.y
    };
  }

  /**
   * Get complete transform information
   * @returns {Object} - Full transform state
   */
  getTransform() {
    return {
      x: this.currentTransform.x,
      y: this.currentTransform.y,
      k: this.currentTransform.k,
      scale: this.currentTransform.k,
      translation: this.getTranslation()
    };
  }

  /**
   * Check if a point in graph space is visible in the current viewport
   * @param {Object} graphPosition - {x, y} in graph space
   * @param {number} margin - Optional margin for visibility check (in screen pixels)
   * @returns {boolean} - True if visible in viewport
   */
  isVisible(graphPosition, margin = 0) {
    const [screenX, screenY] = this.graphToScreen(graphPosition);
    
    return screenX >= -margin && 
           screenX <= this.viewportWidth + margin && 
           screenY >= -margin && 
           screenY <= this.viewportHeight + margin;
  }

  /**
   * Get the visible bounds of the current viewport in graph coordinates
   * @param {number} margin - Optional margin to expand bounds (in screen pixels)
   * @returns {Object} - {minX, maxX, minY, maxY, width, height} in graph space
   */
  getVisibleBounds(margin = 0) {
    const topLeft = this.screenToGraph([-margin, -margin]);
    const bottomRight = this.screenToGraph([
      this.viewportWidth + margin, 
      this.viewportHeight + margin
    ]);

    return {
      minX: topLeft.x,
      maxX: bottomRight.x,
      minY: topLeft.y,
      maxY: bottomRight.y,
      width: bottomRight.x - topLeft.x,
      height: bottomRight.y - topLeft.y
    };
  }

  /**
   * Apply zoom-aware scaling to a value
   * @param {number} value - Original value
   * @param {boolean} inverse - If true, scale inversely with zoom (useful for maintaining visual size)
   * @returns {number} - Scaled value
   */
  scaleValue(value, inverse = false) {
    return inverse ? value / this.currentTransform.k : value * this.currentTransform.k;
  }

  /**
   * Scale a radius or size value to maintain consistent visual appearance across zoom levels
   * @param {number} baseValue - Base size value
   * @param {number} minScale - Minimum scale factor (prevents elements from becoming too small)
   * @param {number} maxScale - Maximum scale factor (prevents elements from becoming too large)
   * @returns {number} - Zoom-adjusted value
   */
  scaleVisualSize(baseValue, minScale = 0.5, maxScale = 2.0) {
    const scale = Math.max(minScale, Math.min(maxScale, 1 / this.currentTransform.k));
    return baseValue * scale;
  }

  /**
   * Calculate appropriate font size for current zoom level
   * @param {number} baseFontSize - Base font size in pixels
   * @param {number} minSize - Minimum readable size
   * @param {number} maxSize - Maximum size to prevent overflow
   * @returns {number} - Zoom-appropriate font size
   */
  scaleFontSize(baseFontSize, minSize = 8, maxSize = 24) {
    const scale = 1 / this.currentTransform.k;
    const scaledSize = baseFontSize * scale;
    return Math.max(minSize, Math.min(maxSize, scaledSize));
  }

  /**
   * Check if a circular area is visible in the viewport
   * @param {Object} center - {x, y} center point in graph space
   * @param {number} radius - Radius in graph space
   * @returns {boolean} - True if any part of the circle is visible
   */
  isCircleVisible(center, radius) {
    const bounds = this.getVisibleBounds();
    
    // Check if circle overlaps with viewport rectangle
    const closestX = Math.max(bounds.minX, Math.min(center.x, bounds.maxX));
    const closestY = Math.max(bounds.minY, Math.min(center.y, bounds.maxY));
    
    const distance = this.calculateDistance(center, { x: closestX, y: closestY });
    return distance <= radius;
  }

  /**
   * Create a transform that centers a specific point in the viewport
   * @param {Object} graphPoint - {x, y} point to center in graph space
   * @param {number} scale - Desired zoom scale (optional, defaults to current scale)
   * @returns {Object} - D3 transform object that centers the point
   */
  createCenteringTransform(graphPoint, scale = null) {
    const targetScale = scale !== null ? scale : this.currentTransform.k;
    const centerX = this.viewportWidth / 2;
    const centerY = this.viewportHeight / 2;
    
    return d3.zoomIdentity
      .translate(centerX - graphPoint.x * targetScale, centerY - graphPoint.y * targetScale)
      .scale(targetScale);
  }

  /**
   * Create a transform that fits a bounding box within the viewport
   * @param {Object} bounds - {minX, maxX, minY, maxY} in graph space
   * @param {number} padding - Padding as percentage of viewport (0.0 to 1.0)
   * @returns {Object} - D3 transform object that fits the bounds
   */
  createFittingTransform(bounds, padding = 0.1) {
    const contentWidth = bounds.maxX - bounds.minX;
    const contentHeight = bounds.maxY - bounds.minY;
    
    const availableWidth = this.viewportWidth * (1 - padding);
    const availableHeight = this.viewportHeight * (1 - padding);
    
    const scaleX = availableWidth / contentWidth;
    const scaleY = availableHeight / contentHeight;
    const scale = Math.min(scaleX, scaleY);
    
    const centerX = (bounds.minX + bounds.maxX) / 2;
    const centerY = (bounds.minY + bounds.maxY) / 2;
    
    return this.createCenteringTransform({ x: centerX, y: centerY }, scale);
  }

  /**
   * Reset transform to identity (no zoom, no pan)
   * @returns {Object} - Identity transform
   */
  resetTransform() {
    this.currentTransform = d3.zoomIdentity;
    return d3.zoomIdentity;
  }

  /**
   * Interpolate between two transforms for smooth animations
   * @param {Object} fromTransform - Starting transform
   * @param {Object} toTransform - Ending transform
   * @param {number} t - Interpolation factor (0.0 to 1.0)
   * @returns {Object} - Interpolated transform
   */
  interpolateTransform(fromTransform, toTransform, t) {
    return d3.zoomIdentity
      .translate(
        fromTransform.x + (toTransform.x - fromTransform.x) * t,
        fromTransform.y + (toTransform.y - fromTransform.y) * t
      )
      .scale(fromTransform.k + (toTransform.k - fromTransform.k) * t);
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = CoordinateTransform;
} else if (typeof window !== 'undefined') {
  window.CoordinateTransform = CoordinateTransform;
}

// utils/DataValidator.js
/**
 * Data Validation Utilities for Knowledge Graph Explorer
 * Validates node and link data structures, ensures data integrity
 */
class DataValidator {
  constructor() {
    this.errors = [];
    this.warnings = [];
  }

  /**
   * Validate complete graph data structure
   * @param {Object} data - Graph data with nodes and links
   * @returns {Object} - Validation result with isValid, errors, warnings
   */
  validateGraphData(data) {
    this.errors = [];
    this.warnings = [];

    if (!data) {
      this.errors.push('Graph data is null or undefined');
      return this.getValidationResult();
    }

    if (!data.nodes || !Array.isArray(data.nodes)) {
      this.errors.push('Graph data must contain a nodes array');
      return this.getValidationResult();
    }

    if (!data.links || !Array.isArray(data.links)) {
      this.errors.push('Graph data must contain a links array');
      return this.getValidationResult();
    }

    // Validate nodes
    const nodeIds = new Set();
    data.nodes.forEach((node, index) => {
      this.validateNode(node, index, nodeIds);
    });

    // Validate links
    data.links.forEach((link, index) => {
      this.validateLink(link, index, nodeIds);
    });

    // Validate parent_node references
    data.nodes.forEach((node, index) => {
      if (node.parent_node && node.parent_node !== null) {
        // Handle both string and array formats
        const parents = Array.isArray(node.parent_node) ? node.parent_node : [node.parent_node];
        parents.forEach(parentId => {
          if (!nodeIds.has(parentId)) {
            this.errors.push(`Node ${index} (${node.id}): parent_node '${parentId}' does not exist`);
          }
        });
      }
    });

    return this.getValidationResult();
  }

  /**
   * Validate individual node structure
   * @param {Object} node - Node data
   * @param {number} index - Node index in array
   * @param {Set} nodeIds - Set of existing node IDs
   */
  validateNode(node, index, nodeIds) {
    const nodeRef = `Node ${index}`;

    // Required fields
    if (!node.id) {
      this.errors.push(`${nodeRef}: Missing required field 'id'`);
      return;
    }

    if (typeof node.id !== 'string') {
      this.errors.push(`${nodeRef}: 'id' must be a string`);
    }

    if (nodeIds.has(node.id)) {
      this.errors.push(`${nodeRef}: Duplicate node ID '${node.id}'`);
    } else {
      nodeIds.add(node.id);
    }

    if (!node.label) {
      this.errors.push(`${nodeRef} (${node.id}): Missing required field 'label'`);
    }

    if (!node.type && !node.layer) {
      this.warnings.push(`${nodeRef} (${node.id}): Missing both 'type' and 'layer' fields, will use defaults`);
    }

    if (!node.layer) {
      this.warnings.push(`${nodeRef} (${node.id}): Missing 'layer' field, may affect layer functionality`);
    }

    // Optional field validation
    if (node.size !== undefined && (typeof node.size !== 'number' || node.size <= 0)) {
      this.errors.push(`${nodeRef} (${node.id}): 'size' must be a positive number`);
    }

    if (node.timespan) {
      this.validateTimespan(node.timespan, `${nodeRef} (${node.id})`);
    }

    if (node.links && !Array.isArray(node.links)) {
      this.errors.push(`${nodeRef} (${node.id}): 'links' must be an array`);
    }

    if (node.position && (!node.position.x || !node.position.y)) {
      this.warnings.push(`${nodeRef} (${node.id}): 'position' should have both x and y coordinates`);
    }

    // Validate experience level
    if (node.experienceLevel && !['experienced', 'interested'].includes(node.experienceLevel)) {
      this.warnings.push(`${nodeRef} (${node.id}): 'experienceLevel' should be 'experienced' or 'interested'`);
    }

    // Validate audience field
    if (node.audience) {
      const validAudiences = ['general', 'technical', 'current'];
      if (Array.isArray(node.audience)) {
        node.audience.forEach(aud => {
          if (!validAudiences.includes(aud)) {
            this.warnings.push(`${nodeRef} (${node.id}): Invalid audience '${aud}', should be one of: ${validAudiences.join(', ')}`);
          }
        });
      } else if (typeof node.audience === 'string') {
        if (!validAudiences.includes(node.audience)) {
          this.warnings.push(`${nodeRef} (${node.id}): Invalid audience '${node.audience}', should be one of: ${validAudiences.join(', ')}`);
        }
      } else {
        this.errors.push(`${nodeRef} (${node.id}): 'audience' must be a string or array of strings`);
      }
    }

    // Validate parent_node reference - can be string or array of strings
    if (node.parent_node) {
      if (typeof node.parent_node === 'string') {
        // Single parent - will be validated later
      } else if (Array.isArray(node.parent_node)) {
        // Multiple parents - validate each is a string
        node.parent_node.forEach((parent, idx) => {
          if (typeof parent !== 'string') {
            this.errors.push(`${nodeRef} (${node.id}): parent_node[${idx}] must be a string node ID`);
          }
        });
      } else {
        this.errors.push(`${nodeRef} (${node.id}): 'parent_node' must be a string or array of strings`);
      }
    }

    // Validate subnode field
    if (node.subnode && typeof node.subnode !== 'boolean') {
      this.errors.push(`${nodeRef} (${node.id}): 'subnode' must be a boolean value`);
    }
  }

  /**
   * Validate individual link structure
   * @param {Object} link - Link data
   * @param {number} index - Link index in array
   * @param {Set} nodeIds - Set of valid node IDs
   */
  validateLink(link, index, nodeIds) {
    const linkRef = `Link ${index}`;

    // Required fields
    if (!link.source) {
      this.errors.push(`${linkRef}: Missing required field 'source'`);
      return;
    }

    if (!link.target) {
      this.errors.push(`${linkRef}: Missing required field 'target'`);
      return;
    }

    // Check if source and target nodes exist
    if (!nodeIds.has(link.source)) {
      this.errors.push(`${linkRef}: Source node '${link.source}' does not exist`);
    }

    if (!nodeIds.has(link.target)) {
      this.errors.push(`${linkRef}: Target node '${link.target}' does not exist`);
    }

    // Self-loops warning
    if (link.source === link.target) {
      this.warnings.push(`${linkRef}: Self-loop detected (${link.source} -> ${link.target})`);
    }

    // Optional field validation
    if (link.strength !== undefined) {
      if (typeof link.strength !== 'number' || link.strength < 0 || link.strength > 1) {
        this.errors.push(`${linkRef}: 'strength' must be a number between 0 and 1`);
      }
    }
  }

  /**
   * Validate timespan structure
   * @param {Object} timespan - Timespan data
   * @param {string} context - Context for error messages
   */
  validateTimespan(timespan, context) {
    if (typeof timespan !== 'object') {
      this.errors.push(`${context}: 'timespan' must be an object`);
      return;
    }

    if (timespan.start !== undefined) {
      if (!Number.isInteger(timespan.start) || timespan.start < 1900 || timespan.start > 2100) {
        this.errors.push(`${context}: 'timespan.start' must be a valid year (1900-2100)`);
      }
    }

    if (timespan.end !== undefined && timespan.end !== null) {
      if (!Number.isInteger(timespan.end) || timespan.end < 1900 || timespan.end > 2100) {
        this.errors.push(`${context}: 'timespan.end' must be a valid year (1900-2100) or null`);
      }

      if (timespan.start && timespan.end && timespan.end < timespan.start) {
        this.errors.push(`${context}: 'timespan.end' cannot be before 'timespan.start'`);
      }
    }
  }

  /**
   * Validate configuration object
   * @param {Object} config - Configuration object
   * @returns {Object} - Validation result
   */
  validateConfig(config) {
    this.errors = [];
    this.warnings = [];

    if (!config) {
      this.errors.push('Configuration is null or undefined');
      return this.getValidationResult();
    }

    // Validate dimensions
    if (config.width !== undefined && (typeof config.width !== 'number' || config.width <= 0)) {
      this.errors.push('width must be a positive number');
    }

    if (config.height !== undefined && (typeof config.height !== 'number' || config.height <= 0)) {
      this.errors.push('height must be a positive number');
    }

    // Validate colors
    const colorFields = ['background', 'textColor', 'linkColor'];
    colorFields.forEach(field => {
      if (config[field] !== undefined && !this.isValidColor(config[field])) {
        this.warnings.push(`${field} may not be a valid CSS color`);
      }
    });

    // Validate layers
    if (config.layers) {
      if (!Array.isArray(config.layers)) {
        this.errors.push('layers must be an array');
      } else {
        config.layers.forEach((layer, index) => {
          this.validateLayer(layer, index);
        });
      }
    }

    // Validate timeline
    if (config.timeline) {
      this.validateTimelineConfig(config.timeline);
    }

    return this.getValidationResult();
  }

  /**
   * Validate layer configuration
   * @param {Object} layer - Layer configuration
   * @param {number} index - Layer index
   */
  validateLayer(layer, index) {
    const layerRef = `Layer ${index}`;

    if (!layer.id) {
      this.errors.push(`${layerRef}: Missing required field 'id'`);
    }

    if (!layer.name) {
      this.errors.push(`${layerRef}: Missing required field 'name'`);
    }

    if (!layer.color) {
      this.warnings.push(`${layerRef}: Missing 'color' field`);
    } else if (!this.isValidColor(layer.color)) {
      this.warnings.push(`${layerRef}: 'color' may not be a valid CSS color`);
    }
  }

  /**
   * Validate timeline configuration
   * @param {Object} timeline - Timeline configuration
   */
  validateTimelineConfig(timeline) {
    if (typeof timeline !== 'object') {
      this.errors.push('timeline must be an object');
      return;
    }

    if (timeline.start !== undefined) {
      if (!Number.isInteger(timeline.start)) {
        this.errors.push('timeline.start must be an integer year');
      }
    }

    if (timeline.end !== undefined) {
      if (!Number.isInteger(timeline.end)) {
        this.errors.push('timeline.end must be an integer year');
      }
    }

    if (timeline.start && timeline.end && timeline.end < timeline.start) {
      this.errors.push('timeline.end cannot be before timeline.start');
    }
  }

  /**
   * Basic CSS color validation
   * @param {string} color - Color string to validate
   * @returns {boolean} - Whether color appears valid
   */
  isValidColor(color) {
    if (typeof color !== 'string') return false;
    
    // Check for common CSS color formats
    const hexRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    const rgbRegex = /^rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/;
    const rgbaRegex = /^rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*[01]?\.?\d*\s*\)$/;
    const namedColors = ['red', 'blue', 'green', 'black', 'white', 'yellow', 'purple', 'orange', 'pink', 'brown', 'gray', 'grey'];

    return hexRegex.test(color) || 
           rgbRegex.test(color) || 
           rgbaRegex.test(color) || 
           namedColors.includes(color.toLowerCase());
  }

  /**
   * Get validation result summary
   * @returns {Object} - Validation result with isValid, errors, warnings
   */
  getValidationResult() {
    return {
      isValid: this.errors.length === 0,
      errors: [...this.errors],
      warnings: [...this.warnings],
      hasWarnings: this.warnings.length > 0
    };
  }

  /**
   * Static method for quick validation
   * @param {Object} data - Data to validate
   * @returns {Object} - Validation result
   */
  static validate(data) {
    const validator = new DataValidator();
    return validator.validateGraphData(data);
  }

  /**
   * Static method for quick config validation
   * @param {Object} config - Config to validate
   * @returns {Object} - Validation result
   */
  static validateConfiguration(config) {
    const validator = new DataValidator();
    return validator.validateConfig(config);
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = DataValidator;
} else if (typeof window !== 'undefined') {
  window.DataValidator = DataValidator;
}

// core/ForceSimulation.js
/**
 * Force Simulation Manager for Knowledge Graph Explorer
 * Handles D3 force simulation setup, configuration, and lifecycle management
 */
class ForceSimulation {
  constructor(config = {}) {
    // Require all force simulation settings to be provided via config
    const required = ['linkDistance', 'chargeStrength', 'collisionRadius', 'linkStrength', 'centerStrength', 'chargeDistanceMax'];
    const missing = required.filter(key => config[key] === undefined);
    if (missing.length > 0) {
      throw new Error(`ForceSimulation requires these settings in config: ${missing.join(', ')}`);
    }

    this.config = {
      width: 800,
      height: 600,

      // Simulation parameters (these have reasonable defaults)
      alphaMin: 0.001,
      alphaDecay: 0.0228,
      velocityDecay: 0.4,

      // Force settings - must be provided
      ...config
    };

    this.simulation = null;
    this.nodes = [];
    this.links = [];
    this.isRunning = false;
    
    // Event callbacks
    this.onTick = null;
    this.onEnd = null;
    
    this.setupSimulation();
  }

  /**
   * Initialize the D3 force simulation with default forces
   */
  setupSimulation() {
    const centerX = this.config.width / 2;
    const centerY = this.config.height / 2;

    this.simulation = d3.forceSimulation()
      .alphaMin(this.config.alphaMin)
      .alphaDecay(this.config.alphaDecay)
      .velocityDecay(this.config.velocityDecay)
      .on('tick', () => {
        if (this.onTick) {
          this.onTick(this.simulation);
        }
      })
      .on('end', () => {
        this.isRunning = false;
        if (this.onEnd) {
          this.onEnd(this.simulation);
        }
      });

    // Setup default forces
    this.setupForces(centerX, centerY);
  }

  /**
   * Configure all simulation forces
   * @param {number} centerX - Center X coordinate
   * @param {number} centerY - Center Y coordinate
   */
  setupForces(centerX, centerY) {
    // Link force - attracts connected nodes
    this.simulation.force('link', d3.forceLink()
      .id(d => d.id)
      .distance(d => this.getLinkDistance(d))
      .strength(d => this.getLinkStrength(d))
    );

    // Charge force - repels nodes from each other
    this.simulation.force('charge', d3.forceManyBody()
      .strength(d => this.getChargeStrength(d))
      .distanceMax(this.config.chargeDistanceMax)
    );

    // Center force - attracts nodes toward center
    this.simulation.force('center', d3.forceCenter(centerX, centerY)
      .strength(this.config.centerStrength)
    );

    // Collision force - prevents node overlap
    this.simulation.force('collision', d3.forceCollide()
      .radius(d => this.getCollisionRadius(d))
      .strength(0.8)
      .iterations(2)
    );
  }

  /**
   * Calculate link distance for a specific link
   * @param {Object} link - Link data
   * @returns {number} - Distance value
   */
  getLinkDistance(link) {
    if (link.distance !== undefined) {
      return link.distance;
    }
    
    // Adjust distance based on link strength
    const baseDistance = this.config.linkDistance;
    const strength = link.strength || 0.5;
    
    // Stronger connections should be closer
    return baseDistance * (1.5 - strength);
  }

  /**
   * Calculate link strength for a specific link
   * @param {Object} link - Link data
   * @returns {number} - Strength value (0-1)
   */
  getLinkStrength(link) {
    if (link.strength !== undefined) {
      return link.strength * this.config.linkStrength;
    }
    return this.config.linkStrength;
  }

  /**
   * Calculate charge (repulsion) strength for a specific node
   * @param {Object} node - Node data
   * @returns {number} - Negative charge strength
   */
  getChargeStrength(node) {
    const baseStrength = this.config.chargeStrength;
    const size = node.size || 10;
    
    // Larger nodes should have stronger repulsion
    const sizeMultiplier = Math.sqrt(size / 10);
    return baseStrength * sizeMultiplier;
  }

  /**
   * Calculate collision radius for a specific node
   * @param {Object} node - Node data
   * @returns {number} - Collision radius
   */
  getCollisionRadius(node) {
    const nodeRadius = node.size || 10;
    return nodeRadius + this.config.collisionRadius;
  }

  /**
   * Update simulation data and restart if needed
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   * @param {boolean} restart - Whether to restart the simulation
   */
  updateData(nodes, links, restart = true) {
    this.nodes = nodes || [];
    this.links = links || [];

    // Update simulation nodes and links
    this.simulation.nodes(this.nodes);
    
    const linkForce = this.simulation.force('link');
    if (linkForce) {
      linkForce.links(this.links);
    }

    if (restart) {
      this.restart();
    }
  }

  /**
   * Start or restart the simulation
   * @param {number} alpha - Initial alpha value (energy level)
   */
  restart(alpha = 1) {
    if (this.simulation) {
      this.isRunning = true;
      this.simulation.alpha(alpha).restart();
    }
  }

  /**
   * Stop the simulation
   */
  stop() {
    if (this.simulation) {
      this.isRunning = false;
      this.simulation.stop();
    }
  }

  /**
   * Pause/resume the simulation
   */
  toggle() {
    if (this.isRunning) {
      this.stop();
    } else {
      this.restart();
    }
  }

  /**
   * Update the center point of the simulation
   * @param {number} x - New center X coordinate
   * @param {number} y - New center Y coordinate
   */
  updateCenter(x, y) {
    const centerForce = this.simulation.force('center');
    if (centerForce) {
      centerForce.x(x).y(y);
    }
  }

  /**
   * Update simulation dimensions and recalculate center
   * @param {number} width - New width
   * @param {number} height - New height
   */
  updateDimensions(width, height) {
    this.config.width = width;
    this.config.height = height;
    this.updateCenter(width / 2, height / 2);
  }

  /**
   * Apply custom positioning to specific nodes
   * @param {Array} nodePositions - Array of {id, x, y} objects
   * @param {boolean} fix - Whether to fix these positions
   */
  setNodePositions(nodePositions, fix = false) {
    const positionMap = new Map();
    nodePositions.forEach(pos => {
      positionMap.set(pos.id, pos);
    });

    this.nodes.forEach(node => {
      const position = positionMap.get(node.id);
      if (position) {
        node.x = position.x;
        node.y = position.y;
        
        if (fix) {
          node.fx = position.x;
          node.fy = position.y;
        }
      }
    });
  }

  /**
   * Release fixed positions for specified nodes
   * @param {Array} nodeIds - Array of node IDs to unfix
   */
  unfixNodes(nodeIds = null) {
    const toUnfix = nodeIds ? new Set(nodeIds) : null;
    
    this.nodes.forEach(node => {
      if (!toUnfix || toUnfix.has(node.id)) {
        node.fx = null;
        node.fy = null;
      }
    });
  }

  /**
   * Fix a node at its current position
   * @param {string} nodeId - ID of node to fix
   */
  fixNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node.x !== undefined && node.y !== undefined) {
      node.fx = node.x;
      node.fy = node.y;
    }
  }

  /**
   * Temporarily increase simulation energy for layout adjustments
   * @param {number} alpha - Energy level (0-1)
   */
  reheat(alpha = 0.3) {
    if (this.simulation) {
      this.simulation.alpha(alpha).restart();
    }
  }

  /**
   * Configure force strengths dynamically
   * @param {Object} forceConfig - Object with force configuration
   */
  updateForceStrengths(forceConfig) {
    Object.assign(this.config, forceConfig);

    // Update existing forces
    const linkForce = this.simulation.force('link');
    if (linkForce && forceConfig.linkDistance !== undefined) {
      linkForce.distance(d => this.getLinkDistance(d));
    }
    if (linkForce && forceConfig.linkStrength !== undefined) {
      linkForce.strength(d => this.getLinkStrength(d));
    }

    const chargeForce = this.simulation.force('charge');
    if (chargeForce && forceConfig.chargeStrength !== undefined) {
      chargeForce.strength(d => this.getChargeStrength(d));
    }

    const collisionForce = this.simulation.force('collision');
    if (collisionForce && forceConfig.collisionRadius !== undefined) {
      collisionForce.radius(d => this.getCollisionRadius(d));
    }

    // Reheat to apply changes
    if (this.isRunning) {
      this.reheat();
    }
  }

  /**
   * Add custom force to the simulation
   * @param {string} name - Force name
   * @param {Function} force - D3 force function
   */
  addCustomForce(name, force) {
    if (this.simulation) {
      this.simulation.force(name, force);
    }
  }

  /**
   * Remove a force from the simulation
   * @param {string} name - Force name to remove
   */
  removeForce(name) {
    if (this.simulation) {
      this.simulation.force(name, null);
    }
  }

  /**
   * Get current simulation statistics
   * @returns {Object} - Simulation state information
   */
  getStats() {
    if (!this.simulation) {
      return null;
    }

    // Get forces by checking what forces are actually set
    const forces = [];
    const forceNames = ['link', 'charge', 'center', 'collision'];
    
    forceNames.forEach(name => {
      if (this.simulation.force(name)) {
        forces.push(name);
      }
    });

    // Check for any additional forces by trying common custom force names
    // This is a workaround since D3's internal _forces is not reliable
    const customForceNames = ['customX', 'customY', 'radial', 'x', 'y'];
    customForceNames.forEach(name => {
      if (this.simulation.force(name)) {
        forces.push(name);
      }
    });

    return {
      alpha: this.simulation.alpha(),
      alphaMin: this.simulation.alphaMin(),
      alphaTarget: this.simulation.alphaTarget(),
      isRunning: this.isRunning,
      nodeCount: this.nodes.length,
      linkCount: this.links.length,
      forces: forces,
      velocityDecay: this.simulation.velocityDecay()
    };
  }

  /**
   * Set tick callback function
   * @param {Function} callback - Function to call on each tick
   */
  onTickCallback(callback) {
    this.onTick = callback;
  }

  /**
   * Set end callback function
   * @param {Function} callback - Function to call when simulation ends
   */
  onEndCallback(callback) {
    this.onEnd = callback;
  }

  /**
   * Calculate the bounds of all nodes
   * @param {number} padding - Padding around the bounds
   * @returns {Object} - Bounds object {minX, maxX, minY, maxY, width, height}
   */
  getNodeBounds(padding = 0) {
    if (this.nodes.length === 0) {
      return null;
    }

    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        const radius = (node.size || 10) + padding;
        minX = Math.min(minX, node.x - radius);
        maxX = Math.max(maxX, node.x + radius);
        minY = Math.min(minY, node.y - radius);
        maxY = Math.max(maxY, node.y + radius);
      }
    });

    if (minX === Infinity) {
      return null;
    }

    return {
      minX, maxX, minY, maxY,
      width: maxX - minX,
      height: maxY - minY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }

  /**
   * Apply a layout preset
   * @param {string} layoutType - Type of layout ('circle', 'grid', 'random')
   * @param {Object} options - Layout-specific options
   */
  applyLayout(layoutType, options = {}) {
    const { width = this.config.width, height = this.config.height } = options;
    const centerX = width / 2;
    const centerY = height / 2;

    switch (layoutType) {
      case 'circle':
        this.applyCircleLayout(centerX, centerY, options);
        break;
      case 'grid':
        this.applyGridLayout(width, height, options);
        break;
      case 'random':
        this.applyRandomLayout(width, height, options);
        break;
      default:
        console.warn(`Unknown layout type: ${layoutType}`);
    }

    this.reheat();
  }

  /**
   * Apply circular layout
   * @param {number} centerX - Center X coordinate
   * @param {number} centerY - Center Y coordinate
   * @param {Object} options - Layout options
   */
  applyCircleLayout(centerX, centerY, options = {}) {
    const { radius = Math.min(this.config.width, this.config.height) / 3 } = options;
    const angleStep = (2 * Math.PI) / this.nodes.length;

    this.nodes.forEach((node, index) => {
      const angle = index * angleStep;
      node.x = centerX + radius * Math.cos(angle);
      node.y = centerY + radius * Math.sin(angle);
    });
  }

  /**
   * Apply grid layout
   * @param {number} width - Layout width
   * @param {number} height - Layout height
   * @param {Object} options - Layout options
   */
  applyGridLayout(width, height, options = {}) {
    const { padding = 50 } = options;
    const cols = Math.ceil(Math.sqrt(this.nodes.length));
    const rows = Math.ceil(this.nodes.length / cols);
    
    const cellWidth = (width - 2 * padding) / cols;
    const cellHeight = (height - 2 * padding) / rows;

    this.nodes.forEach((node, index) => {
      const col = index % cols;
      const row = Math.floor(index / cols);
      
      node.x = padding + col * cellWidth + cellWidth / 2;
      node.y = padding + row * cellHeight + cellHeight / 2;
    });
  }

  /**
   * Apply random layout
   * @param {number} width - Layout width
   * @param {number} height - Layout height
   * @param {Object} options - Layout options
   */
  applyRandomLayout(width, height, options = {}) {
    const { padding = 50 } = options;
    
    this.nodes.forEach(node => {
      node.x = padding + Math.random() * (width - 2 * padding);
      node.y = padding + Math.random() * (height - 2 * padding);
    });
  }

  /**
   * Cleanup and destroy the simulation
   */
  destroy() {
    if (this.simulation) {
      this.simulation.stop();
      this.simulation = null;
    }
    this.nodes = [];
    this.links = [];
    this.onTick = null;
    this.onEnd = null;
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ForceSimulation;
} else if (typeof window !== 'undefined') {
  window.ForceSimulation = ForceSimulation;
}

// core/InteractionManager.js
/**
 * Interaction Manager for Knowledge Graph Explorer
 * Handles mouse/touch interactions, hover effects, and event dispatching
 */
class InteractionManager {
  constructor(config = {}) {
    this.config = {
      hoverRadius: 50,
      maxHoverScale: 1.3,
      hoverTransitionDuration: 100,
      clickRadius: 20,
      doubleClickDelay: 300,
      dragThreshold: 5,
      ...config
    };

    // State
    this.nodes = [];
    this.links = [];
    this.coordinateTransform = null;
    this.isInLayerMode = false;
    this.hoveredNode = null;
    this.draggedNode = null;
    this.isDragging = false;
    this.lastClickTime = 0;
    this.lastClickNode = null;

    // DOM elements
    this.svgElement = null;
    this.nodeElements = null;
    this.linkElements = null;
    this.labelElements = null;

    // Event handlers
    this.eventHandlers = {};
    this.boundHandlers = {};

    this.setupBoundHandlers();
  }

  /**
   * Initialize interaction manager with DOM elements and coordinate transform
   * @param {Object} elements - Object containing SVG and D3 selections
   * @param {CoordinateTransform} coordinateTransform - Coordinate transformation utility
   */
  initialize(elements, coordinateTransform) {
    this.svgElement = elements.svg;
    this.nodeElements = elements.nodes;
    this.linkElements = elements.links;
    this.labelElements = elements.labels;
    this.coordinateTransform = coordinateTransform;

    this.setupEventListeners();
  }

  /**
   * Create bound handler functions to avoid memory leaks
   */
  setupBoundHandlers() {
    this.boundHandlers = {
      mousemove: this.handleMouseMove.bind(this),
      mouseleave: this.handleMouseLeave.bind(this),
      click: this.handleClick.bind(this),
      mousedown: this.handleMouseDown.bind(this),
      mouseup: this.handleMouseUp.bind(this),
      contextmenu: this.handleContextMenu.bind(this)
    };
  }

  /**
   * Setup event listeners on the SVG element
   */
  setupEventListeners() {
    if (!this.svgElement) return;

    // Mouse/touch events
    this.svgElement.on('mousemove', this.boundHandlers.mousemove);
    this.svgElement.on('mouseleave', this.boundHandlers.mouseleave);
    this.svgElement.on('click', this.boundHandlers.click);
    this.svgElement.on('mousedown', this.boundHandlers.mousedown);
    this.svgElement.on('mouseup', this.boundHandlers.mouseup);
    this.svgElement.on('contextmenu', this.boundHandlers.contextmenu);

    // Setup node-specific interactions
    this.setupNodeInteractions();
    this.setupLinkInteractions();
  }

  /**
   * Setup interactions specific to nodes
   */
  setupNodeInteractions() {
    if (!this.nodeElements) return;

    this.nodeElements
      .style('cursor', 'pointer')
      .on('click', (event, d) => {
        event.stopPropagation();
        this.handleNodeClick(event, d);
      })
      .on('mousedown', (event, d) => {
        event.stopPropagation();
        this.handleNodeMouseDown(event, d);
      })
      .on('mouseenter', (event, d) => {
        this.handleNodeMouseEnter(event, d);
      })
      .on('mouseleave', (event, d) => {
        this.handleNodeMouseLeave(event, d);
      });
  }

  /**
   * Setup interactions specific to links
   */
  setupLinkInteractions() {
    if (!this.linkElements) return;

    this.linkElements
      .style('cursor', 'pointer')
      .on('click', (event, d) => {
        event.stopPropagation();
        this.handleLinkClick(event, d);
      })
      .on('mouseenter', (event, d) => {
        this.handleLinkMouseEnter(event, d);
      })
      .on('mouseleave', (event, d) => {
        this.handleLinkMouseLeave(event, d);
      });
  }

  /**
   * Update data references
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   */
  updateData(nodes, links) {
    this.nodes = nodes || [];
    this.links = links || [];
  }

  /**
   * Update layer mode state
   * @param {boolean} isInLayerMode - Whether layer mode is active
   */
  updateLayerMode(isInLayerMode) {
    this.isInLayerMode = isInLayerMode;
  }

  /**
   * Handle mouse movement over the SVG
   * @param {Event} event - Mouse event
   */
  handleMouseMove(event) {
    if (this.isDragging) {
      this.handleDragMove(event);
      return;
    }

    if (this.isInLayerMode) return;

    // Get mouse position in graph coordinates
    const mousePos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());

    // Emit dock hover effects for the main graph
    this.emit('dockHover', { mousePosition: mousePos });

    this.updateContinuousHoverEffects(mousePos);
  }

  /**
   * Handle mouse leaving the SVG area
   * @param {Event} event - Mouse event
   */
  handleMouseLeave(event) {
    // Reset dock hover effects
    this.emit('dockHoverReset');

    this.resetHoverEffects();
    if (this.isDragging) {
      this.endDrag();
    }
  }

  /**
   * Handle click events on the SVG background
   * @param {Event} event - Mouse event
   */
  handleClick(event) {
    // Only handle background clicks (not propagated from nodes/links)
    this.emit('backgroundClick', { event });
  }

  /**
   * Handle mouse down events for drag initiation
   * @param {Event} event - Mouse event
   */
  handleMouseDown(event) {
    if (event.button !== 0) return; // Only left mouse button

    const mousePos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    const clickedNode = this.findNodeAtPosition(mousePos);

    if (clickedNode) {
      this.startDrag(event, clickedNode);
    }
  }

  /**
   * Handle mouse up events
   * @param {Event} event - Mouse event
   */
  handleMouseUp(event) {
    if (this.isDragging) {
      this.endDrag();
    }
  }

  /**
   * Handle context menu (right-click) events
   * @param {Event} event - Mouse event
   */
  handleContextMenu(event) {
    event.preventDefault();
    
    const mousePos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    const clickedNode = this.findNodeAtPosition(mousePos);

    if (clickedNode) {
      this.emit('nodeContextMenu', { node: clickedNode, event });
    } else {
      this.emit('backgroundContextMenu', { event });
    }
  }

  /**
   * Handle node click events
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeClick(event, node) {
    const currentTime = Date.now();
    const isDoubleClick = (currentTime - this.lastClickTime < this.config.doubleClickDelay) &&
                         (this.lastClickNode === node);

    if (isDoubleClick) {
      this.emit('nodeDoubleClick', { node, event });
    } else {
      this.emit('nodeClick', { node, event });
    }

    this.lastClickTime = currentTime;
    this.lastClickNode = node;
  }

  /**
   * Handle node mouse down for drag initiation
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeMouseDown(event, node) {
    this.startDrag(event, node);
  }

  /**
   * Handle node mouse enter
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeMouseEnter(event, node) {
    this.emit('nodeMouseEnter', { node, event });
  }

  /**
   * Handle node mouse leave
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeMouseLeave(event, node) {
    this.emit('nodeMouseLeave', { node, event });
  }

  /**
   * Handle link click events
   * @param {Event} event - Mouse event
   * @param {Object} link - Link data
   */
  handleLinkClick(event, link) {
    this.emit('linkClick', { link, event });
  }

  /**
   * Handle link mouse enter
   * @param {Event} event - Mouse event
   * @param {Object} link - Link data
   */
  handleLinkMouseEnter(event, link) {
    this.emit('linkMouseEnter', { link, event });
  }

  /**
   * Handle link mouse leave
   * @param {Event} event - Mouse event
   * @param {Object} link - Link data
   */
  handleLinkMouseLeave(event, link) {
    this.emit('linkMouseLeave', { link, event });
  }

  /**
   * Start drag operation
   * @param {Event} event - Mouse event
   * @param {Object} node - Node being dragged
   */
  startDrag(event, node) {
    this.draggedNode = node;
    this.isDragging = false; // Will become true if mouse moves beyond threshold
    this.dragStartPos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    
    // Prevent default to avoid text selection
    event.preventDefault();
  }

  /**
   * Handle drag movement
   * @param {Event} event - Mouse event
   */
  handleDragMove(event) {
    if (!this.draggedNode) return;

    const currentPos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    
    if (!this.isDragging) {
      // Check if we've moved beyond the drag threshold
      const distance = this.coordinateTransform.calculateDistance(this.dragStartPos, currentPos);
      if (distance > this.config.dragThreshold) {
        this.isDragging = true;
        this.emit('dragStart', { node: this.draggedNode, event });
      }
    }

    if (this.isDragging) {
      // Update node position
      this.draggedNode.fx = currentPos.x;
      this.draggedNode.fy = currentPos.y;
      
      this.emit('dragMove', { 
        node: this.draggedNode, 
        position: currentPos, 
        event 
      });
    }
  }

  /**
   * End drag operation
   */
  endDrag() {
    if (this.draggedNode) {
      if (this.isDragging) {
        this.emit('dragEnd', { node: this.draggedNode });
      }
      
      // Optionally release the node's fixed position
      // this.draggedNode.fx = null;
      // this.draggedNode.fy = null;
    }

    this.draggedNode = null;
    this.isDragging = false;
    this.dragStartPos = null;
  }

  /**
   * Find node at a specific position
   * @param {Object} position - {x, y} position in graph coordinates
   * @returns {Object|null} - Node at position or null
   */
  findNodeAtPosition(position) {
    const clickRadius = this.config.clickRadius;
    
    for (const node of this.nodes) {
      if (node.x !== undefined && node.y !== undefined) {
        const distance = this.coordinateTransform.calculateDistance(position, node);
        const nodeRadius = (node.size || 10) + clickRadius;
        
        if (distance <= nodeRadius) {
          return node;
        }
      }
    }
    
    return null;
  }

  /**
   * Update continuous hover effects based on mouse position
   * @param {Object} mousePosition - {x, y} mouse position in graph coordinates
   */
  updateContinuousHoverEffects(mousePosition) {
    // Find the closest node within hover radius
    let closestNode = null;
    let closestDistance = Infinity;

    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        const distance = this.coordinateTransform.calculateDistance(node, mousePosition);
        const nodeRadius = (node.size || 10);
        
        // Prioritize nodes that the mouse is directly over
        const isDirectlyOver = distance <= nodeRadius;
        
        if (isDirectlyOver && distance < closestDistance) {
          closestNode = node;
          closestDistance = distance;
        } else if (!closestNode && distance <= this.config.hoverRadius) {
          closestNode = node;
          closestDistance = distance;
        }
      }
    });

    if (closestNode !== this.hoveredNode) {
      if (this.hoveredNode) {
        this.emit('nodeHoverEnd', { node: this.hoveredNode });
      }
      
      this.hoveredNode = closestNode;
      
      if (this.hoveredNode) {
        this.emit('nodeHoverStart', { node: this.hoveredNode, distance: closestDistance });
      }
    }

    if (closestNode) {
      this.emit('nodeHover', { 
        node: closestNode, 
        distance: closestDistance, 
        mousePosition 
      });
    } else {
      this.emit('noHover', { mousePosition });
    }
  }

  /**
   * Reset all hover effects
   */
  resetHoverEffects() {
    if (this.hoveredNode) {
      this.emit('nodeHoverEnd', { node: this.hoveredNode });
      this.hoveredNode = null;
    }
    
    this.emit('hoverReset');
  }

  /**
   * Enable or disable node dragging
   * @param {boolean} enabled - Whether dragging should be enabled
   */
  setDragEnabled(enabled) {
    this.config.dragEnabled = enabled;
  }

  /**
   * Enable or disable hover effects
   * @param {boolean} enabled - Whether hover effects should be enabled
   */
  setHoverEnabled(enabled) {
    this.config.hoverEnabled = enabled;
    if (!enabled) {
      this.resetHoverEffects();
    }
  }

  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);
  }

  /**
   * Get interaction statistics
   * @returns {Object} - Interaction state information
   */
  getStats() {
    return {
      hoveredNode: this.hoveredNode ? this.hoveredNode.id : null,
      isDragging: this.isDragging,
      draggedNode: this.draggedNode ? this.draggedNode.id : null,
      isInLayerMode: this.isInLayerMode,
      config: { ...this.config }
    };
  }

  /**
   * Programmatically trigger hover on a specific node
   * @param {string} nodeId - ID of node to hover
   */
  hoverNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node !== this.hoveredNode) {
      if (this.hoveredNode) {
        this.emit('nodeHoverEnd', { node: this.hoveredNode });
      }
      
      this.hoveredNode = node;
      this.emit('nodeHoverStart', { node, distance: 0 });
      this.emit('nodeHover', { node, distance: 0, mousePosition: node });
    }
  }

  /**
   * Clear programmatic hover
   */
  clearHover() {
    this.resetHoverEffects();
  }

  /**
   * Add event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }

  /**
   * Remove event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function to remove
   */
  off(eventType, callback) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = this.eventHandlers[eventType].filter(cb => cb !== callback);
    }
    return this;
  }

  /**
   * Emit event to all listeners
   * @param {string} eventType - Type of event
   * @param {Object} data - Event data
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event handler for ${eventType}:`, error);
        }
      });
    }
  }

  /**
   * Remove all event listeners and cleanup
   */
  destroy() {
    // Remove DOM event listeners
    if (this.svgElement) {
      Object.values(this.boundHandlers).forEach(handler => {
        this.svgElement.on(handler.name, null);
      });
    }

    // Clear node and link interactions
    if (this.nodeElements) {
      this.nodeElements.on('.interaction', null);
    }
    if (this.linkElements) {
      this.linkElements.on('.interaction', null);
    }

    // Clear state
    this.eventHandlers = {};
    this.hoveredNode = null;
    this.draggedNode = null;
    this.isDragging = false;
    this.nodes = [];
    this.links = [];
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = InteractionManager;
} else if (typeof window !== 'undefined') {
  window.InteractionManager = InteractionManager;
}

// core/VisualEffectsManager.js
/**
 * Visual Effects Manager for Knowledge Graph Explorer
 * Handles 3D-style hover effects, layer transitions, audience filtering, and visual state management
 */
class VisualEffectsManager {
  constructor(config = {}) {
    this.config = {
      // Hover effect settings
      hoverRadius: 50,
      maxHoverScale: 1.3,
      hoverTransitionDuration: 100,
      
      // Layer effect settings
      layerTransitionDuration: 400,
      
      // Audience effect settings
      audienceTransitionDuration: 300,
      audienceBlurAmount: 2,
      audienceOpacityReduced: 0.3,
      
      // Distance-based scaling
      distanceScaling: {
        distance1: 0.9,
        distance2: 0.7,
        distance3: 0.5,
        distanceOther: 0.3
      },
      
      // Layer mode scaling
      layerScaling: {
        activeLayer: 1.0,
        connectedNodes: {
          distance1: 0.7,
          distance2: 0.5,
          distanceOther: 0.3
        },
        disconnectedNodes: 0.5  // Changed from 0.2 to 0.5 for less dramatic zoom out
      },
      
      // Theme settings
      theme: {
        fontSizeBase: 12,
        fontSizeSmall: 10,
        fontSizeLarge: 14,
        defaultOpacity: 1.0,
        dimmedOpacity: 0.6,
        baseStrokeWidth: 2
      },
      
      ...config
    };

    // State
    this.nodes = [];
    this.links = [];
    this.nodeDistances = new Map();
    this.isInLayerMode = false;
    this.isInAudienceMode = false;
    this.currentLayer = null;
    this.currentAudience = 'current_focus';
    this.hoveredNode = null;
    this.selectedNode = null;
    this.selectedNodeRelated = new Set();

    // DOM element references
    this.nodeElements = null;
    this.linkElements = null;
    this.labelElements = null;
  }

  /**
   * Initialize with DOM elements
   * @param {Object} elements - Object containing D3 selections
   */
  initialize(elements) {
    this.nodeElements = elements.nodes;
    this.linkElements = elements.links;
    this.labelElements = elements.labels;
  }

  /**
   * Update data references
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   */
  updateData(nodes, links) {
    this.nodes = nodes || [];
    this.links = links || [];
    this.nodeDistances.clear();
  }

  /**
   * Calculate graph distance between two nodes using BFS
   * @param {string} sourceId - Source node ID
   * @param {string} targetId - Target node ID
   * @returns {number} - Graph distance (hops between nodes)
   */
  calculateGraphDistance(sourceId, targetId) {
    if (sourceId === targetId) return 0;
    
    const cacheKey = `${sourceId}-${targetId}`;
    if (this.nodeDistances.has(cacheKey)) {
      return this.nodeDistances.get(cacheKey);
    }
    
    // Build adjacency list
    const adjacencyList = new Map();
    this.nodes.forEach(node => adjacencyList.set(node.id, []));
    
    this.links.forEach(link => {
      const sourceNodeId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetNodeId = typeof link.target === 'object' ? link.target.id : link.target;
      
      if (adjacencyList.has(sourceNodeId) && adjacencyList.has(targetNodeId)) {
        adjacencyList.get(sourceNodeId).push(targetNodeId);
        adjacencyList.get(targetNodeId).push(sourceNodeId);
      }
    });
    
    // BFS to find shortest path
    const queue = [{ nodeId: sourceId, distance: 0 }];
    const visited = new Set([sourceId]);
    
    while (queue.length > 0) {
      const { nodeId, distance } = queue.shift();
      
      if (nodeId === targetId) {
        this.nodeDistances.set(cacheKey, distance);
        this.nodeDistances.set(`${targetId}-${sourceId}`, distance);
        return distance;
      }
      
      const neighbors = adjacencyList.get(nodeId) || [];
      for (const neighborId of neighbors) {
        if (!visited.has(neighborId)) {
          visited.add(neighborId);
          queue.push({ nodeId: neighborId, distance: distance + 1 });
        }
      }
    }
    
    // No path found
    const maxDistance = 999;
    this.nodeDistances.set(cacheKey, maxDistance);
    this.nodeDistances.set(`${targetId}-${sourceId}`, maxDistance);
    return maxDistance;
  }

  /**
   * Apply continuous hover effects (Mac dock style)
   * @param {Object} centerNode - Node being hovered
   * @param {number} centerDistance - Distance from mouse to center node
   * @param {Object} mousePosition - Mouse position in graph coordinates
   */
  applyContinuousHoverEffects(centerNode, centerDistance, mousePosition) {
    if (this.isInLayerMode || this.isInAudienceMode) return;

    const nodeEffects = this.nodes.map(node => {
      let scaleFactor, opacityFactor;
    
      if (node.id === centerNode.id) {
        // Center node scales based on mouse proximity
        const proximityFactor = Math.max(0, 1 - centerDistance / this.config.hoverRadius);
        scaleFactor = 1 + (this.config.maxHoverScale - 1) * proximityFactor;
        opacityFactor = 1.0;
      } else {
        // Other nodes scale based on graph distance from center node
        const graphDistance = this.calculateGraphDistance(centerNode.id, node.id);
        const proximityFactor = Math.max(0, 1 - centerDistance / this.config.hoverRadius);
      
        let baseScale = this.getDistanceBasedScale(graphDistance);
      
        // Apply proximity-based scaling
        scaleFactor = baseScale + (1 - baseScale) * (1 - proximityFactor);
        opacityFactor = baseScale + (1 - baseScale) * (1 - proximityFactor);
      }
    
      return {
        nodeId: node.id,
        scaleFactor,
        opacityFactor
      };
    });
  
    this.applyNodeTransitions(nodeEffects, this.config.hoverTransitionDuration);
  }

  /**
   * Get scale factor based on graph distance
   * @param {number} distance - Graph distance
   * @returns {number} - Scale factor
   */
  getDistanceBasedScale(distance) {
    const scaling = this.config.distanceScaling;
    if (distance === 1) return scaling.distance1;
    if (distance === 2) return scaling.distance2;
    if (distance === 3) return scaling.distance3;
    return scaling.distanceOther;
  }

  /**
   * Reset all hover effects to normal state
   */
  resetHoverEffects() {
    if (this.isInLayerMode || this.isInAudienceMode) {
      // Don't reset if in layer or audience mode - other effects take precedence
      return;
    }

    this.resetToNormalState();
  }

  /**
   * Set selected node information for visual effects
   * @param {Object|null} selectedNode - Selected node or null
   * @param {Set} selectedNodeRelated - Set of related node IDs
   */
  setSelectedNode(selectedNode, selectedNodeRelated) {
    this.selectedNode = selectedNode;
    this.selectedNodeRelated = selectedNodeRelated || new Set();
  }

  /**
   * Apply audience-based visual effects (blur non-relevant nodes)
   * @param {string} audienceId - Current audience filter
   * @param {Array} nodes - Array of node objects
   */
  applyAudienceEffects(audienceId, nodes) {
    this.currentAudience = audienceId;
    this.isInAudienceMode = true;

    if (!this.nodeElements) return;
    
    // Apply blur and opacity effects based on audience relevance
    this.nodeElements
      .transition()
      .duration(this.config.audienceTransitionDuration)
      .style('filter', d => {
        // If this node is related to the selected node, never blur it
        if (this.selectedNode && this.selectedNodeRelated.has(d.id)) {
          return 'none';
        }

        // Handle audience as array or string
        let nodeAudience = d.audience || ['general'];
        if (typeof nodeAudience === 'string') {
          nodeAudience = [nodeAudience];
        }
        return nodeAudience.includes(audienceId) ? 'none' : `blur(${this.config.audienceBlurAmount}px)`;
      })
      .style('opacity', d => {
        // If this node is related to the selected node, full opacity
        if (this.selectedNode && this.selectedNodeRelated.has(d.id)) {
          return this.config.theme.defaultOpacity;
        }

        // Handle audience as array or string
        let nodeAudience = d.audience || ['general'];
        if (typeof nodeAudience === 'string') {
          nodeAudience = [nodeAudience];
        }
        return nodeAudience.includes(audienceId) ? this.config.theme.defaultOpacity : this.config.audienceOpacityReduced;
      });
    
    // Link visibility is now managed by KnowledgeGraphExplorer.updateLinkVisibility()
    // based on label visibility rather than audience relevance
  }

  /**
   * Reset all visual effects to normal state
   */
  resetToNormalState() {
    if (this.nodeElements) {
      this.nodeElements
        .transition()
        .duration(200)
        .ease(d3.easeQuadOut)
        .attr('r', d => d.size || 10)
        .attr('opacity', this.config.theme.defaultOpacity)
        .style('filter', 'none');
    }
    
    if (this.labelElements) {
      this.labelElements
        .transition()
        .duration(200)
        .ease(d3.easeQuadOut)
        .style('font-size', this.config.theme.fontSizeBase + 'px')
        .attr('opacity', this.config.theme.defaultOpacity);
    }
    
    if (this.linkElements) {
      this.linkElements
        .transition()
        .duration(200)
        .ease(d3.easeQuadOut)
        .attr('opacity', this.config.theme.dimmedOpacity)
        .attr('stroke-width', d => Math.sqrt(d.strength || 0.5) * this.config.theme.baseStrokeWidth)
        .style('filter', 'none');
    }
  }

  /**
   * Apply layer-based visual effects
   * @param {string} activeLayer - ID of the active layer
   */
  applyLayerEffects(activeLayer) {
    this.currentLayer = activeLayer;
    this.isInLayerMode = activeLayer !== null;
    
    if (!this.isInLayerMode) {
      // If no audience mode is active, reset to normal state
      if (!this.isInAudienceMode) {
        this.resetToNormalState();
      }
      return;
    }

    const nodeLayerEffects = this.nodes.map(node => {
      const isActiveLayer = node.layer === activeLayer;
      const hasActiveConnection = this.hasConnectionToActiveLayer(node, activeLayer);
      
      let scaleFactor, opacityFactor;
      
      if (isActiveLayer) {
        scaleFactor = this.config.layerScaling.activeLayer;
        opacityFactor = this.config.layerScaling.activeLayer;
      } else if (hasActiveConnection) {
        const distance = this.getMinDistanceToActiveLayer(node, activeLayer);
        const connectedScaling = this.config.layerScaling.connectedNodes;
        
        if (distance === 1) {
          scaleFactor = connectedScaling.distance1;
          opacityFactor = connectedScaling.distance1;
        } else if (distance === 2) {
          scaleFactor = connectedScaling.distance2;
          opacityFactor = connectedScaling.distance2;
        } else {
          scaleFactor = connectedScaling.distanceOther;
          opacityFactor = connectedScaling.distanceOther;
        }
      } else {
        scaleFactor = this.config.layerScaling.disconnectedNodes;
        opacityFactor = this.config.layerScaling.disconnectedNodes;
      }
      
      return {
        nodeId: node.id,
        scaleFactor,
        opacityFactor,
        isActiveLayer
      };
    });
    
    this.applyLayerTransitions(nodeLayerEffects);
  }

  /**
   * Check if node has connection to active layer
   * @param {Object} node - Node to check
   * @param {string} activeLayer - Active layer ID
   * @returns {boolean} - Whether node connects to active layer
   */
  hasConnectionToActiveLayer(node, activeLayer) {
    return this.links.some(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      
      if (node.id === sourceId) {
        const targetNode = this.nodes.find(n => n.id === targetId);
        return targetNode && targetNode.layer === activeLayer;
      } else if (node.id === targetId) {
        const sourceNode = this.nodes.find(n => n.id === sourceId);
        return sourceNode && sourceNode.layer === activeLayer;
      }
      
      return false;
    });
  }

  /**
   * Get minimum distance to any node in active layer
   * @param {Object} node - Node to check
   * @param {string} activeLayer - Active layer ID
   * @returns {number} - Minimum distance to active layer
   */
  getMinDistanceToActiveLayer(node, activeLayer) {
    const activeLayerNodes = this.nodes.filter(n => n.layer === activeLayer);
    let minDistance = 999;
    
    for (const activeNode of activeLayerNodes) {
      const distance = this.calculateGraphDistance(node.id, activeNode.id);
      minDistance = Math.min(minDistance, distance);
    }
    
    return minDistance;
  }

  /**
   * Apply node transitions for hover effects
   * @param {Array} nodeEffects - Array of effect objects
   * @param {number} duration - Transition duration in ms
   */
  applyNodeTransitions(nodeEffects, duration = 250) {
    const effectsMap = new Map();
    nodeEffects.forEach(effect => {
      effectsMap.set(effect.nodeId, effect);
    });
    
    if (this.nodeElements) {
      this.nodeElements
        .transition()
        .duration(duration)
        .ease(d3.easeQuadOut)
        .attr('r', d => {
          const effect = effectsMap.get(d.id);
          return (d.size || 10) * (effect ? effect.scaleFactor : 1);
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    
    if (this.labelElements) {
      this.labelElements
        .transition()
        .duration(duration)
        .ease(d3.easeQuadOut)
        .style('font-size', d => {
          const effect = effectsMap.get(d.id);
          const baseFontSize = this.config.theme.fontSizeBase;
          return `${baseFontSize * (effect ? effect.scaleFactor : 1)}px`;
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    
    if (this.linkElements) {
      this.linkElements
        .transition()
        .duration(duration)
        .ease(d3.easeQuadOut)
        .attr('opacity', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          
          const sourceEffect = effectsMap.get(sourceId);
          const targetEffect = effectsMap.get(targetId);
          
          const sourceOpacity = sourceEffect ? sourceEffect.opacityFactor : this.config.theme.defaultOpacity;
          const targetOpacity = targetEffect ? targetEffect.opacityFactor : this.config.theme.defaultOpacity;
          
          return Math.min(sourceOpacity, targetOpacity) * this.config.theme.dimmedOpacity;
        });
    }
  }

  /**
   * Apply layer transitions with longer duration and different easing
   * @param {Array} nodeLayerEffects - Array of layer effect objects
   */
  applyLayerTransitions(nodeLayerEffects) {
    const effectsMap = new Map();
    nodeLayerEffects.forEach(effect => {
      effectsMap.set(effect.nodeId, effect);
    });
    
    if (this.nodeElements) {
      this.nodeElements
        .transition()
        .duration(this.config.layerTransitionDuration)
        .ease(d3.easeQuadInOut)
        .attr('r', d => {
          const effect = effectsMap.get(d.id);
          return (d.size || 10) * (effect ? effect.scaleFactor : 1);
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    
    if (this.labelElements) {
      this.labelElements
        .transition()
        .duration(this.config.layerTransitionDuration)
        .ease(d3.easeQuadInOut)
        .style('font-size', d => {
          const effect = effectsMap.get(d.id);
          const baseFontSize = this.config.theme.fontSizeBase;
          return `${baseFontSize * (effect ? effect.scaleFactor : 1)}px`;
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    
    if (this.linkElements) {
      this.linkElements
        .transition()
        .duration(this.config.layerTransitionDuration)
        .ease(d3.easeQuadInOut)
        .attr('opacity', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          
          const sourceEffect = effectsMap.get(sourceId);
          const targetEffect = effectsMap.get(targetId);
          
          const sourceOpacity = sourceEffect ? sourceEffect.opacityFactor : this.config.theme.defaultOpacity;
          const targetOpacity = targetEffect ? targetEffect.opacityFactor : this.config.theme.defaultOpacity;
          
          return Math.min(sourceOpacity, targetOpacity) * this.config.theme.dimmedOpacity;
        })
        .attr('stroke-width', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          
          const sourceEffect = effectsMap.get(sourceId);
          const targetEffect = effectsMap.get(targetId);
          
          const baseWidth = Math.sqrt(d.strength || 0.5) * this.config.theme.baseStrokeWidth;
          const sourceScale = sourceEffect ? sourceEffect.scaleFactor : 1;
          const targetScale = targetEffect ? targetEffect.scaleFactor : 1;
          
          return baseWidth * Math.max(sourceScale, targetScale);
        });
    }
  }

  /**
   * Highlight specific nodes with special effects
   * @param {Array} nodeIds - Array of node IDs to highlight
   * @param {Object} highlightConfig - Highlight configuration
   */
  highlightNodes(nodeIds, highlightConfig = {}) {
    const config = {
      scaleFactor: 1.2,
      opacityFactor: 1.0,
      duration: 300,
      ...highlightConfig
    };

    const highlightSet = new Set(nodeIds);
    
    const nodeEffects = this.nodes.map(node => ({
      nodeId: node.id,
      scaleFactor: highlightSet.has(node.id) ? config.scaleFactor : 0.5,
      opacityFactor: highlightSet.has(node.id) ? config.opacityFactor : 0.3
    }));

    this.applyNodeTransitions(nodeEffects, config.duration);
  }

  /**
   * Create pulsing animation effect
   * @param {string} nodeId - Node ID to animate
   * @param {Object} pulseConfig - Pulse configuration
   */
  pulseNode(nodeId, pulseConfig = {}) {
    const config = {
      scaleFactor: 1.5,
      duration: 600,
      iterations: 3,
      ...pulseConfig
    };

    const node = this.nodes.find(n => n.id === nodeId);
    if (!node) return;

    const nodeElement = this.nodeElements ? this.nodeElements.filter(d => d.id === nodeId) : null;
    const labelElement = this.labelElements ? this.labelElements.filter(d => d.id === nodeId) : null;

    if (nodeElement && nodeElement.size() > 0) {
      const baseSize = node.size || 10;
      const baseFontSize = this.config.theme.fontSizeBase;

      // Create pulsing animation
      for (let i = 0; i < config.iterations; i++) {
        nodeElement
          .transition()
          .delay(i * config.duration)
          .duration(config.duration / 2)
          .ease(d3.easeQuadInOut)
          .attr('r', baseSize * config.scaleFactor)
          .transition()
          .duration(config.duration / 2)
          .ease(d3.easeQuadInOut)
          .attr('r', baseSize);

        if (labelElement && labelElement.size() > 0) {
          labelElement
            .transition()
            .delay(i * config.duration)
            .duration(config.duration / 2)
            .ease(d3.easeQuadInOut)
            .style('font-size', `${baseFontSize * config.scaleFactor}px`)
            .transition()
            .duration(config.duration / 2)
            .ease(d3.easeQuadInOut)
            .style('font-size', `${baseFontSize}px`);
        }
      }
    }
  }

  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);
  }

  /**
   * Get current visual state
   * @returns {Object} - Visual state information
   */
  getState() {
    return {
      isInLayerMode: this.isInLayerMode,
      isInAudienceMode: this.isInAudienceMode,
      currentLayer: this.currentLayer,
      currentAudience: this.currentAudience,
      hoveredNode: this.hoveredNode ? this.hoveredNode.id : null,
      nodeCount: this.nodes.length,
      linkCount: this.links.length,
      config: { ...this.config }
    };
  }

  /**
   * Clear distance cache (call when graph structure changes)
   */
  clearDistanceCache() {
    this.nodeDistances.clear();
  }

  /**
   * Cleanup and reset all effects
   */
  destroy() {
    this.resetToNormalState();
    this.nodeDistances.clear();
    this.nodes = [];
    this.links = [];
    this.hoveredNode = null;
    this.currentLayer = null;
    this.currentAudience = 'current_focus';
    this.isInLayerMode = false;
    this.isInAudienceMode = false;
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = VisualEffectsManager;
} else if (typeof window !== 'undefined') {
  window.VisualEffectsManager = VisualEffectsManager;
}

// core/MiniMapManager.js
/**
 * MiniMap Manager for Knowledge Graph Explorer
 * Handles the miniature overview map with viewport indicator and navigation
 */
class MiniMapManager {
  constructor(config = {}) {
    this.config = {
      width: 150,
      height: 120,
      padding: 10,
      position: 'bottom-left', // 'bottom-left', 'bottom-right', 'top-left', 'top-right'
      
      // Visual settings
      backgroundColor: '#f8f9faE6', // 90% opacity
      borderColor: '#2780e3',
      borderWidth: 1,
      borderRadius: 6,
      
      // Viewport indicator
      viewportColor: '#2780e3',
      viewportOpacity: 0.7,
      viewportStrokeWidth: 2,
      
      // Node/link styling in minimap
      nodeOpacity: 0.8,
      linkOpacity: 0.4,
      nodeMinSize: 1,
      nodeMaxSize: 3,
      linkStrokeWidth: 0.5,
      
      // Interaction
      clickToNavigate: true,
      showOnHover: false,
      
      ...config
    };

    // State
    this.nodes = [];
    this.links = [];
    this.isVisible = true;
    this.coordinateTransform = null;
    
    // Rendering state
    this.scale = 1;
    this.offsetX = 0;
    this.offsetY = 0;
    this.bounds = null;
    
    // DOM elements
    this.container = null;
    this.containerElement = null;
    this.svg = null;
    this.mainGroup = null;
    this.linkGroup = null;
    this.nodeGroup = null;
    this.viewportIndicator = null;

    // Event handlers
    this.eventHandlers = {};
  }

  /**
   * Initialize minimap with parent container and coordinate transform
   * @param {Element} parentContainer - Parent DOM element
   * @param {CoordinateTransform} coordinateTransform - Coordinate transformation utility
   */
  initialize(parentContainer, coordinateTransform) {
    this.container = parentContainer;
    this.coordinateTransform = coordinateTransform;
    
    this.createMiniMapContainer();
    this.setupSVG();
    this.setupEventListeners();
  }

  /**
   * Create the minimap container element
   */
  createMiniMapContainer() {
    this.containerElement = document.createElement('div');
    this.containerElement.className = 'mini-map';
    this.containerElement.style.cssText = this.getContainerStyles();
    
    this.container.appendChild(this.containerElement);
  }

  /**
   * Get CSS styles for the container
   * @returns {string} - CSS style string
   */
  getContainerStyles() {
    const position = this.getPositionStyles();
    
    return `
      position: absolute;
      width: ${this.config.width}px;
      height: ${this.config.height}px;
      background-color: ${this.config.backgroundColor};
      border: ${this.config.borderWidth}px solid ${this.config.borderColor};
      border-radius: ${this.config.borderRadius}px;
      overflow: hidden;
      cursor: pointer;
      backdrop-filter: blur(5px);
      z-index: 10;
      ${position}
    `.replace(/\s+/g, ' ').trim();
  }

  /**
   * Get position styles based on configuration
   * @returns {string} - Position CSS
   */
  getPositionStyles() {
    const margin = 10;
    
    switch (this.config.position) {
      case 'top-left':
        return `top: ${margin}px; left: ${margin}px;`;
      case 'top-right':
        return `top: ${margin}px; right: ${margin}px;`;
      case 'bottom-right':
        return `bottom: ${margin}px; right: ${margin}px;`;
      case 'bottom-left':
      default:
        return `bottom: ${margin}px; left: ${margin}px;`;
    }
  }

  /**
   * Setup SVG and its groups
   */
  setupSVG() {
    this.svg = d3.select(this.containerElement)
      .append('svg')
      .attr('width', this.config.width)
      .attr('height', this.config.height);

    // Create groups for different elements
    this.mainGroup = this.svg.append('g').attr('class', 'mini-map-main');
    this.linkGroup = this.mainGroup.append('g').attr('class', 'mini-map-links');
    this.nodeGroup = this.mainGroup.append('g').attr('class', 'mini-map-nodes');
    
    // Create viewport indicator
    this.viewportIndicator = this.svg.append('rect')
      .attr('class', 'viewport-indicator')
      .attr('fill', 'none')
      .attr('stroke', this.config.viewportColor)
      .attr('stroke-width', this.config.viewportStrokeWidth)
      .attr('opacity', this.config.viewportOpacity);
  }

  /**
   * Setup event listeners
   */
  setupEventListeners() {
    if (this.config.clickToNavigate) {
      this.svg.on('click', (event) => {
        const [x, y] = d3.pointer(event);
        this.navigateToPosition(x, y);
      });
    }

    if (this.config.showOnHover) {
      this.containerElement.addEventListener('mouseenter', () => {
        this.show();
      });
      
      this.containerElement.addEventListener('mouseleave', () => {
        this.hide();
      });
    }
  }

  /**
   * Update data and refresh the minimap
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   */
  updateData(nodes, links) {
    this.nodes = nodes || [];
    this.links = links || [];
    this.render();
  }

  /**
   * Calculate bounds of all nodes
   * @returns {Object|null} - Bounds object or null if no nodes
   */
  calculateBounds() {
    if (this.nodes.length === 0) return null;

    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        minX = Math.min(minX, node.x);
        maxX = Math.max(maxX, node.x);
        minY = Math.min(minY, node.y);
        maxY = Math.max(maxY, node.y);
      }
    });

    if (minX === Infinity) return null;

    return {
      minX, maxX, minY, maxY,
      width: maxX - minX,
      height: maxY - minY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }

  /**
   * Calculate scale and offset for fitting content
   */
  calculateTransform() {
    this.bounds = this.calculateBounds();
    if (!this.bounds) {
      this.scale = 1;
      this.offsetX = 0;
      this.offsetY = 0;
      return;
    }

    const availableWidth = this.config.width - 2 * this.config.padding;
    const availableHeight = this.config.height - 2 * this.config.padding;

    const scaleX = availableWidth / this.bounds.width;
    const scaleY = availableHeight / this.bounds.height;
    this.scale = Math.min(scaleX, scaleY, 0.3); // Max scale to prevent too much zoom

    this.offsetX = (this.config.width - this.bounds.width * this.scale) / 2 - this.bounds.minX * this.scale;
    this.offsetY = (this.config.height - this.bounds.height * this.scale) / 2 - this.bounds.minY * this.scale;
  }

  /**
   * Render the minimap
   */
  render() {
    this.calculateTransform();
    this.renderLinks();
    this.renderNodes();
    this.updateViewportIndicator();
  }

  /**
   * Render links in the minimap
   */
  renderLinks() {
    if (!this.bounds) return;

    const linkSelection = this.linkGroup
      .selectAll('line')
      .data(this.links, d => d.id || `${d.source}-${d.target}`);

    linkSelection.exit().remove();

    linkSelection.enter()
      .append('line')
      .attr('stroke', this.config.borderColor)
      .attr('stroke-width', this.config.linkStrokeWidth)
      .attr('stroke-opacity', this.config.linkOpacity)
      .merge(linkSelection)
      .attr('x1', d => {
        const sourceNode = this.nodes.find(n => n.id === (typeof d.source === 'object' ? d.source.id : d.source));
        return this.offsetX + (sourceNode ? sourceNode.x : 0) * this.scale;
      })
      .attr('y1', d => {
        const sourceNode = this.nodes.find(n => n.id === (typeof d.source === 'object' ? d.source.id : d.source));
        return this.offsetY + (sourceNode ? sourceNode.y : 0) * this.scale;
      })
      .attr('x2', d => {
        const targetNode = this.nodes.find(n => n.id === (typeof d.target === 'object' ? d.target.id : d.target));
        return this.offsetX + (targetNode ? targetNode.x : 0) * this.scale;
      })
      .attr('y2', d => {
        const targetNode = this.nodes.find(n => n.id === (typeof d.target === 'object' ? d.target.id : d.target));
        return this.offsetY + (targetNode ? targetNode.y : 0) * this.scale;
      });
  }

  /**
   * Render nodes in the minimap
   */
  renderNodes() {
    if (!this.bounds) return;

    const nodeSelection = this.nodeGroup
      .selectAll('circle')
      .data(this.nodes, d => d.id);

    nodeSelection.exit().remove();

    nodeSelection.enter()
      .append('circle')
      .attr('stroke', 'none')
      .attr('opacity', this.config.nodeOpacity)
      .merge(nodeSelection)
      .attr('cx', d => this.offsetX + d.x * this.scale)
      .attr('cy', d => this.offsetY + d.y * this.scale)
      .attr('r', d => this.getNodeRadius(d))
      .attr('fill', d => this.getNodeColor(d));
  }

  /**
   * Get node radius for minimap
   * @param {Object} node - Node object
   * @returns {number} - Radius value
   */
  getNodeRadius(node) {
    const baseRadius = (node.size || 10) / 10; // Normalize
    return Math.max(
      this.config.nodeMinSize,
      Math.min(this.config.nodeMaxSize, baseRadius)
    );
  }

  /**
   * Get node color (can be overridden for custom coloring)
   * @param {Object} node - Node object
   * @returns {string} - Color value
   */
  getNodeColor(node) {
    // Default color scheme - can be customized
    const colorMap = {
      'education': '#2780e3',
      'research': '#3fb618',
      'industry': '#ffdd3c',
      'current': '#ff0039',
      'geographic': '#613d7c'
    };
    
    return colorMap[node.type] || colorMap[node.layer] || this.config.borderColor;
  }

  /**
   * Update viewport indicator based on current zoom/pan
   */
  updateViewportIndicator() {
    if (!this.coordinateTransform || !this.bounds) return;

    const transform = this.coordinateTransform.getTransform();
    const viewport = this.coordinateTransform.getVisibleBounds();

    // Calculate viewport rectangle in minimap coordinates
    const viewportWidth = viewport.width * this.scale;
    const viewportHeight = viewport.height * this.scale;
    
    const viewportX = this.offsetX + (viewport.minX - this.bounds.minX) * this.scale;
    const viewportY = this.offsetY + (viewport.minY - this.bounds.minY) * this.scale;

    // Clamp to minimap boundaries
    const clampedX = Math.max(0, Math.min(this.config.width - viewportWidth, viewportX));
    const clampedY = Math.max(0, Math.min(this.config.height - viewportHeight, viewportY));
    const clampedWidth = Math.min(viewportWidth, this.config.width - clampedX);
    const clampedHeight = Math.min(viewportHeight, this.config.height - clampedY);

    this.viewportIndicator
      .attr('x', clampedX)
      .attr('y', clampedY)
      .attr('width', Math.max(1, clampedWidth))
      .attr('height', Math.max(1, clampedHeight));
  }

  /**
   * Navigate to a position clicked in the minimap
   * @param {number} miniX - X coordinate in minimap
   * @param {number} miniY - Y coordinate in minimap
   */
  navigateToPosition(miniX, miniY) {
    if (!this.coordinateTransform || !this.bounds) return;

    // Convert minimap coordinates to graph coordinates
    const graphX = (miniX - this.offsetX) / this.scale + this.bounds.minX;
    const graphY = (miniY - this.offsetY) / this.scale + this.bounds.minY;

    this.emit('navigate', { 
      graphPosition: { x: graphX, y: graphY },
      miniMapPosition: { x: miniX, y: miniY }
    });
  }

  /**
   * Set minimap position
   * @param {string} position - Position string
   */
  setPosition(position) {
    this.config.position = position;
    if (this.containerElement) {
      const positionStyles = this.getPositionStyles();
      this.containerElement.style.cssText = this.getContainerStyles();
    }
  }

  /**
   * Show the minimap
   */
  show() {
    this.isVisible = true;
    if (this.containerElement) {
      this.containerElement.style.display = 'block';
    }
  }

  /**
   * Hide the minimap
   */
  hide() {
    this.isVisible = false;
    if (this.containerElement) {
      this.containerElement.style.display = 'none';
    }
  }

  /**
   * Toggle minimap visibility
   */
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * Update minimap size
   * @param {number} width - New width
   * @param {number} height - New height
   */
  resize(width, height) {
    this.config.width = width;
    this.config.height = height;
    
    if (this.containerElement) {
      this.containerElement.style.width = width + 'px';
      this.containerElement.style.height = height + 'px';
    }
    
    if (this.svg) {
      this.svg.attr('width', width).attr('height', height);
    }
    
    this.render();
  }

  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);
    
    if (this.containerElement) {
      this.containerElement.style.cssText = this.getContainerStyles();
    }
    
    this.render();
  }

  /**
   * Get minimap statistics
   * @returns {Object} - Minimap state information
   */
  getStats() {
    return {
      isVisible: this.isVisible,
      position: this.config.position,
      dimensions: {
        width: this.config.width,
        height: this.config.height
      },
      bounds: this.bounds,
      transform: {
        scale: this.scale,
        offsetX: this.offsetX,
        offsetY: this.offsetY
      },
      nodeCount: this.nodes.length,
      linkCount: this.links.length
    };
  }

  /**
   * Focus on a specific node in the minimap
   * @param {string} nodeId - Node ID to focus on
   */
  focusNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node.x !== undefined && node.y !== undefined) {
      this.navigateToPosition(
        this.offsetX + node.x * this.scale,
        this.offsetY + node.y * this.scale
      );
    }
  }

  /**
   * Highlight specific nodes in the minimap
   * @param {Array} nodeIds - Array of node IDs to highlight
   * @param {Object} highlightConfig - Highlight configuration
   */
  highlightNodes(nodeIds, highlightConfig = {}) {
    const config = {
      color: '#ff0039',
      strokeWidth: 2,
      ...highlightConfig
    };

    const highlightSet = new Set(nodeIds);
    
    this.nodeGroup.selectAll('circle')
      .attr('stroke', d => highlightSet.has(d.id) ? config.color : 'none')
      .attr('stroke-width', d => highlightSet.has(d.id) ? config.strokeWidth : 0);
  }

  /**
   * Clear all highlights
   */
  clearHighlights() {
    this.nodeGroup.selectAll('circle')
      .attr('stroke', 'none')
      .attr('stroke-width', 0);
  }

  /**
   * Add event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }

  /**
   * Remove event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function to remove
   */
  off(eventType, callback) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = this.eventHandlers[eventType].filter(cb => cb !== callback);
    }
    return this;
  }

  /**
   * Emit event to all listeners
   * @param {string} eventType - Type of event
   * @param {Object} data - Event data
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in minimap event handler for ${eventType}:`, error);
        }
      });
    }
  }

  /**
   * Cleanup and destroy the minimap
   */
  destroy() {
    // Remove DOM elements
    if (this.containerElement && this.container) {
      this.container.removeChild(this.containerElement);
    }

    // Clear references
    this.eventHandlers = {};
    this.nodes = [];
    this.links = [];
    this.containerElement = null;
    this.svg = null;
    this.coordinateTransform = null;
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = MiniMapManager;
} else if (typeof window !== 'undefined') {
  window.MiniMapManager = MiniMapManager;
}

// core/LabelLayoutManager.js
/**
 * Label Layout Manager for Knowledge Graph Explorer
 * Handles intelligent positioning of node labels to prevent overlaps
 */
class LabelLayoutManager {
  constructor(config = {}) {
    this.config = {
      // Label positioning preferences
      enabled: true,
      preferredPositions: ['bottom', 'right', 'top', 'left'],
      maxDistance: 50,
      minDistance: 15,
      padding: 8,

      // Collision detection
      collisionIterations: 3,
      positioningIterations: 2,

      // Animation
      transitionDuration: 200,

      // Font metrics (estimated ratios for common fonts)
      fontMetrics: {
        widthRatio: 0.6,  // Character width to font size ratio
        heightRatio: 1.1  // Line height to font size ratio
      },

      ...config
    };

    this.labels = [];
    this.nodes = [];
    this.labelElements = null;
    this.currentZoomScale = 1;

    // Cache for text measurements
    this.textMeasureCache = new Map();

    // Position constants for different directions
    this.POSITIONS = {
      bottom: { dx: 0, dy: 1 },
      right: { dx: 1, dy: 0 },
      top: { dx: 0, dy: -1 },
      left: { dx: -1, dy: 0 }
    };
  }

  /**
   * Initialize with node data and label elements
   * @param {Array} nodes - Array of node objects
   * @param {Selection} labelElements - D3 selection of label elements
   */
  initialize(nodes, labelElements) {
    this.nodes = nodes;
    this.labelElements = labelElements;
    this.updateLabelData();
  }

  /**
   * Update label data from current node positions and visibility
   */
  updateLabelData() {
    if (!this.labelElements || !this.nodes) return;

    this.labels = [];

    this.labelElements.each((d, i, nodes) => {
      const element = nodes[i];
      const node = d;

      // Only process visible labels
      const opacity = parseFloat(d3.select(element).style('opacity')) || 0;
      if (opacity <= 0) return;

      const labelData = {
        id: node.id,
        node: node,
        element: element,
        text: node.label || '',
        originalX: node.x,
        originalY: node.y + (node.size || 10) + 18,
        x: node.x,
        y: node.y + (node.size || 10) + 18,
        width: 0,
        height: 0,
        fontSize: this.getCurrentFontSize(element),
        preferredPosition: 'bottom',
        currentPosition: 'bottom'
      };

      // Calculate text dimensions
      this.calculateTextDimensions(labelData);

      this.labels.push(labelData);
    });
  }

  /**
   * Calculate text dimensions for a label
   * @param {Object} labelData - Label data object
   */
  calculateTextDimensions(labelData) {
    const cacheKey = `${labelData.text}_${labelData.fontSize}_${this.currentZoomScale}`;

    if (this.textMeasureCache.has(cacheKey)) {
      const cached = this.textMeasureCache.get(cacheKey);
      labelData.width = cached.width;
      labelData.height = cached.height;
      return;
    }

    // Use text measurement if available, otherwise estimate
    if (labelData.element) {
      try {
        const bbox = labelData.element.getBBox();
        labelData.width = bbox.width;
        labelData.height = bbox.height;
      } catch (e) {
        // Fallback to estimation
        this.estimateTextDimensions(labelData);
      }
    } else {
      this.estimateTextDimensions(labelData);
    }

    // Cache the result
    this.textMeasureCache.set(cacheKey, {
      width: labelData.width,
      height: labelData.height
    });

    // Limit cache size
    if (this.textMeasureCache.size > 200) {
      const firstKey = this.textMeasureCache.keys().next().value;
      this.textMeasureCache.delete(firstKey);
    }
  }

  /**
   * Estimate text dimensions based on font metrics
   * @param {Object} labelData - Label data object
   */
  estimateTextDimensions(labelData) {
    const fontSize = labelData.fontSize;
    const text = labelData.text || '';

    labelData.width = text.length * fontSize * this.config.fontMetrics.widthRatio;
    labelData.height = fontSize * this.config.fontMetrics.heightRatio;
  }

  /**
   * Get current font size from element or zoom-adjusted default
   * @param {Element} element - Label element
   * @returns {number} Font size in pixels
   */
  getCurrentFontSize(element) {
    if (element) {
      const style = window.getComputedStyle(element);
      const fontSize = parseFloat(style.fontSize);
      if (!isNaN(fontSize)) return fontSize;
    }

    // Fallback: estimate based on zoom scale
    const baseSize = 14;
    return baseSize / this.currentZoomScale;
  }

  /**
   * Update zoom scale for font size calculations
   * @param {number} zoomScale - Current zoom scale
   */
  updateZoomScale(zoomScale) {
    this.currentZoomScale = zoomScale;
    this.textMeasureCache.clear(); // Clear cache when zoom changes
  }

  /**
   * Calculate optimal label positions to avoid overlaps
   * @param {Array} visibleLabels - Array of visible labels (optional, uses all if not provided)
   */
  calculateOptimalPositions(visibleLabels = null) {
    if (!this.config.enabled) return;

    const labelsToProcess = visibleLabels || this.labels.filter(label =>
      this.labelElements && this.labelElements.filter(function() { return this === label.element; }).size() > 0
    );

    if (labelsToProcess.length === 0) return;

    // Update text dimensions for all labels
    labelsToProcess.forEach(label => {
      this.calculateTextDimensions(label);
    });

    // Apply collision avoidance algorithm
    for (let iteration = 0; iteration < this.config.positioningIterations; iteration++) {
      this.resolveCollisions(labelsToProcess);
    }
  }

  /**
   * Resolve collisions between labels using intelligent repositioning
   * @param {Array} labels - Labels to process
   */
  resolveCollisions(labels) {
    // Create spatial index for efficient collision detection
    const spatialIndex = this.createSpatialIndex(labels);

    for (let i = 0; i < labels.length; i++) {
      const labelA = labels[i];
      const conflicts = this.findConflicts(labelA, spatialIndex);

      if (conflicts.length > 0) {
        this.repositionLabel(labelA, conflicts);
      }
    }
  }

  /**
   * Create a simple spatial index for labels
   * @param {Array} labels - Labels to index
   * @returns {Map} Spatial index map
   */
  createSpatialIndex(labels) {
    const gridSize = 100;
    const index = new Map();

    labels.forEach(label => {
      const bounds = this.getLabelBounds(label);
      const gridX = Math.floor(bounds.centerX / gridSize);
      const gridY = Math.floor(bounds.centerY / gridSize);

      // Add to multiple grid cells if label spans across them
      for (let x = Math.floor(bounds.left / gridSize); x <= Math.floor(bounds.right / gridSize); x++) {
        for (let y = Math.floor(bounds.top / gridSize); y <= Math.floor(bounds.bottom / gridSize); y++) {
          const key = `${x},${y}`;
          if (!index.has(key)) index.set(key, []);
          index.get(key).push(label);
        }
      }
    });

    return index;
  }

  /**
   * Find labels that conflict with the given label
   * @param {Object} label - Label to check conflicts for
   * @param {Map} spatialIndex - Spatial index for efficient lookup
   * @returns {Array} Array of conflicting labels
   */
  findConflicts(label, spatialIndex) {
    const bounds = this.getLabelBounds(label);
    const gridSize = 100;
    const conflicts = new Set();

    // Check relevant grid cells
    for (let x = Math.floor(bounds.left / gridSize); x <= Math.floor(bounds.right / gridSize); x++) {
      for (let y = Math.floor(bounds.top / gridSize); y <= Math.floor(bounds.bottom / gridSize); y++) {
        const key = `${x},${y}`;
        const candidates = spatialIndex.get(key) || [];

        candidates.forEach(candidate => {
          if (candidate.id !== label.id && this.labelsOverlap(label, candidate)) {
            conflicts.add(candidate);
          }
        });
      }
    }

    return Array.from(conflicts);
  }

  /**
   * Check if two labels overlap
   * @param {Object} labelA - First label
   * @param {Object} labelB - Second label
   * @returns {boolean} True if labels overlap
   */
  labelsOverlap(labelA, labelB) {
    const boundsA = this.getLabelBounds(labelA);
    const boundsB = this.getLabelBounds(labelB);

    return !(boundsA.right < boundsB.left ||
             boundsA.left > boundsB.right ||
             boundsA.bottom < boundsB.top ||
             boundsA.top > boundsB.bottom);
  }

  /**
   * Get bounding box for a label including padding
   * @param {Object} label - Label object
   * @returns {Object} Bounding box {left, right, top, bottom, centerX, centerY}
   */
  getLabelBounds(label) {
    const padding = this.config.padding;
    const halfWidth = label.width / 2;
    const halfHeight = label.height / 2;

    return {
      left: label.x - halfWidth - padding,
      right: label.x + halfWidth + padding,
      top: label.y - halfHeight - padding,
      bottom: label.y + halfHeight + padding,
      centerX: label.x,
      centerY: label.y
    };
  }

  /**
   * Reposition a label to avoid conflicts
   * @param {Object} label - Label to reposition
   * @param {Array} conflicts - Conflicting labels
   */
  repositionLabel(label, conflicts) {
    const node = label.node;
    let bestPosition = null;
    let bestScore = -Infinity;

    // Try each preferred position
    for (const position of this.config.preferredPositions) {
      const candidatePos = this.calculatePositionForDirection(node, label, position);
      const score = this.scorePosition(candidatePos, conflicts, label);

      if (score > bestScore) {
        bestScore = score;
        bestPosition = candidatePos;
      }
    }

    if (bestPosition) {
      label.x = bestPosition.x;
      label.y = bestPosition.y;
      label.currentPosition = bestPosition.direction;
    }
  }

  /**
   * Calculate label position for a specific direction from node
   * @param {Object} node - Node object
   * @param {Object} label - Label object
   * @param {string} direction - Direction ('bottom', 'right', 'top', 'left')
   * @returns {Object} Position {x, y, direction}
   */
  calculatePositionForDirection(node, label, direction) {
    const pos = this.POSITIONS[direction];
    const nodeRadius = node.size || 10;
    const distance = this.config.minDistance + nodeRadius;

    let x = node.x;
    let y = node.y;

    if (direction === 'bottom') {
      y = node.y + distance + (label.height / 2);
    } else if (direction === 'top') {
      y = node.y - distance - (label.height / 2);
    } else if (direction === 'right') {
      x = node.x + distance + (label.width / 2);
    } else if (direction === 'left') {
      x = node.x - distance - (label.width / 2);
    }

    return { x, y, direction };
  }

  /**
   * Score a position based on conflicts and preferences
   * @param {Object} position - Position to score
   * @param {Array} conflicts - Conflicting labels
   * @param {Object} label - Label being positioned
   * @returns {number} Position score (higher is better)
   */
  scorePosition(position, conflicts, label) {
    let score = 0;

    // Create temporary label with new position
    const tempLabel = { ...label, x: position.x, y: position.y };

    // Penalty for conflicts
    conflicts.forEach(conflict => {
      if (this.labelsOverlap(tempLabel, conflict)) {
        score -= 100;
      }
    });

    // Bonus for preferred positions
    const preferenceIndex = this.config.preferredPositions.indexOf(position.direction);
    score += (this.config.preferredPositions.length - preferenceIndex) * 10;

    // Penalty for distance from node
    const distance = Math.sqrt(
      Math.pow(position.x - label.node.x, 2) +
      Math.pow(position.y - label.node.y, 2)
    );

    if (distance > this.config.maxDistance) {
      score -= (distance - this.config.maxDistance) * 2;
    }

    return score;
  }

  /**
   * Apply calculated positions to label elements with animation
   * @param {Array} labelsToUpdate - Labels to update (optional, uses all if not provided)
   */
  applyPositions(labelsToUpdate = null) {
    if (!this.labelElements) return;

    const labels = labelsToUpdate || this.labels;

    // Update positions with smooth transitions
    labels.forEach(label => {
      const element = d3.select(label.element);

      if (this.config.transitionDuration > 0) {
        element
          .transition()
          .duration(this.config.transitionDuration)
          .ease(d3.easeQuadOut)
          .attr('x', label.x)
          .attr('y', label.y);
      } else {
        element
          .attr('x', label.x)
          .attr('y', label.y);
      }
    });
  }

  /**
   * Update data and recalculate positions
   * @param {Array} nodes - Updated node array
   * @param {Selection} labelElements - Updated label elements
   */
  updateData(nodes, labelElements) {
    this.nodes = nodes;
    this.labelElements = labelElements;
    this.updateLabelData();

    if (this.config.enabled) {
      this.calculateOptimalPositions();
      this.applyPositions();
    }
  }

  /**
   * Force immediate position update without animation
   */
  forceUpdate() {
    this.updateLabelData();

    if (this.config.enabled) {
      this.calculateOptimalPositions();

      // Apply positions immediately
      const originalDuration = this.config.transitionDuration;
      this.config.transitionDuration = 0;
      this.applyPositions();
      this.config.transitionDuration = originalDuration;
    }
  }

  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);

    if (this.config.enabled) {
      this.forceUpdate();
    }
  }

  /**
   * Enable or disable label collision detection
   * @param {boolean} enabled - Whether to enable collision detection
   */
  setEnabled(enabled) {
    this.config.enabled = enabled;

    if (enabled) {
      this.forceUpdate();
    }
  }

  /**
   * Clear all cached data
   */
  clearCache() {
    this.textMeasureCache.clear();
  }

  /**
   * Get statistics about current label layout
   * @returns {Object} Layout statistics
   */
  getStats() {
    const stats = {
      totalLabels: this.labels.length,
      cacheSize: this.textMeasureCache.size,
      positionDistribution: {},
      averageDistance: 0
    };

    // Count position distribution
    this.labels.forEach(label => {
      const pos = label.currentPosition;
      stats.positionDistribution[pos] = (stats.positionDistribution[pos] || 0) + 1;
    });

    // Calculate average distance from nodes
    if (this.labels.length > 0) {
      const totalDistance = this.labels.reduce((sum, label) => {
        const distance = Math.sqrt(
          Math.pow(label.x - label.node.x, 2) +
          Math.pow(label.y - label.node.y, 2)
        );
        return sum + distance;
      }, 0);

      stats.averageDistance = totalDistance / this.labels.length;
    }

    return stats;
  }

  /**
   * Cleanup and destroy the manager
   */
  destroy() {
    this.labels = [];
    this.nodes = [];
    this.labelElements = null;
    this.textMeasureCache.clear();
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = LabelLayoutManager;
} else if (typeof window !== 'undefined') {
  window.LabelLayoutManager = LabelLayoutManager;
}

// core/UIControlsManager.js
/**
 * UI Controls Manager for Knowledge Graph Explorer
 * Handles timeline controls, layer buttons, audience filtering, info panels, and other UI elements
 */
class UIControlsManager {
  constructor(config = {}) {
    this.config = {
      showTimeline: true,
      showLayerControls: true,
      showAudienceControls: true,
      showNodeInfo: true,
      showMiniMap: true,
      timelineHeight: 60,
      controlPanelWidth: 200,
      ...config
    };

    // State
    this.graph = null;
    this.container = null;
    this.layers = [];
    this.timeline = { start: 2000, end: 2025 };
    this.currentTimelinePosition = null;
    this.activeLayer = null;
    this.activeAudience = 'current_focus';
    this.selectedNode = null;

    // DOM elements
    this.uiContainer = null;
    this.timelineContainer = null;
    this.layerContainer = null;
    this.audienceContainer = null;
    this.infoPanel = null;
    this.timelineSlider = null;
    this.refreshButton = null;

    // Event handlers
    this.eventHandlers = {};
  }

  /**
   * Detect if dark theme is currently active
   * @returns {boolean} True if dark theme is active
   */
  isDarkTheme() {
    // Check for Quarto's dark theme attribute
    if (document.documentElement.getAttribute('data-bs-theme') === 'dark') {
      return true;
    }

    // Check for manual dark theme classes
    if (document.body.classList.contains('dark-theme') ||
        document.documentElement.classList.contains('dark-theme')) {
      return true;
    }

    // Check for dark background color on body as fallback
    const bodyStyles = window.getComputedStyle(document.body);
    const bodyBg = bodyStyles.backgroundColor;
    if (bodyBg) {
      // Convert rgb to hex for comparison if needed
      const rgb = bodyBg.match(/\d+/g);
      if (rgb) {
        const r = parseInt(rgb[0]);
        const g = parseInt(rgb[1]);
        const b = parseInt(rgb[2]);
        // Consider it dark if background is darker than medium gray
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
      }
    }

    return false;
  }

  /**
   * Get theme-appropriate colors for UI elements
   * @returns {Object} Color scheme object
   */
  getThemeColors() {
    const isDark = this.isDarkTheme();

    if (isDark) {
      return {
        background: '#2d2d2d',
        border: '#404040',
        text: '#e9ecef',
        textSecondary: '#adb5bd',
        containerBg: 'rgba(45, 45, 45, 0.98)',
        accent: '#ffdd3c'
      };
    } else {
      return {
        background: '#f8f9fa',
        border: '#e9ecef',
        text: '#333',
        textSecondary: '#555',
        containerBg: 'rgba(255, 255, 255, 0.98)',
        accent: '#2780e3'
      };
    }
  }

  /**
   * Initialize UI controls
   * @param {Element} container - Main container element
   * @param {Object} graph - KnowledgeGraphExplorer instance
   * @param {Object} data - Graph data with layers and timeline info
   */
  initialize(container, graph, data) {
    this.container = container;
    this.graph = graph;
    this.layers = data.layers || [];
    
    // Extract timeline range from config or data
    if (data.timeline) {
      this.timeline = data.timeline;
    }

    this.createUIStructure();
    this.setupEventListeners();
  }

  /**
   * Create the overall UI structure
   */
  createUIStructure() {
    // Don't restructure DOM - just add overlay controls to existing container
    this.container.style.position = 'relative';
    this.container.style.fontFamily = 'system-ui, -apple-system, sans-serif';

    // Create control panels as overlays
    if (this.config.showLayerControls && this.layers.length > 0) {
      this.createLayerControls();
    }

    // Add audience controls (bottom-right)
    if (this.config.showAudienceControls) {
      this.createAudienceControls();
    }

    // Add refresh button
    this.createRefreshButton();

    if (this.config.showTimeline && this.timeline.start && this.timeline.end) {
      this.createTimelineControls();
    }

    if (this.config.showNodeInfo) {
      this.createInfoPanel();
    }
  }
  
  /**
   * Create layer control buttons
   */
  createLayerControls() {
    this.layerContainer = document.createElement('div');
    this.layerContainer.className = 'kg-layer-controls';
    this.layerContainer.style.cssText = `
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      max-width: 180px;
    `;

    // Title
    const title = document.createElement('div');
    title.textContent = 'Layers';
    title.style.cssText = `
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 12px;
      color: #333;
    `;
    this.layerContainer.appendChild(title);

    // "All Layers" button
    const allButton = this.createLayerButton('all', 'All Layers', '#666');
    allButton.classList.add('active');
    this.layerContainer.appendChild(allButton);

    // Individual layer buttons
    this.layers.forEach(layer => {
      const button = this.createLayerButton(layer.id, layer.name, layer.color);
      this.layerContainer.appendChild(button);
    });

    this.container.appendChild(this.layerContainer);
  }

  /**
   * Create a single layer button
   */
  createLayerButton(layerId, layerName, color) {
    const button = document.createElement('button');
    button.className = 'kg-layer-btn';
    button.setAttribute('data-layer', layerId);
    button.style.cssText = `
      display: block;
      width: 100%;
      margin: 2px 0;
      padding: 6px 8px;
      border: 1px solid ${color};
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      text-align: left;
      transition: all 0.2s ease;
    `;

    // Color indicator
    const colorDot = document.createElement('span');
    colorDot.style.cssText = `
      display: inline-block;
      width: 8px;
      height: 8px;
      background: ${color};
      border-radius: 50%;
      margin-right: 6px;
    `;
    
    button.appendChild(colorDot);
    button.appendChild(document.createTextNode(layerName));

    // Hover and active states
    button.addEventListener('mouseenter', () => {
      if (!button.classList.contains('active')) {
        button.style.background = color + '20';
      }
    });

    button.addEventListener('mouseleave', () => {
      if (!button.classList.contains('active')) {
        button.style.background = 'white';
      }
    });

    button.addEventListener('click', () => {
      this.setActiveLayer(layerId);
    });

    return button;
  }

  /**
   * Create audience filter controls (bottom-right)
   */
  createAudienceControls() {
    this.audienceContainer = document.createElement('div');
    this.audienceContainer.className = 'kg-audience-controls';
    this.audienceContainer.style.cssText = `
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      max-width: 180px;
    `;

    // Title
    const title = document.createElement('div');
    title.textContent = 'View For';
    title.style.cssText = `
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 12px;
      color: #333;
    `;
    this.audienceContainer.appendChild(title);

    // Audience filter buttons
    const audiences = [
      { id: 'general', name: 'General Audience', color: '#2780e3' },
      { id: 'technical', name: 'Technical', color: '#3fb618' },
      { id: 'current_focus', name: 'Current Focus', color: '#ff6b35' }
    ];

    audiences.forEach(audience => {
      const button = this.createAudienceButton(audience.id, audience.name, audience.color);
      if (audience.id === 'current_focus') {
        button.classList.add('active');
      }
      this.audienceContainer.appendChild(button);
    });

    this.container.appendChild(this.audienceContainer);
  }

  /**
   * Create a single audience filter button
   */
  createAudienceButton(audienceId, audienceName, color) {
    const button = document.createElement('button');
    button.className = 'kg-audience-btn';
    button.setAttribute('data-audience', audienceId);
    button.style.cssText = `
      display: block;
      width: 100%;
      margin: 2px 0;
      padding: 6px 8px;
      border: 1px solid ${color};
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      text-align: center;
      transition: all 0.2s ease;
    `;
    button.textContent = audienceName;

    // Hover and active states
    button.addEventListener('mouseenter', () => {
      if (!button.classList.contains('active')) {
        button.style.background = color + '20';
      }
    });

    button.addEventListener('mouseleave', () => {
      if (!button.classList.contains('active')) {
        button.style.background = 'white';
      }
    });

    button.addEventListener('click', () => {
      this.setActiveAudience(audienceId);
    });

    return button;
  }

  /**
   * Create refresh button for resetting node positions
   */
  createRefreshButton() {
    this.refreshButton = document.createElement('button');
    this.refreshButton.className = 'kg-refresh-btn';
    this.refreshButton.innerHTML = 'ðŸ”„'; // Refresh icon
    this.refreshButton.title = 'Reset node positions';
    this.refreshButton.style.cssText = `
      position: absolute;
      top: 10px;
      left: ${this.layerContainer ? '200px' : '10px'}; /* Adjust based on layer controls */
      width: 36px;
      height: 36px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      transition: all 0.2s ease;
    `;

    // Hover effects
    this.refreshButton.addEventListener('mouseenter', () => {
      this.refreshButton.style.background = '#f0f0f0';
      this.refreshButton.style.transform = 'scale(1.05)';
    });

    this.refreshButton.addEventListener('mouseleave', () => {
      this.refreshButton.style.background = 'rgba(255, 255, 255, 0.95)';
      this.refreshButton.style.transform = 'scale(1)';
    });

    // Click handler
    this.refreshButton.addEventListener('click', () => {
      this.refreshNodePositions();
    });

    this.container.appendChild(this.refreshButton);
  }

  /**
   * Refresh/reset node positions
   */
  refreshNodePositions() {
    if (!this.graph) return;

    // Add visual feedback
    this.refreshButton.style.transform = 'rotate(360deg)';
    this.refreshButton.style.transition = 'transform 0.5s ease';

    // Reset the transform after animation
    setTimeout(() => {
      this.refreshButton.style.transform = 'scale(1)';
      this.refreshButton.style.transition = 'all 0.2s ease';
    }, 500);

    // Restart the simulation with higher energy
    if (this.graph.components && this.graph.components.forceSimulation) {
      // Clear any fixed positions
      this.graph.nodes.forEach(node => {
        node.fx = null;
        node.fy = null;
      });

      // Restart with high energy
      this.graph.components.forceSimulation.restart(1.0);
    }

    this.emit('refresh', { timestamp: Date.now() });
  }

  /**
   * Create timeline controls (compact version)
   */
  createTimelineControls() {
    this.timelineContainer = document.createElement('div');
    this.timelineContainer.className = 'kg-timeline-controls';
    this.timelineContainer.style.cssText = `
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 8px 15px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      min-width: 250px;
    `;

    // Title and current year display
    const header = document.createElement('div');
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      font-size: 11px;
      color: #333;
    `;

    const title = document.createElement('span');
    title.textContent = 'Timeline';
    title.style.fontWeight = 'bold';

    this.currentYearDisplay = document.createElement('span');
    this.currentYearDisplay.textContent = 'All Years';
    this.currentYearDisplay.style.color = '#666';

    header.appendChild(title);
    header.appendChild(this.currentYearDisplay);
    this.timelineContainer.appendChild(header);

    // Timeline slider
    this.timelineSlider = document.createElement('input');
    this.timelineSlider.type = 'range';
    this.timelineSlider.min = this.timeline.start;
    this.timelineSlider.max = this.timeline.end;
    this.timelineSlider.value = this.timeline.end;
    this.timelineSlider.style.cssText = `
      width: 100%;
      margin: 4px 0;
      height: 4px;
    `;

    // Timeline labels
    const labels = document.createElement('div');
    labels.style.cssText = `
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      color: #666;
      margin-top: 2px;
    `;

    const startLabel = document.createElement('span');
    startLabel.textContent = this.timeline.start;
    const endLabel = document.createElement('span');
    endLabel.textContent = this.timeline.end;

    labels.appendChild(startLabel);
    labels.appendChild(endLabel);

    // "All Years" toggle button
    const allYearsBtn = document.createElement('button');
    allYearsBtn.textContent = 'Show All Years';
    allYearsBtn.style.cssText = `
      margin-top: 6px;
      padding: 3px 6px;
      border: 1px solid #ddd;
      background: white;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
      width: 100%;
    `;

    this.timelineContainer.appendChild(this.timelineSlider);
    this.timelineContainer.appendChild(labels);
    this.timelineContainer.appendChild(allYearsBtn);

    // Event listeners
    this.timelineSlider.addEventListener('input', (e) => {
      this.setTimelinePosition(parseInt(e.target.value));
    });

    allYearsBtn.addEventListener('click', () => {
      this.showAllYears();
    });

    this.container.appendChild(this.timelineContainer);
  }

  /**
   * Create info panel for displaying node/link details (top-right)
   */
  createInfoPanel() {
    this.infoPanel = document.createElement('div');
    this.infoPanel.className = 'kg-info-panel';
    this.infoPanel.style.cssText = `
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 15px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      max-width: 280px;
      height: calc(100% - 200px);
      overflow-y: auto;
      overflow-x: hidden;
      display: none;
      pointer-events: auto;
    `;

    this.container.appendChild(this.infoPanel);
  }

  /**
   * Setup event listeners with the graph
   */
  setupEventListeners() {
    if (!this.graph) return;

    // Listen for node clicks
    this.graph.on('nodeClick', (data) => {
      this.showNodeInfo(data.node);
    });

    // Listen for background clicks to hide info
    this.graph.on('backgroundClick', () => {
      this.hideInfo();
    });

    // Listen for layer changes
    this.graph.on('layerChange', (data) => {
      this.updateLayerButtons(data.layer);
    });
  }

  /**
   * Set active layer
   */
  setActiveLayer(layerId) {
    this.activeLayer = layerId === 'all' ? null : layerId;
    
    // Update graph
    if (this.graph) {
      if (layerId === 'all') {
        this.graph.showAllLayers();
      } else {
        this.graph.setActiveLayer(layerId);
      }
    }

    // Update button states
    this.updateLayerButtons(this.activeLayer);
    
    this.emit('layerChange', { layer: this.activeLayer });
  }

  /**
   * Set active audience filter
   */
  setActiveAudience(audienceId) {
    this.activeAudience = audienceId;
    
    // Update graph visual effects
    if (this.graph) {
      this.graph.setAudienceFilter(audienceId);
    }

    // Update button states
    this.updateAudienceButtons(audienceId);
    
    this.emit('audienceChange', { audience: audienceId });
  }

  /**
   * Update layer button visual states
   */
  updateLayerButtons(activeLayerId) {
    if (!this.layerContainer) return;

    const buttons = this.layerContainer.querySelectorAll('.kg-layer-btn');
    buttons.forEach(btn => {
      const layerId = btn.getAttribute('data-layer');
      const isActive = (activeLayerId === null && layerId === 'all') || 
                      (activeLayerId === layerId);
      
      btn.classList.toggle('active', isActive);
      
      if (isActive) {
        const color = layerId === 'all' ? '#666' : 
                     this.layers.find(l => l.id === layerId)?.color || '#666';
        btn.style.background = color + '30';
        btn.style.fontWeight = 'bold';
      } else {
        btn.style.background = 'white';
        btn.style.fontWeight = 'normal';
      }
    });
  }

  /**
   * Update audience button visual states
   */
  updateAudienceButtons(activeAudienceId) {
    if (!this.audienceContainer) return;

    const buttons = this.audienceContainer.querySelectorAll('.kg-audience-btn');
    buttons.forEach(btn => {
      const audienceId = btn.getAttribute('data-audience');
      const isActive = audienceId === activeAudienceId;
      
      btn.classList.toggle('active', isActive);
      
      if (isActive) {
        const audiences = {
          general: '#2780e3',
          technical: '#3fb618',
          current_focus: '#ff6b35'
        };
        const color = audiences[audienceId] || '#666';
        btn.style.background = color + '30';
        btn.style.fontWeight = 'bold';
      } else {
        btn.style.background = 'white';
        btn.style.fontWeight = 'normal';
      }
    });
  }

  /**
   * Set timeline position
   */
  setTimelinePosition(year) {
    this.currentTimelinePosition = year;
    this.currentYearDisplay.textContent = year.toString();
    
    // TODO: Filter nodes/links by timeline position
    // This would require integration with the graph's data filtering
    
    this.emit('timelineChange', { year: year });
  }

  /**
   * Show all years (reset timeline)
   */
  showAllYears() {
    this.currentTimelinePosition = null;
    this.currentYearDisplay.textContent = 'All Years';
    this.timelineSlider.value = this.timeline.end;
    
    // TODO: Reset timeline filtering
    
    this.emit('timelineChange', { year: null });
  }

  /**
   * Show node information in the info panel
   */
  showNodeInfo(node) {
    if (!this.infoPanel) return;

    this.selectedNode = node;

    // Get theme-appropriate colors
    const colors = this.getThemeColors();

    const title = document.createElement('div');
    title.style.cssText = `
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 8px;
      color: ${colors.text};
    `;
    title.textContent = node.label;

    const description = document.createElement('div');
    description.style.cssText = `
      font-size: 12px;
      line-height: 1.4;
      color: ${colors.textSecondary};
      margin: 0;
    `;
    description.textContent = node.description || 'No description available.';

    // Additional details
    const details = document.createElement('div');
    details.style.cssText = `
      font-size: 11px;
      color: ${colors.textSecondary};
      border-top: 1px solid ${colors.border};
      padding-top: 8px;
      margin-bottom: 10px;
    `;

    if (node.timespan) {
      const timespan = document.createElement('div');
      const endText = node.timespan.end ? node.timespan.end : 'current';
      timespan.textContent = `${node.timespan.start} - ${endText}`;
      details.appendChild(timespan);
    }

    // Layer tag (colored box instead of text)
    if (node.layer) {
      const layerInfo = this.layers.find(l => l.id === node.layer);
      const layerTag = document.createElement('div');
      layerTag.style.cssText = `
        display: inline-block;
        background: ${layerInfo?.color || '#666'};
        color: ${this.isDarkTheme() ? 'white' : 'black'} !important;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 10px;
        font-weight: bold;
        margin-top: 4px;
      `;
      layerTag.textContent = layerInfo?.name || node.layer;
      details.appendChild(layerTag);
    }

    // Related nodes section
    const relatedSection = this.createRelatedNodesSection(node);

    // Close button
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Ã—';
    closeBtn.style.cssText = `
      position: absolute;
      top: 5px;
      right: 5px;
      border: none;
      background: none;
      font-size: 16px;
      cursor: pointer;
      color: ${colors.textSecondary};
    `;
    closeBtn.addEventListener('click', () => this.hideInfo());

    // Create main content area with guaranteed space for description
    const mainContent = document.createElement('div');
    mainContent.style.cssText = `
      margin-bottom: 10px;
    `;

    // Add title and details to main content
    mainContent.appendChild(title);
    mainContent.appendChild(details);

    // Create description area with minimum height guarantee
    const descriptionContainer = document.createElement('div');
    descriptionContainer.style.cssText = `
      min-height: 80px;
      max-height: 120px;
      overflow-y: auto;
      margin-bottom: 12px;
      padding: 8px;
      background: ${colors.background};
      border-radius: 4px;
      border: 1px solid ${colors.border};
    `;
    descriptionContainer.appendChild(description);

    // Create scrollable related section
    const relatedContainer = document.createElement('div');
    relatedContainer.style.cssText = `
      border-top: 2px solid ${colors.border};
      padding-top: 8px;
      max-height: 180px;
      overflow-y: auto;
      background: ${colors.containerBg};
    `;
    relatedContainer.appendChild(relatedSection);

    // Clear and populate
    this.infoPanel.innerHTML = '';
    this.infoPanel.appendChild(closeBtn);
    this.infoPanel.appendChild(mainContent);
    this.infoPanel.appendChild(descriptionContainer);
    this.infoPanel.appendChild(relatedContainer);

    this.infoPanel.style.display = 'block';
  }

  /**
   * Create the "Related To" section showing connected nodes
   */
  createRelatedNodesSection(node) {
    // Find all links connected to this node (both as parent and child)
    const connectedLinks = this.graph.links.filter(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      return sourceId === node.id || targetId === node.id;
    });

    // Also find direct parent/child relationships
    const children = this.graph.nodes.filter(n => n.parent_node === node.id);
    const parent = node.parent_node ? this.graph.nodes.find(n => n.id === node.parent_node) : null;

    if (connectedLinks.length === 0 && children.length === 0 && !parent) {
      return document.createElement('div'); // Return empty div if no connections
    }

    // Get theme-appropriate colors
    const colors = this.getThemeColors();

    const section = document.createElement('div');
    section.style.cssText = `
      border-top: 1px solid ${colors.border};
      padding-top: 8px;
      margin-top: 8px;
    `;

    const title = document.createElement('div');
    title.textContent = 'Related To';
    title.style.cssText = `
      font-weight: bold;
      font-size: 11px;
      color: ${colors.text};
      margin-bottom: 6px;
    `;
    section.appendChild(title);

    // Add parent node
    if (parent) {
      this.addRelatedNodeLink(section, parent, 'parent');
    }

    // Add child nodes
    children.forEach(child => {
      this.addRelatedNodeLink(section, child, 'child');
    });

    // Add other connected nodes from links
    connectedLinks.forEach(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      
      const connectedNodeId = sourceId === node.id ? targetId : sourceId;
      const connectedNode = this.graph.nodes.find(n => n.id === connectedNodeId);
      
      if (connectedNode && connectedNode !== parent && !children.includes(connectedNode)) {
        this.addRelatedNodeLink(section, connectedNode, 'related');
      }
    });

    return section;
  }

  /**
   * Add a related node link to the related nodes section
   * @param {HTMLElement} container - The container to add the link to
   * @param {Object} node - The related node
   * @param {string} relationship - The relationship type ('parent', 'child', 'related')
   */
  addRelatedNodeLink(container, node, relationship) {
    // Get theme-appropriate colors
    const colors = this.getThemeColors();

    const link = document.createElement('div');
    link.style.cssText = `
      display: flex;
      align-items: center;
      margin: 2px 0;
      padding: 2px 4px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      background: ${colors.background};
      border: 1px solid ${colors.border};
      transition: background-color 0.2s;
    `;

    // Get layer info for color
    const layerInfo = this.layers.find(l => l.id === node.layer);
    const layerColor = layerInfo?.color || '#666';

    // Create color indicator
    const colorDot = document.createElement('div');
    colorDot.style.cssText = `
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: ${layerColor};
      margin-right: 6px;
      flex-shrink: 0;
    `;

    // Create text content
    const text = document.createElement('span');
    text.style.cssText = `
      color: ${colors.text};
      font-size: 10px;
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
    `;

    // Add relationship prefix
    let prefix = '';
    switch (relationship) {
      case 'parent': prefix = 'â†‘ '; break;
      case 'child': prefix = 'â†“ '; break;
      default: prefix = 'â†’ '; break;
    }

    text.textContent = prefix + node.label;

    link.appendChild(colorDot);
    link.appendChild(text);

    // Get hover colors - slightly different from base colors
    const isDark = this.isDarkTheme();
    const hoverBg = isDark ? '#3a3a3a' : '#e9ecef';
    const originalBg = colors.background;

    // Add hover effects
    link.addEventListener('mouseenter', () => {
      link.style.backgroundColor = hoverBg;
    });

    link.addEventListener('mouseleave', () => {
      link.style.backgroundColor = originalBg;
    });

    // Add click handler to focus on related node
    link.addEventListener('click', (e) => {
      e.stopPropagation();
      this.panToNode(node);
    });

    container.appendChild(link);
  }

  /**
   * Pan the graph to focus on a specific node
   */
  panToNode(node) {
    if (!this.graph || !node.x || !node.y) return;
  
    // Use the graph's focusOnNode method if available
    if (typeof this.graph.focusOnNode === 'function') {
      this.graph.focusOnNode(node.id);
    }
  }

  /**
   * Hide the info panel
   */
  hideInfo() {
    if (this.infoPanel) {
      this.infoPanel.style.display = 'none';
    }
    this.selectedNode = null;
  }

  /**
   * Get current UI state
   */
  getState() {
    return {
      activeLayer: this.activeLayer,
      activeAudience: this.activeAudience,
      currentTimelinePosition: this.currentTimelinePosition,
      selectedNode: this.selectedNode ? this.selectedNode.id : null,
      layerCount: this.layers.length
    };
  }

  /**
   * Add event listener
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }

  /**
   * Emit event
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in UI event handler for ${eventType}:`, error);
        }
      });
    }
  }

  /**
   * Cleanup and destroy UI controls
   */
  destroy() {
    if (this.uiContainer && this.uiContainer.parentNode) {
      this.uiContainer.parentNode.removeChild(this.uiContainer);
    }
    this.eventHandlers = {};
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = UIControlsManager;
} else if (typeof window !== 'undefined') {
  window.UIControlsManager = UIControlsManager;
}

// core/KnowledgeGraphExplorer.js
/**
 * Knowledge Graph Explorer - Main Orchestrating Class
 * Coordinates all modular components to create an interactive knowledge graph
 */
class KnowledgeGraphExplorer {
  constructor(container, data, config = {}) {
    this.container = typeof container === 'string' 
      ? document.querySelector(container) 
      : container;
    
    if (!this.container) {
      throw new Error('Container element not found');
    }

    // Validate data before proceeding
    this.validateAndProcessData(data);

    // Configuration with sensible defaults
    this.config = this.mergeConfigurations(config);
    
    // Initialize modular components
    this.components = {
      dataValidator: null,
      coordinateTransform: null,
      forceSimulation: null,
      interactionManager: null,
      visualEffectsManager: null,
      miniMapManager: null,
      labelLayoutManager: null
    };

    // State management
    this.state = {
      currentLayer: null,
      currentAudience: 'current_focus',
      isTimelineActive: false,
      currentTimelinePosition: null,
      selectedNode: null,
      selectedNodeRelated: new Set(),
      selectedNodeDistances: new Map(),
      isInitialized: false,
      isPanning: false
    };

    // Event handlers for external API
    this.eventHandlers = {};

    // Initialize the graph
    this.init();
  }

  /**
   * Generate links from parent_node/parent_nodes relationships
   * @returns {Array} - Array of link objects
   */
  generateLinksFromParents() {
    const links = [];

    this.nodes.forEach(node => {
      // Support both parent_node (single) and parent_nodes (array) for backward compatibility
      let parents = [];

      // Check for single parent (backward compatibility)
      if (node.parent_node && node.parent_node !== null) {
        // parent_node can be either a string or an array
        parents = Array.isArray(node.parent_node) ? node.parent_node : [node.parent_node];
      }
      // Check for multiple parents (new format)
      else if (node.parent_nodes && node.parent_nodes !== null) {
        if (Array.isArray(node.parent_nodes)) {
          parents = node.parent_nodes;
        } else {
          // If parent_nodes is not an array, treat it as a single parent
          parents = [node.parent_nodes];
        }
      }

      // Create links for all parents
      parents.forEach(parentId => {
        // Find the parent node
        const parentNode = this.nodes.find(n => n.id === parentId);
        if (parentNode) {
          links.push({
            source: parentId,
            target: node.id,
            strength: 0.5, // Default strength
            id: `${parentId}-${node.id}`
          });
        }
      });
    });

    return links;
  }

  /**
   * Validate and process input data
   * @param {Object} data - Input data with nodes
   */
  validateAndProcessData(data) {
    // Use DataValidator if available, otherwise basic validation
    if (typeof DataValidator !== 'undefined') {
      // Generate links for validation
      const tempNodes = data.nodes || [];
      const tempLinks = [];
      
      tempNodes.forEach(node => {
        // Support both parent_node and parent_nodes
        let parents = [];
        if (node.parent_node && node.parent_node !== null) {
          // parent_node can be either a string or an array
          parents = Array.isArray(node.parent_node) ? node.parent_node : [node.parent_node];
        } else if (node.parent_nodes && node.parent_nodes !== null) {
          parents = Array.isArray(node.parent_nodes) ? node.parent_nodes : [node.parent_nodes];
        }

        parents.forEach(parentId => {
          tempLinks.push({
            source: parentId,
            target: node.id
          });
        });
      });

      const dataForValidation = {
        nodes: [...tempNodes],
        links: tempLinks
      };
      
      const validation = DataValidator.validate(dataForValidation);
      if (!validation.isValid) {
        console.warn('Data validation warnings:', validation.errors);
        if (validation.errors.length > 0) {
          throw new Error(`Data validation failed: ${validation.errors[0]}`);
        }
      }
    } else {
      // Basic validation fallback
      if (!data || !data.nodes) {
        throw new Error('Data must contain nodes array');
      }
    }

    this.originalData = data;
    this.allNodes = [...data.nodes];
    this.nodes = [...data.nodes];
    
    // Generate links from parent relationships
    this.links = this.generateLinksFromParents();
    this.allLinks = [...this.links];
  }

  /**
   * Merge user configuration with defaults
   * @param {Object} userConfig - User-provided configuration
   * @returns {Object} - Merged configuration
   */
  mergeConfigurations(userConfig) {
    const defaultConfig = {
      // Container dimensions
      width: 900,
      height: 600,
      
      // Visual theme
      theme: {
        primaryColor: '#2780e3',
        secondaryColor: '#3fb618',
        accentColor: '#ffdd3c',
        dangerColor: '#ff0039',
        mutedColor: '#868e96',
        backgroundColor: '#ffffff',
        surfaceColor: '#f8f9fa',
        textPrimary: '#212529',
        textSecondary: '#495057',
        textMuted: '#868e96',
        borderColor: '#dee2e6',
        fontFamily: 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
        fontSizeBase: 14,
        fontSizeSmall: 12,
        fontSizeLarge: 16,
        borderRadius: 6,
        shadowColor: 'rgba(0, 0, 0, 0.15)'
      },

      // Node colors - completely configurable, no hardcoded categories
      nodeColors: {},
      
      // Layer configuration - user-defined
      layers: [],
      
      // Timeline configuration
      timeline: {
        enabled: true,
        start: null, // Auto-calculated if not provided
        end: null    // Auto-calculated if not provided
      },
      
      // Feature toggles
      features: {
        showMiniMap: true,
        showTimeline: true,
        showLegend: true,
        enableHover: true,
        enableDrag: true,
        enableLayerMode: true,
        clickToNavigate: true,
        smartLabelPositioning: true
      },

      // Label positioning configuration
      labelLayout: {
        enabled: true,
        preferredPositions: ['bottom', 'right', 'top', 'left'],
        maxDistance: 50,
        minDistance: 15,
        padding: 8,
        collisionIterations: 3,
        positioningIterations: 2,
        transitionDuration: 200
      },
      
      // Interaction settings
      interaction: {
        hoverRadius: 50,
        maxHoverScale: 1.3,
        clickRadius: 20,
        dragThreshold: 5
      },
      
      // Force simulation settings - must be provided by Python config from YAML
      simulation: {},
      
      // Visual effects settings
      effects: {
        hoverTransitionDuration: 100,
        layerTransitionDuration: 400,
        distanceScaling: {
          distance1: 0.9,
          distance2: 0.7,
          distance3: 0.5,
          distanceOther: 0.3
        }
      },
      
      // MiniMap settings
      miniMap: {
        width: 150,
        height: 120,
        position: 'bottom-left',
        padding: 10
      }
    };

    return this.deepMerge(defaultConfig, userConfig);
  }

  /**
   * Deep merge two objects
   * @param {Object} target - Target object
   * @param {Object} source - Source object
   * @returns {Object} - Merged object
   */
  deepMerge(target, source) {
    const result = { ...target };
    
    for (const key in source) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        result[key] = this.deepMerge(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
    
    return result;
  }

  /**
   * Initialize all components and setup the graph
   */
  init() {
    this.setupContainer();
    this.setupSVG();
    this.initializeComponents();
    this.setupEventBindings();
    this.render();
    this.startSimulation();

    this.state.isInitialized = true;

    // Apply initial audience filter after initialization to show current focus view by default
    this.setAudienceFilter('current_focus');

    this.emit('initialized', { config: this.config, state: this.state });
  }

  /**
   * Setup the container element
   */
  setupContainer() {
    this.container.innerHTML = '';
    this.container.style.position = 'relative';
    this.container.style.width = this.config.width + 'px';
    this.container.style.height = this.config.height + 'px';
    this.container.style.backgroundColor = this.config.theme.backgroundColor;
    this.container.style.overflow = 'hidden';
    this.container.style.borderRadius = this.config.theme.borderRadius + 'px';
    this.container.style.fontFamily = this.config.theme.fontFamily;
  }

  /**
   * Setup SVG and its groups
   */
  setupSVG() {
    this.svg = d3.select(this.container)
      .append('svg')
      .attr('width', this.config.width)
      .attr('height', this.config.height);

    this.mainGroup = this.svg.append('g').attr('class', 'main-group');
    this.linkGroup = this.mainGroup.append('g').attr('class', 'links');
    this.nodeGroup = this.mainGroup.append('g').attr('class', 'nodes');
    this.labelGroup = this.mainGroup.append('g').attr('class', 'labels');

    // Setup zoom behavior
    this.zoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        this.handleZoom(event);
      });

    this.svg.call(this.zoom);
  }

  /**
   * Initialize all modular components
   */
  initializeComponents() {
    // Initialize coordinate transform
    this.components.coordinateTransform = new CoordinateTransform();
    this.components.coordinateTransform.updateViewport(this.config.width, this.config.height);

    // Initialize force simulation
    this.components.forceSimulation = new ForceSimulation(this.config.simulation);
    this.components.forceSimulation.updateDimensions(this.config.width, this.config.height);
    this.components.forceSimulation.onTickCallback(() => this.updatePositions());

    // Initialize visual effects manager
    this.components.visualEffectsManager = new VisualEffectsManager({
      ...this.config.effects,
      theme: this.config.theme
    });

    // Initialize interaction manager
    this.components.interactionManager = new InteractionManager({
      ...this.config.interaction,
      hoverEnabled: this.config.features.enableHover,
      dragEnabled: this.config.features.enableDrag
    });

    // Initialize minimap if enabled
    if (this.config.features.showMiniMap) {
      this.components.miniMapManager = new MiniMapManager({
        ...this.config.miniMap,
        backgroundColor: this.config.theme.surfaceColor + 'E6',
        borderColor: this.config.theme.primaryColor
      });
    }

    // Initialize label layout manager if smart positioning is enabled
    if (this.config.features.smartLabelPositioning) {
      this.components.labelLayoutManager = new LabelLayoutManager({
        ...this.config.labelLayout
      });
    }

    // Initialize UI controls manager
    this.components.uiControlsManager = new UIControlsManager({
      showTimeline: this.config.features.showTimeline,
      showLayerControls: this.config.features.showLayerControls,
      showAudienceControls: this.config.features.showAudienceControls,
      showNodeInfo: this.config.features.showNodeInfo,
      showMiniMap: this.config.features.showMiniMap
    });
  }

  /**
   * Setup event bindings between components
   */
  setupEventBindings() {
    // Interaction events
    if (this.components.interactionManager) {
      const elements = {
        svg: this.svg,
        nodes: this.nodeGroup.selectAll('.node'),
        links: this.linkGroup.selectAll('.link'),
        labels: this.labelGroup.selectAll('.label')
      };

      this.components.interactionManager.initialize(elements, this.components.coordinateTransform);
      this.components.interactionManager.updateData(this.nodes, this.links);

      // Bind interaction events
      this.components.interactionManager.on('nodeClick', (data) => {
        this.setSelectedNode(data.node);
        this.emit('nodeClick', data);
      });

      this.components.interactionManager.on('linkClick', (data) => {
        this.emit('linkClick', data);
      });

      this.components.interactionManager.on('backgroundClick', (data) => {
        this.setSelectedNode(null);
        this.emit('backgroundClick', data);
      });

      this.components.interactionManager.on('dockHover', (data) => {
        this.applyDockHoverEffects(data.mousePosition);
      });

      this.components.interactionManager.on('dockHoverReset', () => {
        this.resetDockHoverEffects();
      });

      this.components.interactionManager.on('nodeHover', (data) => {
        if (this.config.features.enableHover && this.components.visualEffectsManager) {
          this.components.visualEffectsManager.applyContinuousHoverEffects(
            data.node, data.distance, data.mousePosition
          );
        }
      });

      this.components.interactionManager.on('hoverReset', () => {
        if (this.components.visualEffectsManager) {
          this.components.visualEffectsManager.resetHoverEffects();
        }
      });

      this.components.interactionManager.on('dragStart', (data) => {
        this.emit('dragStart', data);
      });

      this.components.interactionManager.on('dragEnd', (data) => {
        this.emit('dragEnd', data);
      });
    }

    // Visual effects initialization
    if (this.components.visualEffectsManager) {
      const elements = {
        nodes: this.nodeGroup.selectAll('.node'),
        links: this.linkGroup.selectAll('.link'),
        labels: this.labelGroup.selectAll('.label')
      };
      this.components.visualEffectsManager.initialize(elements);
      this.components.visualEffectsManager.updateData(this.nodes, this.links);
    }

    // MiniMap initialization and events
    if (this.components.miniMapManager) {
      this.components.miniMapManager.initialize(this.container, this.components.coordinateTransform);
      this.components.miniMapManager.updateData(this.nodes, this.links);

      this.components.miniMapManager.on('navigate', (data) => {
        this.navigateToPosition(data.graphPosition);
      });
    }

    // UI Controls Manager initialization and events
    if (this.components.uiControlsManager) {
      const graphData = {
        layers: this.originalData.layers || [],
        timeline: this.originalData.timeline || {}
      };
      this.components.uiControlsManager.initialize(this.container, this, graphData);
    }

    // Label Layout Manager initialization
    if (this.components.labelLayoutManager) {
      // Will be initialized after rendering when label elements are available
    }
  }

  /**
   * Update text sizes based on zoom level with floor and ceiling constraints
   * @param {number} zoomScale - Current zoom scale factor
   */
  updateTextSizesForZoom(zoomScale) {
    if (!this.labelGroup) return;

    // Define base text size and constraints for screen appearance
    const baseTextSize = 14;    // Base font size in pixels at 1.0 zoom
    const minScreenSize = 10;   // Minimum visual size on screen (pixels)
    const maxScreenSize = 24;   // Maximum visual size on screen (pixels)

    // Calculate text size to maintain consistent screen appearance
    // Scale inversely with zoom so text appears constant size on screen
    const screenTargetSize = baseTextSize / zoomScale;

    // Apply floor and ceiling constraints
    const constrainedSize = Math.max(minScreenSize / zoomScale,
                                   Math.min(maxScreenSize / zoomScale, screenTargetSize));

    // Apply the text size to all labels
    this.labelGroup.selectAll('.label')
      .style('font-size', `${constrainedSize}px`);

    // Update label layout manager with new zoom scale
    if (this.components.labelLayoutManager) {
      this.components.labelLayoutManager.updateZoomScale(zoomScale);
    }
  }

  /**
   * Handle zoom events
   * @param {Object} event - D3 zoom event
   */
  handleZoom(event) {
    this.components.coordinateTransform.updateTransform(event.transform);
    this.mainGroup.attr('transform', event.transform);

    // Only update text sizes if we're not in a panning transition (prevents shaking)
    if (!this.state.isPanning) {
      this.updateTextSizesForZoom(event.transform.k);
    }

    if (this.components.miniMapManager) {
      this.components.miniMapManager.updateViewportIndicator();
    }

    this.emit('zoom', { transform: event.transform });
  }

  /**
   * Render all visual elements
   */
  render() {
    this.renderLinks();
    this.renderNodes();
    this.renderLabels();
    
    // Update component references
    this.updateComponentElements();
  }

  /**
   * Update component element references after rendering
   */
  updateComponentElements() {
    const elements = {
      nodes: this.nodeGroup.selectAll('.node'),
      links: this.linkGroup.selectAll('.link'),
      labels: this.labelGroup.selectAll('.label')
    };

    if (this.components.interactionManager) {
      this.components.interactionManager.nodeElements = elements.nodes;
      this.components.interactionManager.linkElements = elements.links;
      this.components.interactionManager.labelElements = elements.labels;
      this.components.interactionManager.setupNodeInteractions();
      this.components.interactionManager.setupLinkInteractions();
    }

    if (this.components.visualEffectsManager) {
      this.components.visualEffectsManager.nodeElements = elements.nodes;
      this.components.visualEffectsManager.linkElements = elements.links;
      this.components.visualEffectsManager.labelElements = elements.labels;
    }

    if (this.components.labelLayoutManager) {
      this.components.labelLayoutManager.initialize(this.nodes, elements.labels);
    }
  }

  /**
   * Render links
   */
  renderLinks() {
    const linkSelection = this.linkGroup
      .selectAll('.link')
      .data(this.links, d => d.id || `${d.source}-${d.target}`);

    linkSelection.exit().remove();

    linkSelection.enter()
      .append('line')
      .attr('class', 'link')
      .attr('stroke', this.config.theme.mutedColor)
      .attr('stroke-width', d => Math.sqrt(d.strength || 0.5) * 2)
      .style('opacity', 0) // Start with links hidden
      .style('pointer-events', 'none');
  }

  /**
   * Render nodes with experience-based styling
   */
  renderNodes() {
    const nodeSelection = this.nodeGroup
      .selectAll('.node')
      .data(this.nodes, d => d.id);
  
    nodeSelection.exit().remove();
  
    nodeSelection.enter()
      .append('circle')
      .attr('class', 'node')
      .attr('r', d => d.size || 10)
      .attr('fill', d => this.getNodeColor(d))
      .attr('stroke', d => this.getNodeStrokeColor(d))
      .attr('stroke-width', d => this.getNodeStrokeWidth(d))
      .style('cursor', 'pointer');
  }
  
  /**
   * Get node color based on configuration, with support for experience levels
   * @param {Object} node - Node object
   * @returns {string} - Color value
   */
  getNodeColor(node) {
    let baseColor;

    // Get base color from layer (primary), then type, then default
    if (node.layer && this.config.nodeColors[node.layer]) {
      baseColor = this.config.nodeColors[node.layer];
    } else if (node.type && this.config.nodeColors[node.type]) {
      baseColor = this.config.nodeColors[node.type];
    } else if (node.color) {
      baseColor = node.color;
    } else {
      baseColor = this.config.theme.primaryColor;
    }

    // Handle experience level - default to "experienced" if not specified
    const experienceLevel = node.experienceLevel || 'experienced';
    return this.adjustColorForExperience(baseColor, experienceLevel);
  }
  
  /**
   * Adjust color based on experience level
   * @param {string} baseColor - Base color (hex format)
   * @param {string} experienceLevel - 'experienced' or 'interested'
   * @returns {string} - Adjusted color
   */
  adjustColorForExperience(baseColor, experienceLevel) {
    if (experienceLevel === 'interested') {
      // Make color lighter/less saturated for interest-only
      return this.lightenColor(baseColor, 0.4); // 40% lighter
    }
    
    // For 'experienced' or any other value, return full saturation
    return baseColor;
  }
  
  /**
   * Lighten a hex color by a given factor
   * @param {string} color - Hex color (e.g., "#2780e3")
   * @param {number} factor - Lightening factor (0-1, where 1 is white)
   * @returns {string} - Lightened hex color
   */
  lightenColor(color, factor) {
    // Remove # if present
    const hex = color.replace('#', '');
    
    // Parse RGB values
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    // Lighten each component
    const newR = Math.round(r + (255 - r) * factor);
    const newG = Math.round(g + (255 - g) * factor);
    const newB = Math.round(b + (255 - b) * factor);
    
    // Convert back to hex
    const toHex = (n) => {
      const hex = n.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    
    return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
  }

  /**
   * Get stroke color for nodes based on experience level
   * @param {Object} node - Node object
   * @returns {string} - Stroke color
   */
  getNodeStrokeColor(node) {
    // Handle experience level - default to "experienced" if not specified
    const experienceLevel = node.experienceLevel || 'experienced';

    if (experienceLevel === 'interested') {
      // Lighter stroke for interested nodes
      return this.lightenColor(this.config.theme.textPrimary, 0.5);
    }

    // Full stroke for experienced nodes
    return this.config.theme.textPrimary;
  }
  
  /**
   * Get stroke width for nodes based on experience level
   * @param {Object} node - Node object
   * @returns {number} - Stroke width
   */
  getNodeStrokeWidth(node) {
    // Handle experience level - default to "experienced" if not specified
    const experienceLevel = node.experienceLevel || 'experienced';

    if (experienceLevel === 'interested') {
      return 1; // Thinner stroke for interested
    }

    return 2; // Standard stroke for experienced
  }

  /**
   * Render labels
   */
  renderLabels() {
    const labelSelection = this.labelGroup
      .selectAll('.label')
      .data(this.nodes, d => d.id);

    labelSelection.exit().remove();

    labelSelection.enter()
      .append('text')
      .attr('class', 'label')
      .attr('text-anchor', 'middle')
      .attr('dy', '0.35em')
      .attr('font-family', this.config.theme.fontFamily)
      .style('font-size', '12px') // Will be updated by updateTextSizesForZoom
      .attr('fill', this.config.theme.textPrimary)
      .attr('pointer-events', 'none')
      .style('user-select', 'none')
      .style('opacity', 0) // Start invisible
      .text(d => d.label);
  }

  /**
   * Update positions during simulation tick
   */
  updatePositions() {
    this.linkGroup.selectAll('.link')
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);

    this.nodeGroup.selectAll('.node')
      .attr('cx', d => d.x)
      .attr('cy', d => d.y);

    // Update label positions - use smart layout only when a node is selected, otherwise use default positioning
    if (this.components.labelLayoutManager && this.config.features.smartLabelPositioning && this.state.selectedNode) {
      this.components.labelLayoutManager.updateData(this.nodes, this.labelGroup.selectAll('.label'));
    } else {
      // Default label positioning (below nodes)
      this.labelGroup.selectAll('.label')
        .attr('x', d => d.x)
        .attr('y', d => d.y + (d.size || 10) + 18);
    }

    if (this.components.miniMapManager) {
      this.components.miniMapManager.render();
    }
  }

  /**
   * Initialize node positions based on layer grid layout
   */
  initializeLayerBasedPositions() {
    // 3x3 grid layout
    const gridSize = 3;
    const cellWidth = this.config.width / gridSize;
    const cellHeight = this.config.height / gridSize;
    
    // Fill order: (1,2), (2,1), (2,3), (3,2), (2,2), (1,1), (3,3), (1,3), (3,1)
    // Convert to 0-based indexing: (0,1), (1,0), (1,2), (2,1), (1,1), (0,0), (2,2), (0,2), (2,0)
    const fillOrder = [
      [0, 1], [1, 0], [1, 2], [2, 1], [1, 1], [0, 0], [2, 2], [0, 2], [2, 0]
    ];
    
    // Get unique layers
    const uniqueLayers = [...new Set(this.nodes.map(node => node.layer))];
    
    // Assign each layer to a grid position
    const layerToGridPosition = new Map();
    uniqueLayers.forEach((layer, index) => {
      if (index < fillOrder.length) {
        layerToGridPosition.set(layer, fillOrder[index]);
      } else {
        // Fallback for extra layers - use modulo to wrap around
        layerToGridPosition.set(layer, fillOrder[index % fillOrder.length]);
      }
    });
    
    // Position nodes within their assigned grid cells
    this.nodes.forEach(node => {
      const gridPos = layerToGridPosition.get(node.layer);
      if (gridPos) {
        const [gridX, gridY] = gridPos;
        
        // Calculate cell boundaries
        const cellLeft = gridX * cellWidth;
        const cellTop = gridY * cellHeight;
        
        // Add padding within cells to avoid edges
        const padding = Math.min(cellWidth, cellHeight) * 0.1;
        
        // Random position within the cell (with padding)
        node.x = cellLeft + padding + Math.random() * (cellWidth - 2 * padding);
        node.y = cellTop + padding + Math.random() * (cellHeight - 2 * padding);
      } else {
        // Fallback to center if no layer assigned
        node.x = this.config.width / 2 + (Math.random() - 0.5) * 100;
        node.y = this.config.height / 2 + (Math.random() - 0.5) * 100;
      }
    });
  }

  /**
   * Calculate initial zoom to fit all nodes with padding
   */
  setInitialZoom() {
    if (!this.svg || !this.nodes.length) return;

    // Calculate bounding box of all nodes
    const padding = 50; // Padding around the content
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        minX = Math.min(minX, node.x);
        maxX = Math.max(maxX, node.x);
        minY = Math.min(minY, node.y);
        maxY = Math.max(maxY, node.y);
      }
    });

    // If we have valid bounds
    if (isFinite(minX) && isFinite(maxX) && isFinite(minY) && isFinite(maxY)) {
      const contentWidth = maxX - minX;
      const contentHeight = maxY - minY;
      const svgWidth = this.config.width;
      const svgHeight = this.config.height;

      // Calculate scale to fit content with padding
      const scaleX = (svgWidth - 2 * padding) / contentWidth;
      const scaleY = (svgHeight - 2 * padding) / contentHeight;
      const scale = Math.min(scaleX, scaleY, 0.8); // Cap at 0.8 to ensure zoom out

      // Calculate center of content
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;

      // Calculate translation to center the content
      const translateX = svgWidth / 2 - centerX * scale;
      const translateY = svgHeight / 2 - centerY * scale;

      // Apply the transform
      const initialTransform = d3.zoomIdentity
        .translate(translateX, translateY)
        .scale(scale);

      this.svg.call(this.zoom.transform, initialTransform);

      // Update text sizes for the initial zoom level
      this.updateTextSizesForZoom(scale);
    }
  }

  /**
   * Start the force simulation
   */
  startSimulation() {
    if (this.components.forceSimulation) {
      // Initialize positions before starting simulation
      this.initializeLayerBasedPositions();
      this.components.forceSimulation.updateData(this.nodes, this.links);

      // Set initial zoom after a brief delay to ensure nodes have positions
      setTimeout(() => {
        this.setInitialZoom();
      }, 100);
    }
  }

  /**
   * Navigate to a specific position
   * @param {Object} position - {x, y} position in graph coordinates
   */
  navigateToPosition(position) {
    const scale = 1.5;
    const centerX = this.config.width / 2;
    const centerY = this.config.height / 2;
    
    const newTransform = d3.zoomIdentity
      .translate(centerX - position.x * scale, centerY - position.y * scale)
      .scale(scale);
    
    this.svg.transition()
      .duration(750)
      .call(this.zoom.transform, newTransform);
  }

  // ====== PUBLIC API METHODS ======

  /**
   * Set audience filter
   * @param {string} audienceId - 'all', 'general', 'technical', or 'current'
   */
  setAudienceFilter(audienceId) {
    this.state.currentAudience = audienceId;

    // Clear selected node when switching audiences to prevent
    // related nodes from staying visible in wrong audience context
    if (this.state.selectedNode) {
      this.setSelectedNode(null);
    }

    if (this.components.visualEffectsManager) {
      this.components.visualEffectsManager.applyAudienceEffects(audienceId, this.nodes);
    }

    this.updateLabelsForAudience(audienceId);

    this.emit('audienceChange', { audience: audienceId });
  }

  /**
   * Calculate graph distances from a selected node to all other nodes
   * @param {Object} selectedNode - The selected node
   * @returns {Map} - Map of node ID to distance from selected node
   */
  calculateGraphDistances(selectedNode) {
    const distances = new Map();
    const visited = new Set();
    const queue = [{ node: selectedNode, distance: 0 }];

    distances.set(selectedNode.id, 0);
    visited.add(selectedNode.id);

    while (queue.length > 0) {
      const { node, distance } = queue.shift();

      // Find all connected nodes (both through links and parent/child relationships)
      const connectedNodeIds = new Set();

      // Check links
      this.links.forEach(link => {
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;

        if (sourceId === node.id && !visited.has(targetId)) {
          connectedNodeIds.add(targetId);
        } else if (targetId === node.id && !visited.has(sourceId)) {
          connectedNodeIds.add(sourceId);
        }
      });

      // Check parent/child relationships
      this.nodes.forEach(n => {
        if (n.parent_node === node.id && !visited.has(n.id)) {
          connectedNodeIds.add(n.id);
        }
        if (node.parent_node === n.id && !visited.has(n.id)) {
          connectedNodeIds.add(n.id);
        }
      });

      // Add connected nodes to queue
      connectedNodeIds.forEach(nodeId => {
        if (!visited.has(nodeId)) {
          const connectedNode = this.nodes.find(n => n.id === nodeId);
          if (connectedNode) {
            visited.add(nodeId);
            distances.set(nodeId, distance + 1);
            queue.push({ node: connectedNode, distance: distance + 1 });
          }
        }
      });
    }

    return distances;
  }

  /**
   * Find all nodes related to a given node
   * @param {Object} node - The node to find relations for
   * @returns {Set} - Set of related node IDs
   */
  findRelatedNodes(node) {
    const relatedIds = new Set();

    // Add the node itself
    relatedIds.add(node.id);

    // Find all links connected to this node (both as parent and child)
    const connectedLinks = this.links.filter(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      return sourceId === node.id || targetId === node.id;
    });

    // Add connected nodes from links
    connectedLinks.forEach(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      relatedIds.add(sourceId);
      relatedIds.add(targetId);
    });

    // Add direct parent/child relationships
    const children = this.nodes.filter(n => n.parent_node === node.id);
    children.forEach(child => relatedIds.add(child.id));

    if (node.parent_node) {
      relatedIds.add(node.parent_node);
    }

    return relatedIds;
  }

  /**
   * Update link visibility to only show links between nodes with visible labels
   */
  updateLinkVisibility() {
    if (!this.linkGroup) return;

    // During initial setup, don't show any links until properly initialized
    if (!this.state.isInitialized) {
      this.linkGroup.selectAll('.link').style('opacity', 0);
      return;
    }

    // Get all nodes with visible labels (opacity > 0)
    const nodesWithVisibleLabels = new Set();

    if (this.labelGroup) {
      this.labelGroup.selectAll('.label').each(function(d) {
        const opacity = parseFloat(d3.select(this).style('opacity')) || 0;
        if (opacity > 0) {
          nodesWithVisibleLabels.add(d.id);
        }
      });
    }

    // Update link visibility based on selection state
    this.linkGroup.selectAll('.link')
      .transition()
      .duration(300)
      .ease(d3.easeQuadOut)
      .style('opacity', d => {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;

        if (this.state.selectedNode) {
          // When a node is selected, only show links directly connected to that node
          const selectedNodeId = this.state.selectedNode.id;
          const isConnectedToSelected = (sourceId === selectedNodeId || targetId === selectedNodeId);

          // Show link if it's connected to selected node AND both endpoints have visible labels
          const sourceVisible = nodesWithVisibleLabels.has(sourceId);
          const targetVisible = nodesWithVisibleLabels.has(targetId);

          return (isConnectedToSelected && sourceVisible && targetVisible) ? 0.6 : 0;
        } else {
          // When no node is selected, show links between any nodes with visible labels
          const sourceVisible = nodesWithVisibleLabels.has(sourceId);
          const targetVisible = nodesWithVisibleLabels.has(targetId);

          return (sourceVisible && targetVisible) ? 0.6 : 0;
        }
      })
      .style('pointer-events', d => {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;

        if (this.state.selectedNode) {
          // When a node is selected, only show links directly connected to that node
          const selectedNodeId = this.state.selectedNode.id;
          const isConnectedToSelected = (sourceId === selectedNodeId || targetId === selectedNodeId);

          const sourceVisible = nodesWithVisibleLabels.has(sourceId);
          const targetVisible = nodesWithVisibleLabels.has(targetId);

          return (isConnectedToSelected && sourceVisible && targetVisible) ? 'auto' : 'none';
        } else {
          // When no node is selected, enable links between any nodes with visible labels
          const sourceVisible = nodesWithVisibleLabels.has(sourceId);
          const targetVisible = nodesWithVisibleLabels.has(targetId);

          return (sourceVisible && targetVisible) ? 'auto' : 'none';
        }
      });
  }

  /**
   * Update label visibility based on audience and layer
   * @param {string} audienceId - Current audience filter
   */
  updateLabelsForAudience(audienceId) {
    if (!this.labelGroup) return;

    // Use immediate updates during panning to prevent conflicts, smooth transitions otherwise
    const labelSelection = this.labelGroup.selectAll('.label');
    const updateMethod = this.state.isPanning ? labelSelection : labelSelection.transition().duration(200);

    updateMethod.style('opacity', d => {
        // Always show labels for related nodes when a node is selected
        if (this.state.selectedNode && this.state.selectedNodeRelated.has(d.id)) {
          return 1;
        }

        // Hide labels for subnodes when "All Layers" is active and no specific layer is selected
        if (this.state.currentLayer === null && d.subnode) {
          return 0;
        }

        // Handle audience as array or string
        let nodeAudience = d.audience || ['general'];
        if (typeof nodeAudience === 'string') {
          nodeAudience = [nodeAudience];
        }

        return nodeAudience.includes(audienceId) ? 1 : 0;
      });

    // Update link visibility immediately if not panning and initialized, otherwise delay until panning completes
    if (!this.state.isPanning && this.state.isInitialized) {
      this.updateLinkVisibility();
    }
  }

  /**
   * Apply Mac dock-style hover effects based on mouse proximity
   * @param {Object} mousePosition - Mouse position in graph coordinates
   */
  applyDockHoverEffects(mousePosition) {
    // Only apply dock effects when no node is selected (info panel not visible)
    if (this.state.selectedNode !== null || !this.nodeGroup) return;

    this.nodeGroup.selectAll('.node')
      .transition()
      .duration(200)
      .ease(d3.easeQuadOut)
      .attr('r', d => {
        const originalSize = d.size || 10;
        const distance = Math.sqrt(Math.pow(d.x - mousePosition.x, 2) + Math.pow(d.y - mousePosition.y, 2));

        // Define influence radius (adjust based on your graph scale)
        const maxInfluenceRadius = 100;

        if (distance <= 30) {
          // Very close - largest zoom (like Mac dock)
          return originalSize * 1.4;
        } else if (distance <= 50) {
          // Close - medium zoom
          return originalSize * 1.25;
        } else if (distance <= maxInfluenceRadius) {
          // Within influence radius - slight zoom with falloff
          const factor = 1 + (0.15 * (1 - distance / maxInfluenceRadius));
          return originalSize * factor;
        } else {
          // Outside influence - normal size
          return originalSize;
        }
      });
  }

  /**
   * Reset dock hover effects to normal node sizes
   */
  resetDockHoverEffects() {
    // Only reset if no node is selected
    if (this.state.selectedNode !== null || !this.nodeGroup) return;

    this.nodeGroup.selectAll('.node')
      .transition()
      .duration(300)
      .ease(d3.easeQuadOut)
      .attr('r', d => d.size || 10);
  }

  /**
   * Apply size scaling to nodes based on their distance from selected node
   * @param {Map} distances - Map of node ID to distance from selected node
   */
  applyNodeSizeScaling(distances) {
    if (!this.nodeGroup) return;

    this.nodeGroup.selectAll('.node')
      .transition()
      .duration(400)
      .ease(d3.easeQuadOut)
      .attr('r', d => {
        const originalSize = d.size || 10;
        const distance = distances.get(d.id);

        if (distance === undefined) {
          // Unconnected nodes - reduce significantly
          return originalSize * 0.6;
        } else if (distance === 0) {
          // Selected node - increase significantly
          return originalSize * 1.5;
        } else if (distance === 1) {
          // Directly connected - increase slightly
          return originalSize * 1.2;
        } else if (distance === 2) {
          // 2 nodes away - slight decrease
          return originalSize * 0.8;
        } else {
          // Further away - decrease more
          return originalSize * Math.max(0.5, 1 - (distance * 0.15));
        }
      });
  }

  /**
   * Reset all nodes to their original sizes
   */
  resetNodeSizes() {
    if (!this.nodeGroup) return;

    this.nodeGroup.selectAll('.node')
      .transition()
      .duration(400)
      .ease(d3.easeQuadOut)
      .attr('r', d => d.size || 10);
  }

  /**
   * Pan the view to center on a specific node
   * @param {Object} node - Node to center on
   */
  centerOnNode(node) {
    if (!node || !this.svg || !this.zoom) return;

    const svgRect = this.svg.node().getBoundingClientRect();
    const centerX = svgRect.width / 2;
    const centerY = svgRect.height / 2;

    // Calculate the transform to center the node
    const currentTransform = d3.zoomTransform(this.svg.node());
    const newTransform = d3.zoomIdentity
      .translate(centerX - node.x * currentTransform.k, centerY - node.y * currentTransform.k)
      .scale(currentTransform.k);

    // Set panning flag to prevent text size updates during transition
    this.state.isPanning = true;

    // Smoothly transition to the new position
    this.svg.transition()
      .duration(400)
      .ease(d3.easeQuadOut)
      .call(this.zoom.transform, newTransform)
      .on('end', () => {
        // Clear panning flag and update text size for final zoom level
        this.state.isPanning = false;
        this.updateTextSizesForZoom(newTransform.k);
        // Update link visibility after panning completes
        this.updateLinkVisibility();
      });
  }

  /**
   * Set selected node and update related node visibility
   * @param {Object|null} node - Selected node or null to clear selection
   */
  setSelectedNode(node) {
    if (node) {
      this.state.selectedNode = node;
      this.state.selectedNodeRelated = this.findRelatedNodes(node);
      this.state.selectedNodeDistances = this.calculateGraphDistances(node);

      // Update VisualEffectsManager with selected node information
      if (this.components.visualEffectsManager) {
        this.components.visualEffectsManager.setSelectedNode(node, this.state.selectedNodeRelated);
      }

      // Apply visual effects
      this.applyNodeSizeScaling(this.state.selectedNodeDistances);
      this.centerOnNode(node);

      // Re-apply audience effects to respect selected node state
      if (this.components.visualEffectsManager) {
        this.components.visualEffectsManager.applyAudienceEffects(this.state.currentAudience, this.nodes);
      }
    } else {
      this.state.selectedNode = null;
      this.state.selectedNodeRelated = new Set();
      this.state.selectedNodeDistances = new Map();

      // Clear VisualEffectsManager selected node information
      if (this.components.visualEffectsManager) {
        this.components.visualEffectsManager.setSelectedNode(null, new Set());
      }

      // Reset visual effects
      this.resetNodeSizes();

      // Re-apply audience effects to normal state
      if (this.components.visualEffectsManager) {
        this.components.visualEffectsManager.applyAudienceEffects(this.state.currentAudience, this.nodes);
      }
    }

    // Update label visibility to show related nodes
    this.updateLabelsForAudience(this.state.currentAudience);

    // Trigger smart label positioning if a node is selected
    if (node && this.components.labelLayoutManager && this.config.features.smartLabelPositioning) {
      // Give a small delay to let the label visibility updates complete
      setTimeout(() => {
        this.components.labelLayoutManager.updateData(this.nodes, this.labelGroup.selectAll('.label'));
      }, 50);
    }
  }

  /**
   * Set active layer
   * @param {string|null} layerId - Layer ID or null for all layers
   */
  setActiveLayer(layerId) {
    this.state.currentLayer = layerId;
    
    if (this.components.visualEffectsManager) {
      this.components.visualEffectsManager.applyLayerEffects(layerId);
    }
    
    if (this.components.interactionManager) {
      this.components.interactionManager.updateLayerMode(layerId !== null);
    }
    
    // Update labels based on subnode visibility and current audience
    this.updateLabelsForAudience(this.state.currentAudience);
    
    this.emit('layerChange', { layer: layerId });
  }

  /**
   * Show all layers
   */
  showAllLayers() {
    this.setActiveLayer(null);
  }

  /**
   * Update data and refresh the graph
   * @param {Object} newData - New data object
   */
  updateData(newData) {
    this.validateAndProcessData(newData);
    
    // Update all components with new data
    Object.values(this.components).forEach(component => {
      if (component && component.updateData) {
        component.updateData(this.nodes, this.links);
      }
    });
    
    this.render();
    this.startSimulation();
    
    this.emit('dataUpdate', { nodeCount: this.nodes.length, linkCount: this.links.length });
  }

  /**
   * Focus on a specific node
   * @param {string} nodeId - Node ID
   */
  focusOnNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node.x !== undefined && node.y !== undefined) {
      this.navigateToPosition({ x: node.x, y: node.y });
      this.emit('nodeFocus', { node });
    }
  }

  /**
   * Restart the simulation
   */
  restartSimulation() {
    if (this.components.forceSimulation) {
      this.components.forceSimulation.restart();
    }
  }

  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    this.config = this.deepMerge(this.config, newConfig);
    
    // Update components with new config
    Object.values(this.components).forEach(component => {
      if (component && component.updateConfig) {
        component.updateConfig(newConfig);
      }
    });
    
    this.emit('configUpdate', { config: this.config });
  }

  /**
   * Add event listener
   * @param {string} eventType - Event type
   * @param {Function} callback - Callback function
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }

  /**
   * Remove event listener
   * @param {string} eventType - Event type
   * @param {Function} callback - Callback function
   */
  off(eventType, callback) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = this.eventHandlers[eventType].filter(cb => cb !== callback);
    }
    return this;
  }

  /**
   * Emit event
   * @param {string} eventType - Event type
   * @param {Object} data - Event data
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event handler for ${eventType}:`, error);
        }
      });
    }
  }

  /**
   * Get current state and statistics
   * @returns {Object} - Current state information
   */
  getState() {
    return {
      ...this.state,
      nodeCount: this.nodes.length,
      linkCount: this.links.length,
      config: this.config,
      components: Object.keys(this.components).reduce((acc, key) => {
        acc[key] = this.components[key] ? 'initialized' : 'not available';
        return acc;
      }, {})
    };
  }

  /**
   * Cleanup and destroy the graph
   */
  destroy() {
    // Destroy all components
    Object.values(this.components).forEach(component => {
      if (component && component.destroy) {
        component.destroy();
      }
    });
    
    // Clear container
    this.container.innerHTML = '';
    
    // Clear references
    this.eventHandlers = {};
    this.components = {};
    this.nodes = [];
    this.links = [];
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = KnowledgeGraphExplorer;
} else if (typeof window !== 'undefined') {
  window.KnowledgeGraphExplorer = KnowledgeGraphExplorer;
}


        // Initialize when ready
        function initGraph() {
            try {
                console.log('Starting graph initialization...');
                
                // Decode base64 data
                const dataStr = atob('eyJub2RlcyI6IFt7ImlkIjogIm1hZ25ldGljX21vbm9wb2xlcyIsICJsYWJlbCI6ICJNYWduZXRpYyBNb25vcG9sZXMiLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogMiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTEsICJlbmQiOiAyMDEyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImJpdHNfZWR1Y2F0aW9uIiwgImNhbGN1bHVzIiwgImxpbmVhcl9hbGdlYnJhIiwgImNvbXBsZXhfYW5hbHlzaXMiXSwgImRlc2NyaXB0aW9uIjogIlRoZSBmaXJzdCBvcmlnaW5hbCBxdWVzdGlvbiBJIGFza2VkIGFuZCB0cmllZCB0byBmb2xsb3cgdGhyb3VnaCAtIE1heHdlbGwncyBlcXVhdGlvbnMgYXJlIGFzeW1tZXRyaWMgc2luY2UgdGhlcmUgYXJlIG5vIG1hZ25ldGljIG1vbm9wb2xlcy4gV2hhdCB3b3VsZCB0aGUgbWF0aGVtYXRpY2FsIHRoZW9yeSBsb29rIGxpa2UgaWYgd2UgcG9zaXQgdGhlaXIgZXhpc3RlbmNlLCBhbmQgd2hhdCB3b3VsZCB0aGUgY29uc2VxdWVuY2VzIGJlPyBBcyBpdCB0dXJuZWQgb3V0LCBJIHJlYWxpemVkIHRoaXMgd2FzIGEgdmVyeSBvbGQgcXVlc3Rpb24gRGlyYWMgaGFkIGFscmVhZHkgYXNrZWQuIn0sIHsiaWQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJsYWJlbCI6ICJRdWFudHVtIEZvdW5kYXRpb25zIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDE1LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMiwgImVuZCI6IDIwMTR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJiaXRzX2VkdWNhdGlvbiIsICJtdW5pY2giLCAiZGV0bGVmX2R1cnIiLCAicGhpbG9zb3BoeV9waHlzaWNzIiwgImJvdHRvbV91cF9hcHByb2FjaCIsICJpbnZpdGVkX3RhbGtzIiwgIm1hc3RlcnNfdGhlc2lzX2xtdSIsICJsYXRleCJdLCAiZGVzY3JpcHRpb24iOiAiSSBnb3QgaW50cmlndWVkIGJ5IHRoZSBub24tbG9jYWwgbmF0dXJlIG9mIHF1YW50dW0gbWVjaGFuaWNzIGFuZCB0aGUgbWVhc3VyZW1lbnQgcHJvYmxlbSwgd2hpY2ggbGVkIG1lIHRvIGV4cGxvcmUgaW50ZXJwcmV0YXRpb25zIG9mIFFNLCBhbmQgaW4gcGFydGljdWxhciBCb2htaWFuIG1lY2hhbmljcy4ifSwgeyJpZCI6ICJkZXRsZWZfZHVyciIsICJsYWJlbCI6ICJEZXRsZWYgRFx1MDBmY3JyIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDE2LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMiwgImVuZCI6IDIwMTR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJtdW5pY2giLCAibWFzdGVyc190aGVzaXNfbG11IiwgInBoaWxvc29waHlfcGh5c2ljcyIsICJib3R0b21fdXBfYXBwcm9hY2giXSwgImRlc2NyaXB0aW9uIjogIk15IGFkdmlzb3IgaW4gTXVuaWNoIHdobywgaW4gbWFueSB3YXlzLCBzaGFwZWQgbXkgd2VsdGJpbGQuIEkgbGVhcm50IG11Y2ggbW9yZSB0aGFuIGp1c3QgcGh5c2ljcyBmcm9tIGhpbTsgaHVtaWxpdHksIGN1cmlvc2l0eSBhYm91dCB0aGUgd29ybGQsIGFuZCBhIGRlZXAgc2Vuc2Ugb2YgY2FyZSBmb3IgdGhlIHBlb3BsZSBoZSBpbnRlcmFjdGVkIHdpdGguIn0sIHsiaWQiOiAicmVub3JtYWxpemF0aW9uIiwgImxhYmVsIjogIlJlbm9ybWFsaXphdGlvbiAmIFVWIFByb2JsZW0iLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogNSwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTMsICJlbmQiOiAyMDE2fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImRldGxlZl9kdXJyIiwgInF1YW50dW1fZm91bmRhdGlvbnMiLCAiY29tcGxleF9hbmFseXNpcyIsICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJmb3VyaWVyX2xhcGxhY2UiLCAicGVydHVyYmF0aW9uX3RoZW9yeSJdLCAiZGVzY3JpcHRpb24iOiAiSSBmaXJzdCBlbmNvdW50ZXJlZCB0aGUgcHJvYmxlbSBvZiByZW5vcm1hbGl6YXRpb24gaW4gY2xhc3NpY2FsIGVsZWN0cm9keW5hbWljcywgd2hpY2ggbGVkIG1lIHRvIGV4cGxvcmUgdGhlIGJyb2FkZXIgaXNzdWUgb2YgaW5maW5pdGllcyBpbiBRRlQgYW5kIHRoZSByZW5vcm1hbGl6YXRpb24gZ3JvdXAuIFVuZGVyc3RhbmRpbmcgV2hlZWxlciBhbmQgRmV5bm1hbidzIGFic29yYmVyIHRoZW9yeSB3YXMgYW5vdGhlciBrZXkgc3RlcCBpbiBzaGFwaW5nIHRoZSBzdHlsZSBvZiB0aG91Z2h0L3dvcmsgd2hlcmUgYXJyaXZpbmcgYXQgYW4gZWxlZ2FudCBhbmQgY29tcGxldGUgbWF0aGVtYXRpY2FsIGZyYW1ld29yayBmb3IgYWxyZWFkeSBlbXBpcmljYWxseSBkZXNjcmliYWJsZSBwaGVub21lbmEgd2FzIHRoZSBmb2N1cy4ifSwgeyJpZCI6ICJzZWxmX2ZvcmNlIiwgImxhYmVsIjogIlNlbGYgRm9yY2UgUHJvYmxlbSIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTMsICJlbmQiOiAyMDE2fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJlbm9ybWFsaXphdGlvbiIsICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAicGVydHVyYmF0aW9uX3RoZW9yeSIsICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJtYXRoZW1hdGljYSJdLCAiZGVzY3JpcHRpb24iOiAiR2l2ZW4gbXkgb3ZlcmFyY2hpbmcgaW50ZXJlc3QgaW4gdGhlIFVWIHByb2JsZW0sIEkgd2FzIG5hdHVyYWxseSBkcmF3biB0byB0aGUgc2VsZi1mb3JjZSBwcm9ibGVtIGluIEdSLCB3aGljaCBpcyBhIGNsYXNzaWNhbCBhbmFsb2d1ZSBvZiB0aGUgcmVub3JtYWxpemF0aW9uIHByb2JsZW0gaW4gUUZULiBUaGlzIHdhcyB3aGF0IHRvb2sgbWUgdG8gU2FtIEdyYWxsYSBhdCB0aGUgVW5pdmVyc2l0eSBvZiBBcml6b25hIGZvciBteSBQaEQuIn0sIHsiaWQiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHkiLCAibGFiZWwiOiAiQmxhY2sgSG9sZSBTdGFiaWxpdHkiLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogMTgsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE2LCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiBmYWxzZSwgInBhcmVudF9ub2RlIjogWyJzZWxmX2ZvcmNlIiwgInVvZmFfZWR1Y2F0aW9uIiwgInNhbV9ncmFsbGEiLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5IiwgInBlcnR1cmJhdGlvbl90aGVvcnkiLCAicHl0aG9uIiwgIm1hdGhlbWF0aWNhIl0sICJkZXNjcmlwdGlvbiI6ICJNeSBQaEQgcmVzZWFyY2ggaW52ZXN0aWdhdGVkIGEgc3VidGxlIGJ1dCBmdW5kYW1lbnRhbCBpbnN0YWJpbGl0eSB0aGF0IG9jY3VycyBhdCBleHRyZW1hbCBibGFjayBob2xlIGhvcml6b25zLiBJIHdhcyBmYXNjaW5hdGVkIGJ5IHVuZGVyc3RhbmRpbmcgdGhlIHBoeXNpY2FsIG1lY2hhbmlzbXMgYmVoaW5kIHRoaXMgcGhlbm9tZW5vbiAtIHdoeSBjZXJ0YWluIHBlcnR1cmJhdGlvbnMgZ2V0IHRyYXBwZWQgbmVhciB0aGUgaG9yaXpvbiBmb3IgcGFyYW1ldHJpY2FsbHkgbG9uZyB0aW1lcyBiZWZvcmUgZmFsbGluZyBpbi4gVXNpbmcgc2ltcGxpZmllZCBtb2RlbHMgbGlrZSB0aGUgQlRaIGJsYWNrIGhvbGUgYXMgYSB0aGVvcmV0aWNhbCBwbGF5Z3JvdW5kLCBJIGRpc2NvdmVyZWQgdGhpcyBpbnN0YWJpbGl0eSBpcyBjb25uZWN0ZWQgdG8gc3BlY2lhbCBudWxsIGdlb2Rlc2ljIHRyYWplY3RvcmllcyB0aGF0IHNwaXJhbCBhcm91bmQgdGhlIGJsYWNrIGhvbGUgbWFueSB0aW1lcyBiZWZvcmUgY3Jvc3NpbmcgdGhlIGhvcml6b24uIEV4dGVuZGluZyB0byBtb3JlIHJlYWxpc3RpYyBnZW9tZXRyaWVzLCBJIGZvdW5kIHRoaXMgaG9yaXpvbiBpbnN0YWJpbGl0eSBwbGF5cyBhIGNydWNpYWwgcm9sZSBpbiBob2xvZ3JhcGhpYyBkdWFsaXR5LCBiZWluZyBlc3NlbnRpYWwgZm9yIG1haW50YWluaW5nIHNlbWktbG9jYWwgcXVhbnR1bSBjcml0aWNhbGl0eSBpbiBkdWFsIGZpZWxkIHRoZW9yaWVzIGFuZCBjb25uZWN0aW5nIGJsYWNrIGhvbGUgcGh5c2ljcyB0byBjcml0aWNhbCBwaGVub21lbmEsIHBvd2VyIGxhd3MsIGFuZCBwaGFzZSB0cmFuc2l0aW9ucy4ifSwgeyJpZCI6ICJidHpfYmxhY2tfaG9sZSIsICJsYWJlbCI6ICJCVFogQmxhY2sgSG9sZSIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTYsICJlbmQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgImNvbXBsZXhfYW5hbHlzaXMiLCAic3BlY2lhbF9mdW5jdGlvbnMiLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5Il0sICJkZXNjcmlwdGlvbiI6ICJBIHRocmVlLWRpbWVuc2lvbmFsIGJsYWNrIGhvbGUgc29sdXRpb24gaW4gQW50aS1kZSBTaXR0ZXIgc3BhY2UgdGhhdCBzZXJ2ZXMgYXMgYSBzaW1wbGlmaWVkIG1vZGVsIGZvciBzdHVkeWluZyBibGFjayBob2xlIHBoeXNpY3Mgd2hpbGUgcmV0YWluaW5nIGVzc2VudGlhbCBmZWF0dXJlcyBsaWtlIGhvcml6b25zIGFuZCB0aGVybW9keW5hbWljcy4gSW4gbXkgcmVzZWFyY2gsIEkgdXNlZCB0aGUgZXh0cmVtYWwgQlRaIGFzIGEgdHJhY3RhYmxlIHBsYXlncm91bmQgdG8gdW5kZXJzdGFuZCB0aGUgQXJldGFraXMgaW5zdGFiaWxpdHksIGRldmVsb3BpbmcgdGltZS1kb21haW4gdGVjaG5pcXVlcyB0byBjb25zdHJ1Y3QgdGhlIHJldGFyZGVkIEdyZWVuIGZ1bmN0aW9uIHVzaW5nIHRoZSBtZXRob2Qgb2YgaW1hZ2VzLiBJIHNvbHZlZCB0aGUgbnVsbCBnZW9kZXNpYyBlcXVhdGlvbiBpbiBmdWxsIGdlbmVyYWxpdHkgYW5kIGRlbW9uc3RyYXRlZCB0aGF0IHRoZSBob3Jpem9uIGluc3RhYmlsaXR5IGFyaXNlcyBmcm9tIGEgc3BlY2lmaWMgY2xhc3Mgb2YgbnVsbCBnZW9kZXNpY3MgdGhhdCBvcmJpdCBuZWFyIHRoZSBldmVudCBob3Jpem9uIGFyYml0cmFyaWx5IG1hbnkgdGltZXMgYmVmb3JlIGZhbGxpbmcgaW4sIHByb3ZpZGluZyB0aGUgZmlyc3QgY2xlYXIgcGh5c2ljYWwgaW50ZXJwcmV0YXRpb24gb2YgaG93IHBlcnR1cmJhdGlvbnMgZ2V0IHRyYXBwZWQgbmVhciBleHRyZW1hbCBob3Jpem9ucy4ifSwgeyJpZCI6ICJhcmV0YWtpc19pbnN0YWJpbGl0eSIsICJsYWJlbCI6ICJBcmV0YWtpcyBJbnN0YWJpbGl0eSIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTYsICJlbmQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgImJ0el9ibGFja19ob2xlIiwgInBlcnR1cmJhdGlvbl90aGVvcnkiLCAiZm91cmllcl9sYXBsYWNlIl0sICJkZXNjcmlwdGlvbiI6ICJBIGNvdW50ZXJpbnR1aXRpdmUgaW5zdGFiaWxpdHkgb2YgZXh0cmVtYWwgYmxhY2sgaG9sZSBob3Jpem9ucyB3aGVyZSBmaWVsZCBwZXJ0dXJiYXRpb25zIGRlY2F5IGV2ZXJ5d2hlcmUgZXhjZXB0IHByZWNpc2VseSBvbiB0aGUgaG9yaXpvbiwgd2hlcmUgdHJhbnN2ZXJzZSBkZXJpdmF0aXZlcyBncm93IHBvbHlub21pYWxseSB3aXRoIHRpbWUuIFRoaXMgaW5zdGFiaWxpdHkgd2FzIHN1cnByaXNpbmcgYmVjYXVzZSBleHRyZW1hbCBibGFjayBob2xlcyB3ZXJlIHRob3VnaHQgdG8gYmUgc3RhYmxlLiBNeSB3b3JrIGV4dGVuZGVkIHVuZGVyc3RhbmRpbmcgb2YgdGhpcyBwaGVub21lbm9uIGZyb20gY29tcGFjdCB0byBwbGFuYXIgaG9yaXpvbiBnZW9tZXRyaWVzLCBzaG93aW5nIGl0IHBlcnNpc3RzIGluIGNhc2VzIHJlbGV2YW50IHRvIGhvbG9ncmFwaHkuIEkgZGVtb25zdHJhdGVkIHRoZSBwaHlzaWNhbCBtZWNoYW5pc206IG51bGwgZ2VvZGVzaWNzIHRoYXQgc3BlbmQgcGFyYW1ldHJpY2FsbHkgbG9uZyB0aW1lcyBuZWFyIHRoZSBob3Jpem9uIGJlZm9yZSBmYWxsaW5nIGluLCBlZmZlY3RpdmVseSB0cmFwcGluZyBwZXJ0dXJiYXRpb25zIGFuZCBjYXVzaW5nIHRoZSBtYXRoZW1hdGljYWwgZ3Jvd3RoIG9mIGRlcml2YXRpdmVzIGF0IHRoZSBob3Jpem9uIGJvdW5kYXJ5LiJ9LCB7ImlkIjogInBfcm5hZHM1IiwgImxhYmVsIjogIlBsYW5hciBSZWlzc25lci1Ob3Jkc3RyXHUwMGY2bSBBZFM1IiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDEwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNiwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYXJldGFraXNfaW5zdGFiaWxpdHkiLCAiYWRzX2NmdCIsICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiXSwgImRlc2NyaXB0aW9uIjogIkZpdmUtZGltZW5zaW9uYWwgY2hhcmdlZCBibGFjayBob2xlcyB3aXRoIHBsYW5hciBob3Jpem9uIHRvcG9sb2d5IGluIEFudGktZGUgU2l0dGVyIHNwYWNlLCBwYXJ0aWN1bGFybHkgcmVsZXZhbnQgZm9yIGhvbG9ncmFwaGljIGFwcGxpY2F0aW9ucy4gV2UgcHJvdmVkIHRoYXQgZXh0cmVtYWwgcGxhbmFyIFJOLUFkUzUgYmxhY2sgaG9sZXMgZXhoaWJpdCB0aGUgQXJldGFraXMgaW5zdGFiaWxpdHkgZGVzcGl0ZSBoYXZpbmcgbm9uLWNvbXBhY3QgaG9yaXpvbiBnZW9tZXRyeSwgZXh0ZW5kaW5nIHByZXZpb3VzIHJlc3VsdHMgdGhhdCByZXF1aXJlZCBjb21wYWN0IGhvcml6b25zLiBUaGlzIHdvcmsgcmV2ZWFsZWQgZGVlcCBjb25uZWN0aW9ucyBiZXR3ZWVuIGJ1bGsgaG9yaXpvbiBpbnN0YWJpbGl0aWVzIGFuZCBib3VuZGFyeSBwaHlzaWNzOiB0aGUgc3BhdGlhbGx5IGxvY2FsaXplZCBwb3dlci1sYXcgZ3Jvd3RoIG9mIHN0cmVzcy1lbmVyZ3kgb24gdGhlIGhvcml6b24gY29ycmVzcG9uZHMgdG8gc2VtaS1sb2NhbCBxdWFudHVtIGNyaXRpY2FsaXR5IGluIHRoZSBkdWFsIGZpZWxkIHRoZW9yeSwgd2hlcmUgdGVtcG9yYWwgY29uZm9ybWFsIHN5bW1ldHJ5IGVtZXJnZXMgYW5kIHRoZSBidWxrIGluc3RhYmlsaXR5IGlzIGVzc2VudGlhbCBmb3IgcHJlc2VydmluZyB0aGlzIHN5bW1ldHJ5IHVuZGVyIGludGVyYWN0aW9ucyJ9LCB7ImlkIjogImNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIiwgImxhYmVsIjogIkNyaXRpY2FsIFBoZW5vbWVuYSAmIFNjYWxpbmciLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogMTQsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE2LCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJwX3JuYWRzNSIsICJib3R0b21fdXBfYXBwcm9hY2giLCAiYWRzX2NmdCIsICJzdGF0aXN0aWNzIiwgImFnZW50X2Jhc2VkX21vZGVsbGluZyJdLCAiZGVzY3JpcHRpb24iOiAiVW5pdmVyc2FsIGJlaGF2aW9yIG5lYXIgcGhhc2UgdHJhbnNpdGlvbnMgY2hhcmFjdGVyaXplZCBieSBwb3dlciBsYXdzLCBzY2FsaW5nIHN5bW1ldHJpZXMsIGFuZCBlbWVyZ2VudCBjb25mb3JtYWwgaW52YXJpYW5jZS4gTXkgZWFybHkgZXhwb3N1cmUgdG8gcGhhc2UgdHJhbnNpdGlvbnMgYW5kIHRoZSByZW5vcm1hbGl6YXRpb24gZ3JvdXAgaW4gc3RhdGlzdGljYWwgcGh5c2ljcyBmYXNjaW5hdGVkIG1lIHdpdGggaG93IHNpbXBsZSBtaWNyb3Njb3BpYyBydWxlcyBjb3VsZCBnaXZlIHJpc2UgdG8gdW5pdmVyc2FsIG1hY3Jvc2NvcGljIGJlaGF2aW9yLiBXaGVuIG15IGJsYWNrIGhvbGUgcmVzZWFyY2ggcmV2ZWFsZWQgdW5leHBlY3RlZCBjb25uZWN0aW9ucyB0byBjcml0aWNhbCBwaGVub21lbmEgLSB3aXRoIGhvcml6b24gaW5zdGFiaWxpdGllcyBjb3JyZXNwb25kaW5nIHRvIHNlbWktbG9jYWwgcXVhbnR1bSBjcml0aWNhbGl0eSBpbiBkdWFsIGZpZWxkIHRoZW9yaWVzIC0gaXQgZGVlcGVuZWQgbXkgYXBwcmVjaWF0aW9uIGZvciBob3cgdGhlc2UgdW5pdmVyc2FsIHBhdHRlcm5zIGVtZXJnZSBhY3Jvc3MgdmFzdGx5IGRpZmZlcmVudCBwaHlzaWNhbCBzeXN0ZW1zLiBUaGlzIHNwYXJrZWQgbXkgYnJvYWRlciBpbnRlcmVzdCBpbiB1bml2ZXJzYWxpdHkgYW5kIGVtZXJnZW50IHBoZW5vbWVuYSBiZXlvbmQgcGh5c2ljczogc2NhbGluZyBsYXdzIGluIG5ldXJhbCBuZXR3b3JrIHRyYWluaW5nLCBwaGFzZSB0cmFuc2l0aW9ucyBpbiBtdWx0aS1hZ2VudCBzeXN0ZW1zLCBtYXJrZXQgZHluYW1pY3MsIGFuZCBjb2xsZWN0aXZlIGJlaGF2aW9yLiBUaGUgbWF0aGVtYXRpY2FsIHNpZ25hdHVyZXMgb2YgY3JpdGljYWxpdHkgLSBwb3dlciBsYXdzLCBzY2FsZSBpbnZhcmlhbmNlLCBlbWVyZ2VudCBzeW1tZXRyaWVzIC0gYXBwZWFyIHJlbWFya2FibHkgY29uc2lzdGVudGx5IGFjcm9zcyBzZWVtaW5nbHkgZGlzcGFyYXRlIGRvbWFpbnMsIHN1Z2dlc3RpbmcgZGVlcCB1bmRlcmx5aW5nIHByaW5jaXBsZXMgZ292ZXJuaW5nIGNvbXBsZXggZW1lcmdlbnQgYmVoYXZpb3IuIn0sIHsiaWQiOiAic2FtX2dyYWxsYSIsICJsYWJlbCI6ICJTYW0gR3JhbGxhIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDE1LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNSwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsidW9mYV9lZHVjYXRpb24iLCAic2VsZl9mb3JjZSIsICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJ0dWNzb24iLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5Il0sICJkZXNjcmlwdGlvbiI6ICJNeSBQaEQgYWR2aXNvciBhdCB0aGUgVW5pdmVyc2l0eSBvZiBBcml6b25hLiBJIHdlbnQgdG8gd29yayB3aXRoIFNhbSBiZWNhdXNlIG9mIGhpcyBleHBlcnRpc2UgaW4gdGhlIHNlbGYtZm9yY2UgcHJvYmxlbSwgYnV0IGVuZGVkIHVwIGdldHRpbmcgaW50ZXJlc3RlZCBpbiBvdGhlciBhcmVhcyBvZiBjbGFzc2ljYWwgYW5kIHNlbWktY2xhc3NpY2FsIHJlbGF0aXZpdHkuIE9uZSB0aGluZyBJIHJlYWxseSBhcHByZWNpYXRlZCBhYm91dCBTYW0ncyByZXNlYXJjaCB3YXMgaGlzIGFuYWx5dGljYWwgYXBwcm9hY2ggdG8gdW5kZXJzdGFuZGluZyBob3cgZGlmZmVyZW50IHBoeXNpY2FsIHNjYWxlcyBpbnRlcmFjdCBpbiB2YXJpb3VzIGxpbWl0cyAtIHRoZSBzeXN0ZW1hdGljIHdheSBoZSBoYW5kbGVkIGFwcHJveGltYXRpb25zIHdoZW4gbXVsdGlwbGUgc2NhbGVzIGFyZSBhdCBwbGF5LiBUaGlzIGJlY2FtZSBhIGtleSBwYXJ0IG9mIGhvdyBJIHRoaW5rIGFib3V0IHBoeXNpY3MgcHJvYmxlbXMuIEV2ZW4gdGhvdWdoIG15IHJlc2VhcmNoIHNoaWZ0ZWQgZnJvbSBzZWxmLWZvcmNlIHRvIGJsYWNrIGhvbGUgc3RhYmlsaXR5LCBTYW0gd2FzIGFuIGV4Y2VsbGVudCBhZHZpc29yIHdobyB0YXVnaHQgbWUgcmlnb3JvdXMgbWF0aGVtYXRpY2FsIHRlY2huaXF1ZXMgYW5kIGhlbHBlZCBtZSBkZXZlbG9wIHBoeXNpY2FsIGludHVpdGlvbiBhYm91dCBncmF2aXRhdGlvbmFsIHBoZW5vbWVuYS4ifSwgeyJpZCI6ICJhZHNfY2Z0IiwgImxhYmVsIjogIkFkUy9DRlQgQ29ycmVzcG9uZGVuY2UiLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogNiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTgsICJlbmQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInBfcm5hZHM1IiwgImNvbXBsZXhfYW5hbHlzaXMiLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5Il0sICJkZXNjcmlwdGlvbiI6ICJIb2xvZ3JhcGhpYyBkdWFsaXR5IGJldHdlZW4gZ3Jhdml0eSB0aGVvcmllcyBpbiBBbnRpLWRlIFNpdHRlciBzcGFjZSBhbmQgY29uZm9ybWFsIGZpZWxkIHRoZW9yaWVzIG9uIHRoZSBib3VuZGFyeS4gSSB3YXMgaW5pdGlhbGx5IGRyYXduIHRvIEFkUy9DRlQgYXMgd2hhdCBJIHRob3VnaHQgd291bGQgYmUgbXkgZW50cnkgcG9pbnQgaW50byBtb3JlIGZ1bmRhbWVudGFsIHBoeXNpY3MsIGdpdmVuIHRoZSBwcm9mb3VuZCBxdWVzdGlvbnMgaXQgcmFpc2VzIGFib3V0IHRoZSBuYXR1cmUgb2Ygc3BhY2V0aW1lIGFuZCBxdWFudHVtIGdyYXZpdHkuIEhvd2V2ZXIsIGl0IHF1aWNrbHkgYmVjYW1lIGNsZWFyIHRoYXQgZnVsbHkgYXBwcmVjaWF0aW5nIHRoZSBjb3JyZXNwb25kZW5jZSByZXF1aXJlcyBkZWVwIGV4cGVydGlzZSBpbiBzdHJpbmcgdGhlb3J5LCB3aGljaCByZW1haW5lZCBiZXlvbmQgbXkgcmVhY2guIE5ldmVydGhlbGVzcywgbXkgYmxhY2sgaG9sZSB3b3JrIHByb3ZpZGVkIGEgd2luZG93IGludG8gc3BlY2lmaWMgYXNwZWN0cyBvZiB0aGUgZHVhbGl0eSwgcGFydGljdWxhcmx5IGhvdyBidWxrIGhvcml6b24gcGh5c2ljcyBtYXBzIHRvIGJvdW5kYXJ5IGNyaXRpY2FsIHBoZW5vbWVuYSwgZ2l2aW5nIG1lIGEgdGFzdGUgb2YgaXRzIHJlbWFya2FibGUgZGVwdGggd2hpbGUgaGlnaGxpZ2h0aW5nIGhvdyBtdWNoIHJlbWFpbnMgdG8gYmUgdW5kZXJzdG9vZC4ifSwgeyJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2giLCAibGFiZWwiOiAiQm90dG9tLVVwIEFwcHJvYWNoIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDE1LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxM30sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IGZhbHNlLCAicGFyZW50X25vZGUiOiBbImRldGxlZl9kdXJyIiwgInBoaWxvc29waHlfcGh5c2ljcyIsICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAicmVpbmZvcmNlbWVudF9sZWFybmluZyJdLCAiZGVzY3JpcHRpb24iOiAiQnVpbGRpbmcgdW5kZXJzdGFuZGluZyBmcm9tIGZ1bmRhbWVudGFsIHByaW5jaXBsZXMgYW5kIG1pY3Jvc2NvcGljIGR5bmFtaWNzLiBUaGlzIGFwcHJvYWNoIHN0YXJ0cyB3aXRoIGJhc2ljIGF4aW9tcyBhYm91dCBob3cgbmF0dXJlIHdvcmtzIGFuZCBkZXJpdmVzIGNvbmNsdXNpb25zIHRocm91Z2ggbWF0aGVtYXRpY2FsIGZyYW1ld29ya3MgLSBsaWtlIEJvaG1pYW4gbWVjaGFuaWNzIHByb3ZpZGluZyBhIGRldGVybWluaXN0aWMgZm91bmRhdGlvbiBmb3IgcXVhbnR1bSBtZWNoYW5pY3MsIG9yIGdlbmVyYWwgcmVsYXRpdml0eSBlbWVyZ2luZyBmcm9tIHRoZSBlcXVpdmFsZW5jZSBwcmluY2lwbGUuIE1vc3Qgb2YgdGhlb3JldGljYWwgcGh5c2ljcyBmb2xsb3dzIHRoaXMgcGF0dGVybjogcHJvcG9zZSBmdW5kYW1lbnRhbCBydWxlcyBhbmQgd29yayBvdXQgdGhlaXIgY29uc2VxdWVuY2VzLiBJIGFwcGx5IHRoaXMgdGhpbmtpbmcgYmV5b25kIHBoeXNpY3MgdG9vLCBsaWtlIGluIGFnZW50LWJhc2VkIG1vZGVsaW5nIHdoZXJlIEkgc3RhcnQgYnkgZGVmaW5pbmcgd2hhdCBpbmRpdmlkdWFsIGFnZW50cyBkbyBpbiBhIG1hcmtldCBhbmQgdGhlbiBzZWUgd2hhdCBlbWVyZ2VudCBwaGVub21lbmEgYXJpc2UsIHJhdGhlciB0aGFuIGp1c3Qgb2JzZXJ2aW5nIHBhdHRlcm5zIGFuZCBzdG9wcGluZyB0aGVyZS4gVGhpcyBhcHByb2FjaCBhcHBlYWxzIHRvIG1lIGJlY2F1c2UgaXQgc2Vla3MgdG8gdW5kZXJzdGFuZCB0aGUgdW5kZXJseWluZyBtZWNoYW5pc21zIHRoYXQgZ2VuZXJhdGUgb2JzZXJ2ZWQgYmVoYXZpb3IuIn0sIHsiaWQiOiAidG9wX2Rvd25fYXBwcm9hY2giLCAibGFiZWwiOiAiVG9wLURvd24gQXBwcm9hY2giLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTUsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIwfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJzdGF0aXN0aWNzIiwgImV4cGVyaW1lbnRhbF9kZXNpZ24iXSwgImRlc2NyaXB0aW9uIjogIlN0YXJ0aW5nIGZyb20gb2JzZXJ2ZWQgcGhlbm9tZW5hIGFuZCB3b3JraW5nIGJhY2t3YXJkcyB0byB1bmRlcmx5aW5nIG1lY2hhbmlzbXMuIFRoaXMgaXMgdGhlIGFwcHJvYWNoIG9mIHN0YXRpc3RpY3MsIG1hY2hpbmUgbGVhcm5pbmcsIGFuZCBBSSAtIHlvdSBiZWdpbiB3aXRoIGRhdGEgYW5kIHRyeSB0byBpbmZlciBwYXR0ZXJucywgcmVsYXRpb25zaGlwcywgb3IgbW9kZWxzIHRoYXQgZXhwbGFpbiB3aGF0IHlvdSBvYnNlcnZlLiBSYXRoZXIgdGhhbiBzdGFydGluZyB3aXRoIHRoZW9yZXRpY2FsIGF4aW9tcywgeW91IGxldCB0aGUgZGF0YSBndWlkZSB5b3UgdG93YXJkIHVuZGVyc3RhbmRpbmcuIFRoaXMgZW1waXJpY2FsIGFwcHJvYWNoIGhhcyBiZWNvbWUgY2VudHJhbCB0byBteSB3b3JrIGluIGRhdGEgc2NpZW5jZSwgd2hlcmUgdGhlIGdvYWwgaXMgb2Z0ZW4gdG8gZXh0cmFjdCBpbnNpZ2h0cyBkaXJlY3RseSBmcm9tIG9ic2VydmVkIGJlaGF2aW9yIHdpdGhvdXQgbmVjZXNzYXJpbHkgaGF2aW5nIGEgY29tcGxldGUgdGhlb3JldGljYWwgZnJhbWV3b3JrIGJlZm9yZWhhbmQuIEJvdGggYXBwcm9hY2hlcyBhcmUgdmFsdWFibGUsIGFuZCBtdWNoIG9mIG15IGN1cnJlbnQgd29yayBpbnZvbHZlcyBicmlkZ2luZyBiZXR3ZWVuIHRoZW0gLSB1c2luZyBib3R0b20tdXAgaW5zaWdodHMgdG8gaW5mb3JtIGRhdGEtZHJpdmVuIG1vZGVscyBhbmQgdXNpbmcgZW1waXJpY2FsIGZpbmRpbmdzIHRvIGd1aWRlIHRoZW9yZXRpY2FsIHVuZGVyc3RhbmRpbmcuIn0sIHsiaWQiOiAicGhpbG9zb3BoeV9waHlzaWNzIiwgImxhYmVsIjogIlBoaWxvc29waHkgb2YgUGh5c2ljcyIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiA2LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMywgImVuZCI6IDIwMTh9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgImV4cGVyaWVuY2VMZXZlbCI6ICJpbnRlcmVzdGVkIiwgInBhcmVudF9ub2RlIjogWyJxdWFudHVtX2ZvdW5kYXRpb25zIiwgImRldGxlZl9kdXJyIiwgIm11bmljaCIsICJiaXRzX2VkdWNhdGlvbiJdLCAiZGVzY3JpcHRpb24iOiAiVGhlIGRlZXAgY29uY2VwdHVhbCBxdWVzdGlvbnMgdW5kZXJseWluZyBwaHlzaWNhbCB0aGVvcmllcyBhbmQgdGhlaXIgaW1wbGljYXRpb25zIGZvciBvdXIgdW5kZXJzdGFuZGluZyBvZiByZWFsaXR5LiBJIHdhcyBwYXJ0aWN1bGFybHkgZHJhd24gdG8gcXVlc3Rpb25zIGFib3V0IHBoeXNpY3MgYW5kIGZyZWUgd2lsbCwgdGFraW5nIGEgY291cnNlIHdpdGggSmVuYW5uIElzbWFlbCB0aGF0IGV4cGxvcmVkIGhvdyBkZXRlcm1pbmlzdGljIHBoeXNpY2FsIGxhd3MgcmVsYXRlIHRvIGh1bWFuIGFnZW5jeSBhbmQgY2hvaWNlLiBUaGUgZm91bmRhdGlvbnMgb2YgcXVhbnR1bSBtZWNoYW5pY3MgYWxzbyBmYXNjaW5hdGVkIG1lIC0gdGhlIG1lYXN1cmVtZW50IHByb2JsZW0sIHRoZSByb2xlIG9mIHRoZSBvYnNlcnZlciwgYW5kIHdoYXQgZGlmZmVyZW50IGludGVycHJldGF0aW9ucyBsaWtlIEJvaG1pYW4gbWVjaGFuaWNzIG1pZ2h0IHRlbGwgdXMgYWJvdXQgdGhlIG5hdHVyZSBvZiByZWFsaXR5LiBUaGVzZSBwaGlsb3NvcGhpY2FsIGlucXVpcmllcyBjb21wbGVtZW50ZWQgbXkgdGVjaG5pY2FsIHBoeXNpY3Mgd29yayBieSBmb3JjaW5nIG1lIHRvIHRoaW5rIGNhcmVmdWxseSBhYm91dCB3aGF0IG91ciBtYXRoZW1hdGljYWwgZnJhbWV3b3JrcyBhY3R1YWxseSBtZWFuIGFuZCB3aGF0IHRoZXkgaW1wbHkgYWJvdXQgdGhlIHdvcmxkLiBVbmRlcnN0YW5kaW5nIHRoZSBjb25jZXB0dWFsIGZvdW5kYXRpb25zIGhlbHBlZCBjbGFyaWZ5IHdoeSBjZXJ0YWluIGFwcHJvYWNoZXMgaW4gcGh5c2ljcyBhcmUgY29tcGVsbGluZyBhbmQgd2hhdCBhc3N1bXB0aW9ucyB3ZSdyZSBtYWtpbmcgd2hlbiB3ZSBhZG9wdCBwYXJ0aWN1bGFyIHRoZW9yZXRpY2FsIGZyYW1ld29ya3MuIn0sIHsiaWQiOiAicHVibGljYXRpb25zIiwgImxhYmVsIjogIlBoeXNpY3MgUHVibGljYXRpb25zIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDEwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxOH0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiBmYWxzZSwgInBhcmVudF9ub2RlIjogWyJibGFja19ob2xlX3N0YWJpbGl0eSIsICJhcmV0YWtpc19pbnN0YWJpbGl0eSIsICJidHpfYmxhY2tfaG9sZSIsICJwX3JuYWRzNSIsICJsYXRleCIsICJzYW1fZ3JhbGxhIl0sICJkZXNjcmlwdGlvbiI6ICJNeSByZXNlYXJjaCBwdWJsaWNhdGlvbnMgaW4gZ3Jhdml0YXRpb25hbCBwaHlzaWNzIGFuZCBibGFjayBob2xlIHRoZW9yeSwgYXZhaWxhYmxlIG9uIElOU1BJUkUtSEVQLiBLZXkgcGFwZXJzIGluY2x1ZGU6XG5cblwiSG9yaXpvbiBpbnN0YWJpbGl0eSBvZiB0aGUgZXh0cmVtYWwgQlRaIGJsYWNrIGhvbGVcIiAoMjAyMCkgLSBTLkUuIEdyYWxsYSwgQS4gUmF2aXNoYW5rYXIsIFAuIFppbW1lcm1hbiwgSm91cm5hbCBvZiBIaWdoIEVuZXJneSBQaHlzaWNzIC0gRGVtb25zdHJhdGVkIHRoZSBBcmV0YWtpcyBpbnN0YWJpbGl0eSBpbiB0aGUgQlRaIGJsYWNrIGhvbGUgYW5kIGNvbm5lY3RlZCBpdCB0byBudWxsIGdlb2Rlc2ljcyB0aGF0IG9yYml0IG5lYXIgdGhlIGhvcml6b24uXG5cblwiU2VtaS1sb2NhbCBxdWFudHVtIGNyaXRpY2FsaXR5IGFuZCB0aGUgaW5zdGFiaWxpdHkgb2YgZXh0cmVtYWwgcGxhbmFyIGhvcml6b25zXCIgKDIwMTgpIC0gUy5FLiBHcmFsbGEsIEEuIFJhdmlzaGFua2FyLCBQLiBaaW1tZXJtYW4gLSBFeHRlbmRlZCB0aGUgQXJldGFraXMgaW5zdGFiaWxpdHkgdG8gcGxhbmFyIGdlb21ldHJpZXMgYW5kIHJldmVhbGVkIGNvbm5lY3Rpb25zIHRvIGNyaXRpY2FsIHBoZW5vbWVuYSBpbiBob2xvZ3JhcGhpYyBmaWVsZCB0aGVvcmllcy5cblxuUGhEIERpc3NlcnRhdGlvbjogXCJPbiB0aGUgSG9yaXpvbiBJbnN0YWJpbGl0eSBvZiBFeHRyZW1hbCBCbGFjayBIb2xlcyBhbmQgQmxhY2sgQnJhbmVzXCIgKDIwMjEpIC0gVW5pdmVyc2l0eSBvZiBBcml6b25hIC0gQ29tcHJlaGVuc2l2ZSBzdHVkeSBvZiBleHRyZW1hbCBob3Jpem9uIGluc3RhYmlsaXRpZXMgYWNyb3NzIGRpZmZlcmVudCBnZW9tZXRyaWVzIGFuZCB0aGVpciBpbXBsaWNhdGlvbnMgZm9yIGhvbG9ncmFwaGljIGR1YWxpdHkuXG5cblRoZXNlIHB1YmxpY2F0aW9ucyByZXByZXNlbnQgbXkgY29udHJpYnV0aW9ucyB0byB1bmRlcnN0YW5kaW5nIGJsYWNrIGhvbGUgc3RhYmlsaXR5IGFuZCB0aGUgc3VycHJpc2luZyBjb25uZWN0aW9ucyBiZXR3ZWVuIGdyYXZpdGF0aW9uYWwgcGh5c2ljcyBhbmQgY3JpdGljYWwgcGhlbm9tZW5hLlxuIn0sIHsiaWQiOiAiY29uZmVyZW5jZXMiLCAibGFiZWwiOiAiQ29uZmVyZW5jZXMgJiBTY2hvb2xzIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDEwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNCwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IGZhbHNlLCAicGFyZW50X25vZGUiOiBbInB1YmxpY2F0aW9ucyIsICJpbnZpdGVkX3RhbGtzIiwgImxhdGV4IiwgInVvZmFfZWR1Y2F0aW9uIl0sICJkZXNjcmlwdGlvbiI6ICJQcmVzZW50YXRpb25zIGF0IG1ham9yIHBoeXNpY3MgY29uZmVyZW5jZXMgaW5jbHVkaW5nIFBhY2lmaWMgQ29hc3QgR3Jhdml0eSBNZWV0ICgyMDE4LCAyMDIxKSBhdCBDYWx0ZWNoIGFuZCBVbml2ZXJzaXR5IG9mIEFyaXpvbmEsIGFuZCBBbWVyaWNhbiBQaHlzaWNhbCBTb2NpZXR5IEFwcmlsIE1lZXRpbmcgKDIwMTkpIGluIERlbnZlci4gVG9waWNzIGZvY3VzZWQgb24gZXh0cmVtYWwgYmxhY2sgaG9sZSBpbnN0YWJpbGl0aWVzLCBjcml0aWNhbCBiZWhhdmlvciBpbiBob2xvZ3JhcGhpYyBzeXN0ZW1zLCBhbmQgdGhlIEJUWiBibGFjayBob2xlIGhvcml6b24gaW5zdGFiaWxpdHkuIEFsc28gYXR0ZW5kZWQgc3BlY2lhbGl6ZWQgd29ya3Nob3BzIGFuZCBzY2hvb2xzIGluY2x1ZGluZyB0aGUgU3VtbWVyIFNjaG9vbCBvbiBGb3VuZGF0aW9ucyBvZiBRdWFudHVtIE1lY2hhbmljcyBkZWRpY2F0ZWQgdG8gSm9obiBCZWxsICgyMDE0KSwgV29ya3Nob3Agb24gTXVsdGktVGltZSBXYXZlZnVuY3Rpb25zIGF0IFJ1dGdlcnMgKDIwMTgpLCBhbmQgQmFyY2Vsb25hIFN1bW1lciBTY2hvb2wgb24gTWFjaGluZSBMZWFybmluZyBhbmQgTWVjaGFuaXN0aWMgTW9kZWxpbmcgKDIwMTkpLlxuIn0sIHsiaWQiOiAiaW52aXRlZF90YWxrcyIsICJsYWJlbCI6ICJJbnZpdGVkIFRhbGtzIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDgsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE0LCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIl0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsiY29uZmVyZW5jZXMiLCAicHVibGljYXRpb25zIiwgInF1YW50dW1fZm91bmRhdGlvbnMiLCAiYmxhY2tfaG9sZV9zdGFiaWxpdHkiXSwgImRlc2NyaXB0aW9uIjogIkludml0ZWQgcHJlc2VudGF0aW9ucyBhdCBsZWFkaW5nIHJlc2VhcmNoIGluc3RpdHV0aW9ucyBpbiBJbmRpYSBhbmQgR2VybWFueS4gR2F2ZSB0YWxrcyBvbiBcIlRoZSBBcmV0YWtpcyBpbnN0YWJpbGl0eSBvZiBleHRyZW1hbCBhc3ltcHRvdGljYWxseSBBZFMgYmxhY2sgaG9sZXNcIiBhdCBDaGVubmFpIE1hdGhlbWF0aWNhbCBJbnN0aXR1dGUgYW5kIEluc3RpdHV0ZSBvZiBNYXRoZW1hdGljYWwgU2NpZW5jZXMgKDIwMTkpLCBzaGFyaW5nIG15IFBoRCByZXNlYXJjaCBmaW5kaW5ncyB3aXRoIHRoZSBJbmRpYW4gdGhlb3JldGljYWwgcGh5c2ljcyBjb21tdW5pdHkuIEVhcmxpZXIgcHJlc2VudGVkIHdvcmsgb24gcXVhbnR1bSBtZWNoYW5pY3MgZm91bmRhdGlvbnMgYXQgTHVkd2lnIE1heGltaWxpYW5zIFVuaXZlcnNpdHksIE11bmljaCAoMjAxNCkgb24gXCJUaGUgdGltZSBvcGVyYXRvciBhbmQgdGhlIHRpbWUtZW5lcmd5IHVuY2VydGFpbnR5IHJlbGF0aW9uIGluIHF1YW50dW0gbWVjaGFuaWNzXCIgZHVyaW5nIG15IG1hc3RlcidzIHRoZXNpcyBwZXJpb2QuXG4ifSwgeyJpZCI6ICJ1b2ZhX2VkdWNhdGlvbiIsICJsYWJlbCI6ICJVbml2ZXJzaXR5IG9mIEFyaXpvbmEiLCAibGF5ZXIiOiAicGVyc29uYWwiLCAic2l6ZSI6IDEzLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNSwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsiYml0c19lZHVjYXRpb24iLCAidHVjc29uIiwgInNhbV9ncmFsbGEiLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJQaEQgaW4gUGh5c2ljcyB1bmRlciBTYW11ZWwgRS4gR3JhbGxhLCBmb2N1c2luZyBvbiBleHRyZW1hbCBibGFjayBob2xlIGhvcml6b24gaW5zdGFiaWxpdGllcy4gQWxzbyBjb21wbGV0ZWQgTWFzdGVyIG9mIFNjaWVuY2UgaW4gUGh5c2ljcyBhcyBwYXJ0IG9mIHRoZSBkb2N0b3JhbCBwcm9ncmFtLiJ9LCB7ImlkIjogImJpdHNfZWR1Y2F0aW9uIiwgImxhYmVsIjogIkJJVFMgUGlsYW5pIiwgImxheWVyIjogInBlcnNvbmFsIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMDksICJlbmQiOiAyMDE0fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IGZhbHNlLCAicGFyZW50X25vZGUiOiBbImh5ZGVyYWJhZCIsICJjYWxjdWx1cyIsICJsaW5lYXJfYWxnZWJyYSIsICJjb21wbGV4X2FuYWx5c2lzIl0sICJkZXNjcmlwdGlvbiI6ICJJbnRlZ3JhdGVkIE1hc3RlciBvZiBTY2llbmNlIGluIFBoeXNpY3MgKEhvbm9ycykgYW5kIEJhY2hlbG9yIG9mIFBoYXJtYWN5IChIb25vcnMpIGZyb20gQmlybGEgSW5zdGl0dXRlIG9mIFRlY2hub2xvZ3kgYW5kIFNjaWVuY2VzLCBQaWxhbmksIEh5ZGVyYWJhZC4ifSwgeyJpZCI6ICJncmFkdWF0ZV9yZXNlYXJjaCIsICJsYWJlbCI6ICJHcmFkdWF0ZSBSZXNlYXJjaCAtIFVvZkEiLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE1LCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInVvZmFfZWR1Y2F0aW9uIiwgImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInB5dGhvbiIsICJtYXRoZW1hdGljYSJdLCAiZGVzY3JpcHRpb24iOiAiR3JhZHVhdGUgUmVzZWFyY2ggQXNzb2NpYXRlIGludmVzdGlnYXRpbmcgZXh0cmVtYWwgYmxhY2sgaG9sZSBob3Jpem9uIGluc3RhYmlsaXRpZXMuIERpc2NvdmVyZWQgY29ubmVjdGlvbnMgYmV0d2VlbiBncmF2aXRhdGlvbmFsIHBoeXNpY3MgYW5kIHNlbWktbG9jYWwgcXVhbnR1bSBjcml0aWNhbGl0eSwgaWRlbnRpZmllZCBwaHlzaWNhbCBtZWNoYW5pc21zIGludm9sdmluZyBudWxsIGdlb2Rlc2ljcywgYW5kIGRldmVsb3BlZCBjb21wdXRhdGlvbmFsIG1ldGhvZHMgdXNpbmcgTWF0aGVtYXRpY2EgYW5kIFB5dGhvbiBvbiBzdXBlcmNvbXB1dGVycy4ifSwgeyJpZCI6ICJtYXN0ZXJzX3RoZXNpc19sbXUiLCAibGFiZWwiOiAiTWFzdGVyJ3MgVGhlc2lzIC0gTE1VIE11bmljaCIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTMsICJlbmQiOiAyMDE0fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImRldGxlZl9kdXJyIiwgIm11bmljaCIsICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgImxhdGV4Il0sICJkZXNjcmlwdGlvbiI6ICJSZXNlYXJjaCBvbiBhcnJpdmFsIHRpbWUgZGlzdHJpYnV0aW9ucyBpbiBxdWFudHVtIHRoZW9yeSwgY2lyY3VtdmVudGluZyBQYXVsaSdzIHRoZW9yZW0gdG8gZGVzY3JpYmUgYXJyaXZhbCB0aW1lIHN0YXRpc3RpY3MsIGFuZCBleHBsb3JpbmcgcmVub3JtYWxpemF0aW9uIGluIFF1YW50dW0gRWxlY3Ryb2R5bmFtaWNzIHVzaW5nIFdoZWVsZXItRmV5bm1hbiBFbGVjdHJvZHluYW1pY3MgaWRlYXMuIn0sIHsiaWQiOiAidGVhY2hpbmdfdW9mYSIsICJsYWJlbCI6ICJUZWFjaGluZyAtIFVuaXZlcnNpdHkgb2YgQXJpem9uYSIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNSwgImVuZCI6IDIwMjB9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJ1b2ZhX2VkdWNhdGlvbiIsICJ0dWNzb24iLCAiY2FsY3VsdXMiLCAibGluZWFyX2FsZ2VicmEiXSwgImRlc2NyaXB0aW9uIjogIkdyYWR1YXRlIFRlYWNoaW5nIEFzc29jaWF0ZSBmb3IgaW50cm9kdWN0b3J5IGFuZCBpbnRlcm1lZGlhdGUgcGh5c2ljcyBjb3Vyc2VzIGluY2x1ZGluZyBtZWNoYW5pY3MsIGVsZWN0cm9tYWduZXRpc20sIGxhYm9yYXRvcnkgd29yaywgYW5kIGhvbm9ycyBzZWN0aW9ucy4gVGF1Z2h0IGFjcm9zcyBtdWx0aXBsZSBzZW1lc3RlcnMgZnJvbSAyMDE1LTIwMjEuIn0sIHsiaWQiOiAiZmFzY2luYXRpb25fbGVhcm5pbmciLCAibGFiZWwiOiAiRmFzY2luYXRpb24gQmFzZWQgTGVhcm5pbmciLCAibGF5ZXIiOiAiYXBwbGljYXRpb25zIiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMywgImVuZCI6IDIwMTR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbIm11bmljaCIsICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAiYm90dG9tX3VwX2FwcHJvYWNoIl0sICJkZXNjcmlwdGlvbiI6ICJDby1mb3VuZGluZyB0ZWFtIG1lbWJlciBvZiBNdW5pY2gtYmFzZWQgc3RhcnR1cCBjcmVhdGluZyBmYXNjaW5hdGlvbi1iYXNlZCBsZWFybmluZyBwbGF0Zm9ybS4gUHJvZHVjZWQgcGVkYWdvZ2ljYWwgY29udGVudCBhbmQgY29vcmRpbmF0ZWQgd2l0aCBpbnRlcmRpc2NpcGxpbmFyeSB0ZWFtIHRvIGRldmVsb3AgTVZQIGNvbWJpbmluZyBsaW5lYXIgYW5kIG5vbi1saW5lYXIgcGVkYWdvZ3kgYXBwcm9hY2hlcy4ifSwgeyJpZCI6ICJ0dXJub19leHBlcmllbmNlIiwgImxhYmVsIjogIlR1cm5vIC0gTWFya2V0cGxhY2UgRGF0YSBTY2llbnRpc3QiLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsidmFuY291dmVyIiwgInJvdmVyX2V4cGVyaWVuY2UiLCAicmVjb21tZW5kYXRpb25fc3lzdGVtcyIsICJnYW1lX3RoZW9yeSIsICJtYXJrZXRwbGFjZXMiXSwgImRlc2NyaXB0aW9uIjogIk1hcmtldHBsYWNlIERhdGEgU2NpZW50aXN0IGJ1aWxkaW5nIGFuYWx5dGljcyBmcmFtZXdvcmtzIGZvciBzdXBwbHktZGVtYW5kIGhlYWx0aCBhbmFseXNpcywgcmVjb21tZW5kYXRpb24gc3lzdGVtcyBhY2hpZXZpbmcgNDAlIGZ1bm5lbCBjb252ZXJzaW9uIGxpZnQsIGFuZCBjdXN0b21lciBsaWZldGltZSB2YWx1ZSBwcmVkaWN0aW9uIG1vZGVscy4gRGV2ZWxvcGVkIGVuZC10by1lbmQgTUwgZnJhbWV3b3JrcyBmcm9tIGlkZWF0aW9uIHRocm91Z2ggZGVwbG95bWVudCBhbmQgbW9uaXRvcmluZyBmb3IgbWFya2V0cGxhY2Ugb3B0aW1pemF0aW9uLiJ9LCB7ImlkIjogInJvdmVyX2V4cGVyaWVuY2UiLCAibGFiZWwiOiAiUm92ZXIgLSBEYXRhIFNjaWVudGlzdCBJSSAmIElJSSIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiAxOCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjEsICJlbmQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IGZhbHNlLCAicGFyZW50X25vZGUiOiBbImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAic2VhdHRsZSIsICJzY2hudWNraSIsICJtYXJrZXRwbGFjZXMiLCAicHl0aG9uIiwgInNxbCJdLCAiZGVzY3JpcHRpb24iOiAiSSB3YXMgYSBEYXRhIFNjaWVudGlzdCBpbiB0aGUgc3VwcGx5IG1hbmFnZW1lbnQgdGVhbSwgZGV2ZWxvcGluZyBmb3JlY2FzdGluZyBhbmQgTWFya292IENoYWluIG1vZGVscyBmb3Igc3VwcGx5LWRlbWFuZCBvcHRpbWl6YXRpb24gYWNyb3NzIGdsb2JhbCBwZXQgc2VydmljZXMgbWFya2V0cywgZHJpdmluZyA0JSBhbm51YWwgcmV2ZW51ZSBpbmNyZWFzZS4gQnVpbHQgcmVjb21tZW5kYXRpb24gYWxnb3JpdGhtcywgRVRMIHBpcGVsaW5lcywgYWdlbnQtYmFzZWQgbW9kZWxzIGZvciBzdHJhdGVnaWMgcGxhbm5pbmcsIGFuZCBkZXBsb3llZCBMTE0gc29sdXRpb25zIGZvciB0aGUgVHJ1c3QgJiBTYWZldHkgdGVhbS4ifSwgeyJpZCI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIiwgImxhYmVsIjogIlRoZSBEYXRhIEluY3ViYXRvciAtIEZlbGxvd3NoaXAiLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIxLCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiBmYWxzZSwgInBhcmVudF9ub2RlIjogWyJ1b2ZhX2VkdWNhdGlvbiIsICJweXRob24iLCAic3RhdGlzdGljcyIsICJ0b3BfZG93bl9hcHByb2FjaCIsICJzZWF0dGxlIl0sICJkZXNjcmlwdGlvbiI6ICJJbnRlbnNpdmUgZGF0YSBzY2llbmNlIGZlbGxvd3NoaXAgcHJvZ3JhbSBmb3IgU1RFTSBQaERzLiBDb21wbGV0ZWQgY2Fwc3RvbmUgcHJvamVjdCBvbiBTb3V0aCBJbmRpYW4gY2xhc3NpY2FsIG11c2ljIHJhZ2FtIGlkZW50aWZpY2F0aW9uIHVzaW5nIG1hY2hpbmUgbGVhcm5pbmcsIGFjaGlldmluZyA3NSUgYWNjdXJhY3kgb24gMTAtY2xhc3MgY2xhc3NpZmljYXRpb24uIERldmVsb3BlZCBGbGFzayB3ZWIgYXBwbGljYXRpb24gYW5kIHdvcmtlZCBvbiB0cmFuc2ZlciBsZWFybmluZyB3aXRoIENOTnMgZm9yIGltYWdlIGNsYXNzaWZpY2F0aW9uLiJ9LCB7ImlkIjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAibGFiZWwiOiAiUGVydHVyYmF0aW9uIFRoZW9yeSIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNSwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYmxhY2tfaG9sZV9zdGFiaWxpdHkiLCAiY29tcGxleF9hbmFseXNpcyIsICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAiZm91cmllcl9sYXBsYWNlIl0sICJkZXNjcmlwdGlvbiI6ICJTeXN0ZW1hdGljIG1ldGhvZCBmb3IgZmluZGluZyBhcHByb3hpbWF0ZSBzb2x1dGlvbnMgdG8gcHJvYmxlbXMgdGhhdCBjYW5ub3QgYmUgc29sdmVkIGV4YWN0bHksIGVzc2VudGlhbCBmb3IgYmxhY2sgaG9sZSBwaHlzaWNzIGNhbGN1bGF0aW9ucywgd2hlcmUgbm9uLWxpbmVhciBiZWhhdmlvciBpcyBoaWdobHkgaW50cmFjdGFibGUuIn0sIHsiaWQiOiAiY29tcGxleF9hbmFseXNpcyIsICJsYWJlbCI6ICJDb21wbGV4IEFuYWx5c2lzIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDYsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDEyLCAiZW5kIjogMjAxOH0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJiaXRzX2VkdWNhdGlvbiIsICJjYWxjdWx1cyIsICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJmb3VyaWVyX2xhcGxhY2UiXSwgImRlc2NyaXB0aW9uIjogIlRoZW9yeSBvZiBmdW5jdGlvbnMgb2YgY29tcGxleCB2YXJpYWJsZXMsIGNyaXRpY2FsIGZvciBhZHZhbmNlZCBwaHlzaWNzIGFuZCBtYXRoZW1hdGljYWwgbW9kZWxpbmcuIE1vc3Qgb2YgbXkgcmVzZWFyY2ggb24gT0RFcyBpbiBibGFjayBob2xlIHNwYWNldGltZXMgaW52b2x2ZWQgY29tcGxleCBhbmFseXNpcyB0ZWNobmlxdWVzLiJ9LCB7ImlkIjogInNwZWNpYWxfZnVuY3Rpb25zIiwgImxhYmVsIjogIlNwZWNpYWwgRnVuY3Rpb25zICYgT0RFcyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiA3LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNCwgImVuZCI6IDIwMTl9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiY29tcGxleF9hbmFseXNpcyIsICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgIm1hdGhlbWF0aWNhIiwgInB5dGhvbiJdLCAiZGVzY3JpcHRpb24iOiAiSHlwZXJnZW9tZXRyaWMgZnVuY3Rpb25zLCBXaGl0dGFrZXIgRnVuY3Rpb25zLCBIYW5rZWwgZnVuY3Rpb25zLCBCZXNzZWwgZnVuY3Rpb25zLCBhbW9uZ3N0IG1hbnkgb3RoZXJzLCBhbmQgZGlmZmVyZW50aWFsIGVxdWF0aW9uIHRlY2huaXF1ZXMgZm9yIHNvbHZpbmcgcGh5c2ljcyBwcm9ibGVtcy4gTW9zdCBvZiBteSByZXNlYXJjaCBpbnZvbHZlZCB0aGUgc3R1ZHkgb2YgdGhlc2Ugc3BlY2lhbCBmdW5jdGlvbnMuIn0sIHsiaWQiOiAiZm91cmllcl9sYXBsYWNlIiwgImxhYmVsIjogIkZvdXJpZXIgJiBMYXBsYWNlIFRyYW5zZm9ybXMiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTEsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDExfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImNvbXBsZXhfYW5hbHlzaXMiLCAicGVydHVyYmF0aW9uX3RoZW9yeSIsICJpc2FpX3Byb2plY3QiLCAidGltZV9zZXJpZXNfZm9yZWNhc3RpbmciXSwgImRlc2NyaXB0aW9uIjogIkZyZXF1ZW5jeSBkb21haW4gYW5hbHlzaXMgYW5kIGludGVncmFsIHRyYW5zZm9ybXMsIGJyaWRnaW5nIHBoeXNpY3MgYW5kIGRhdGEgc2NpZW5jZSBhcHBsaWNhdGlvbnMuIFVzZWQgZXh0ZW5zaXZlbHkgaW4gYmxhY2sgaG9sZSBwZXJ0dXJiYXRpb24gdGhlb3J5IGFuZCB0aW1lIHNlcmllcyBhbmFseXNpcyBvZiBhdWRpbyBkYXRhLiJ9LCB7ImlkIjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJsYWJlbCI6ICJEaWZmZXJlbnRpYWwgR2VvbWV0cnkiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogOSwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTQsICJlbmQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInVvZmFfZWR1Y2F0aW9uIiwgImxpbmVhcl9hbGdlYnJhIiwgImNhbGN1bHVzIiwgInNhbV9ncmFsbGEiXSwgImRlc2NyaXB0aW9uIjogIk1hdGhlbWF0aWNhbCBmcmFtZXdvcmsgZm9yIGdlbmVyYWwgcmVsYXRpdml0eSBhbmQgY3VydmVkIHNwYWNldGltZSBwaHlzaWNzLiJ9LCB7ImlkIjogImNhbGN1bHVzIiwgImxhYmVsIjogIkNhbGN1bHVzIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDgsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDA5fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYml0c19lZHVjYXRpb24iLCAibWFnbmV0aWNfbW9ub3BvbGVzIiwgImNvbXBsZXhfYW5hbHlzaXMiLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5Il0sICJkZXNjcmlwdGlvbiI6ICJGdW5kYW1lbnRhbCBtYXRoZW1hdGljYWwgdG9vbCB1bmRlcmx5aW5nIGFsbCBxdWFudGl0YXRpdmUgYW5hbHlzaXMuIn0sIHsiaWQiOiAibGluZWFyX2FsZ2VicmEiLCAibGFiZWwiOiAiTGluZWFyIEFsZ2VicmEiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogOCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMDl9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJiaXRzX2VkdWNhdGlvbiIsICJjYWxjdWx1cyIsICJweXRob24iLCAiY2xhc3NpZmljYXRpb24iLCAicmVncmVzc2lvbiJdLCAiZGVzY3JpcHRpb24iOiAiTWF0cml4IG9wZXJhdGlvbnMgYW5kIHZlY3RvciBzcGFjZXMsIGVzc2VudGlhbCBmb3IgcXVhbnR1bSBwaHlzaWNzLCBtYWNoaW5lIGxlYXJuaW5nIGFuZCBkYXRhIGFuYWx5c2lzLiJ9LCB7ImlkIjogInN0YXRpc3RpY3MiLCAibGFiZWwiOiAiU3RhdGlzdGljcyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjB9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJiYXllc2lhbl9zdGF0aXN0aWNzIiwgInB5dGhvbiJdLCAiZGVzY3JpcHRpb24iOiAiTWF0aGVtYXRpY2FsIGZvdW5kYXRpb24gZm9yIGRhdGEgYW5hbHlzaXMsIGh5cG90aGVzaXMgdGVzdGluZywgYW5kIHVuY2VydGFpbnR5IHF1YW50aWZpY2F0aW9uLiJ9LCB7ImlkIjogImdhbWVfdGhlb3J5IiwgImxhYmVsIjogIkdhbWUgVGhlb3J5IiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDcsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJ0dXJub19leHBlcmllbmNlIiwgImRlY2lzaW9uX21ha2luZ19hZ2VudHMiLCAiYXVjdGlvbnNfZGVzaWduIiwgIm1hcmtldHBsYWNlcyJdLCAiZGVzY3JpcHRpb24iOiAiTWF0aGVtYXRpY2FsIGZyYW1ld29yayBmb3Igc3RyYXRlZ2ljIGRlY2lzaW9uLW1ha2luZyBhbmQgbXVsdGktYWdlbnQgaW50ZXJhY3Rpb25zLiBJJ3ZlIGJlZW4gaW50ZXJlc3RlZCBpbiB0aGlzIGFyZWEgYmVjYXVzZSBvZiBteSBpbnRlcmVzdCBpbiBtYXJrZXRwbGFjZSBlY29ub21pY3MgYW5kIGdhbWUtcGxheS4ifSwgeyJpZCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgImxhYmVsIjogIlJlY29tbWVuZGF0aW9uIFN5c3RlbXMiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTQsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJweXRob24iLCAiY2xhc3NpZmljYXRpb24iLCAibGVhcm5fdG9fcmFuayJdLCAiZGVzY3JpcHRpb24iOiAiQWxnb3JpdGhtcyBmb3IgbWF0Y2hpbmcgdXNlcnMgd2l0aCByZWxldmFudCBjb250ZW50IG9yIHNlcnZpY2VzIGluIG1hcmtldHBsYWNlIHNldHRpbmdzLiBJIHRyYWluZWQgYW5kIGRlcGxveWVkIGNvbXBvbmVudHMgb2YgYSByZWNvbW1lbmRhdGlvbiBzeXN0ZW0gYXQgUm92ZXIsIGFuZCBhbmFseXplZCBleHBlcmltZW50cyBiZWZvcmUgcm9sbGluZyBvdXQgdGhlIHN5c3RlbSB0byBhbGwgdXNlcnMuIEF0IFR1cm5vLCBJIGJ1aWx0IGZyb20gZW5kIHRvIGVuZCwgdGhlIGVudGlyZSByZWNvbW1lbmRhdGlvbiBzeXN0ZW0gZnJhbWV3b3JrIGZvciByYW5raW5nIHNlcnZpY2UgcHJvdmlkZXJzIGF0IHNlYXJjaCwgaWUuIGlkZWF0aW9uIC0+IGZlYXR1cmUgZW5naW5lZXJpbmcgLT4gbW9kZWwgdHJhaW5pbmcgLT4gZGVwbG95bWVudCAtPiB0ZXN0aW5nIC0+IG1vbml0b3JpbmcuIn0sIHsiaWQiOiAiY2x1c3RlcmluZ19hbGdvcml0aG1zIiwgImxhYmVsIjogIkNsdXN0ZXJpbmcgQWxnb3JpdGhtcyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJweXRob24iLCAiZ2Vvc3BhdGlhbF9hbmFseXNpcyIsICJzZW1hbnRpY19zZWFyY2giXSwgImRlc2NyaXB0aW9uIjogIlVuc3VwZXJ2aXNlZCBsZWFybmluZyBtZXRob2RzIGZvciBkaXNjb3ZlcmluZyBwYXR0ZXJucyBhbmQgZ3JvdXBpbmdzIGluIGRhdGEuIEkgdXNlZCBjbHVzdGVyaW5nIHRlY2huaXF1ZXMgdG8gZGVmaW5lIHJlYXNvbmFibGUgbWFya2V0IGJvdW5kYXJpZXMgZm9yIHN1cHBseS1kZW1hbmQgZm9yZWNhc3RpbmcgYXQgVHVybm8uIn0sIHsiaWQiOiAiY2xhc3NpZmljYXRpb24iLCAibGFiZWwiOiAiQ2xhc3NpZmljYXRpb24iLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTMsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJweXRob24iLCAibGluZWFyX2FsZ2VicmEiLCAic3RhdGlzdGljcyIsICJpc2FpX3Byb2plY3QiXSwgImRlc2NyaXB0aW9uIjogIlN1cGVydmlzZWQgbGVhcm5pbmcgdGVjaG5pcXVlcyBmb3IgcHJlZGljdGluZyBjYXRlZ29yaWNhbCBvdXRjb21lcy4gVXNlZCBhY3Jvc3MgYSB2YXJpZXR5IG9mIGFwcGxpY2F0aW9ucyBhdCBSb3ZlciBhbmQgVHVybm8uIn0sIHsiaWQiOiAicmVncmVzc2lvbiIsICJsYWJlbCI6ICJSZWdyZXNzaW9uIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDE0LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAicHl0aG9uIiwgImxpbmVhcl9hbGdlYnJhIiwgInN0YXRpc3RpY3MiLCAicHJpY2luZ19lbGFzdGljaXR5Il0sICJkZXNjcmlwdGlvbiI6ICJTdGF0aXN0aWNhbCBtZXRob2RzIGZvciBtb2RlbGluZyByZWxhdGlvbnNoaXBzIGJldHdlZW4gdmFyaWFibGVzIGFuZCBwcmVkaWN0aW5nIGNvbnRpbnVvdXMgb3V0Y29tZXMuIFVzZWQgZXh0ZW5zaXZlbHkgZm9yIHZhcmlvdXMgYXBwbGljYXRpb25zIGF0IFJvdmVyIGFuZCBUdXJuby4ifSwgeyJpZCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJsYWJlbCI6ICJUaW1lIFNlcmllcyBGb3JlY2FzdGluZyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxMiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJyb3Zlcl9leHBlcmllbmNlIiwgInB5dGhvbiIsICJzdGF0aXN0aWNzIiwgImZvdXJpZXJfbGFwbGFjZSIsICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0Il0sICJkZXNjcmlwdGlvbiI6ICJQcmVkaWN0aW5nIGZ1dHVyZSB2YWx1ZXMgYmFzZWQgb24gaGlzdG9yaWNhbCB0ZW1wb3JhbCBwYXR0ZXJucywgY3J1Y2lhbCBmb3IgZGVtYW5kIGZvcmVjYXN0aW5nLiBVc2VkIFByb3BoZXQgYW5kIEFSSU1BIG1vZGVscyB0byBmb3JlY2FzdCBzdXBwbHkgYW5kIGRlbWFuZCBhdCBSb3Zlci4gQ29uZHVjdGVkIGV4dGVuc2l2ZSBiYWNrdGVzdGluZyBhbmQgbW9kZWwgdmFsaWRhdGlvbiB0byBlbnN1cmUgcm9idXN0IHBlcmZvcm1hbmNlLiJ9LCB7ImlkIjogIm1hcmtvdl9jaGFpbl9tb2RlbHMiLCAibGFiZWwiOiAiTWFya292IENoYWluIE1vZGVscyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxNCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjIsICJlbmQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAic3RhdGlzdGljcyIsICJweXRob24iLCAic3VwcGx5X2RlbWFuZF9mb3JlY2FzdCJdLCAiZGVzY3JpcHRpb24iOiAiU3RvY2hhc3RpYyBwcm9jZXNzZXMgZm9yIG1vZGVsaW5nIHNlcXVlbnRpYWwgYmVoYXZpb3IgYW5kIHN0YXRlIHRyYW5zaXRpb25zLiBUaGUgc3VwcGx5IGZ1bm5lbCBhdCBSb3ZlciB3YXMgbW9kZWxlZCBhcyBhIE1hcmtvdiBDaGFpbiwgYWxsb3dpbmcgdXMgdG8gYWNjdXJhdGVseSBmb3JlY2FzdCB0aGUgYW1vdW50IG9mIHN1cHBseSBpbiBhIG1hcmtldCB0byB0YWNrbGUgdGhlIGZvcmVjYXN0ZWQgZGVtYW5kLiJ9LCB7ImlkIjogImxlYXJuX3RvX3JhbmsiLCAibGFiZWwiOiAiTGVhcm4gdG8gUmFuayIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiA3LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyNH0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAiZXhwZXJpZW5jZUxldmVsIjogImludGVyZXN0ZWQiLCAicGFyZW50X25vZGUiOiBbInJlY29tbWVuZGF0aW9uX3N5c3RlbXMiLCAicHl0aG9uIiwgImNsYXNzaWZpY2F0aW9uIl0sICJkZXNjcmlwdGlvbiI6ICJNYWNoaW5lIGxlYXJuaW5nIHRlY2huaXF1ZXMgZm9yIG9yZGVyaW5nIGFuZCByYW5raW5nIGl0ZW1zIGluIHJlY29tbWVuZGF0aW9uIHN5c3RlbXMuIEkgbGVhcm50IGFib3V0IHRoaXMgZHVyaW5nIG15IGxhc3QgZmV3IG1vbnRocyBhdCBSb3ZlciwgYW5kIHdvdWxkIGxvdmUgdG8gYmUgYWJsZSB0byB3b3JrIG9uIHRoaXMgaW4gbW9yZSBkZXB0aCBpbiB0aGUgZnV0dXJlLiJ9LCB7ImlkIjogImFnZW50X2Jhc2VkX21vZGVsbGluZyIsICJsYWJlbCI6ICJBZ2VudCBCYXNlZCBNb2RlbGxpbmciLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIzfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYm90dG9tX3VwX2FwcHJvYWNoIiwgInB5dGhvbiIsICJlcGlkZW1pY19zaW11bGF0aW9uIiwgImRlY2lzaW9uX21ha2luZ19hZ2VudHMiXSwgImRlc2NyaXB0aW9uIjogIlNpbXVsYXRpbmcgY29tcGxleCBzeXN0ZW1zIGJ5IG1vZGVsaW5nIGluZGl2aWR1YWwgYWdlbnRzIGFuZCB0aGVpciBpbnRlcmFjdGlvbnMuIn0sIHsiaWQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJsYWJlbCI6ICJFeHBlcmltZW50YWwgRGVzaWduIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDE1LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJzdGF0aXN0aWNzIiwgImJheWVzaWFuX3N0YXRpc3RpY3MiLCAibWFya2V0cGxhY2VfaW5mbGF0aW9uX3JlY3MiXSwgImRlc2NyaXB0aW9uIjogIlN0YXRpc3RpY2FsIHByaW5jaXBsZXMgZm9yIGRlc2lnbmluZyB2YWxpZCBleHBlcmltZW50cyBhbmQgY29udHJvbGxpbmcgZm9yIGNvbmZvdW5kaW5nIGZhY3RvcnMuIFNvbWV0aW1lcyB0aGUgZXhwZXJpbWVudGFsIGRlc2lnbiBpbiB0ZWNoIHByb2R1Y3RzIGNhbiBiZSBzdHJhaWdodGZvcndhcmQgd2hlcmUgeW91IHNpbXBseSByYW5kb21pemUgdXNlcnMgaW50byB0cmVhdG1lbnQgYW5kIGNvbnRyb2wgZ3JvdXBzLCBidXQgb2Z0ZW4gdGhlcmUgYXJlIGNvbXBsaWNhdGlvbnMgbGlrZSBpbnRlcmZlcmVuY2UgYmV0d2VlbiB1c2VycywgYW5kL29yIGZlZWRiYWNrIGxvb3BzIGluIHBsYXkgdGhhdCBuZWVkIHRvIGJlIGFjY291bnRlZCBmb3IgaW4gdGhlIGRlc2lnbmluZyBvZiB0aGUgZXhwZXJpbWVudC4gSSBoYXZlIGV4cGVyaWVuY2UgZGVhbGluZyB3aXRoIHRoZXNlIGNvbXBsZXhpdGllcyBpbiByZWFsLXdvcmxkIEEvQiB0ZXN0cy4ifSwgeyJpZCI6ICJleHBlcmltZW50YXRpb24iLCAibGFiZWwiOiAiRXhwZXJpbWVudGF0aW9uIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDE0LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJleHBlcmltZW50YWxfZGVzaWduIiwgInN0YXRpc3RpY3MiLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJBL0IgdGVzdGluZyBhbmQgY2F1c2FsIGluZmVyZW5jZSBpbiBwcm9kdWN0IGNoYW5nZXMgYXMgd2VsbCBhcyBhbGdvcml0aG0gY2hhbmdlcyBmb3IgbWVhc3VyaW5nIHByb2R1Y3QgaW1wYWN0IGFuZCBtYWtpbmcgZGF0YS1kcml2ZW4gZGVjaXNpb25zLiJ9LCB7ImlkIjogImJheWVzaWFuX3N0YXRpc3RpY3MiLCAibGFiZWwiOiAiQmF5ZXNpYW4gU3RhdGlzdGljcyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxMSwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJzdGF0aXN0aWNzIiwgImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAibHR2X21vZGVsaW5nIl0sICJkZXNjcmlwdGlvbiI6ICJQcm9iYWJpbGlzdGljIGFwcHJvYWNoIHRvIGluZmVyZW5jZSB0aGF0IGluY29ycG9yYXRlcyBwcmlvciBrbm93bGVkZ2UgYW5kIHVwZGF0ZXMgYmVsaWVmcyB3aXRoIGV2aWRlbmNlLiJ9LCB7ImlkIjogImxhdGV4IiwgImxhYmVsIjogIkxhVGVYIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDUsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDExfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImJpdHNfZWR1Y2F0aW9uIiwgInF1YW50dW1fZm91bmRhdGlvbnMiLCAicHVibGljYXRpb25zIiwgImNvbmZlcmVuY2VzIl0sICJkZXNjcmlwdGlvbiI6ICJEb2N1bWVudCBwcmVwYXJhdGlvbiBzeXN0ZW0gZm9yIGFjYWRlbWljIHdyaXRpbmcgYW5kIG1hdGhlbWF0aWNhbCB0eXBlc2V0dGluZy4ifSwgeyJpZCI6ICJtYXRoZW1hdGljYSIsICJsYWJlbCI6ICJNYXRoZW1hdGljYSIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiA2LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMn0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJiaXRzX2VkdWNhdGlvbiIsICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJjb21wbGV4X2FuYWx5c2lzIl0sICJkZXNjcmlwdGlvbiI6ICJDb21wdXRhdGlvbmFsIHNvZnR3YXJlIGZvciBzeW1ib2xpYyBtYXRoZW1hdGljcyBhbmQgbnVtZXJpY2FsIGFuYWx5c2lzLiJ9LCB7ImlkIjogInB5dGhvbiIsICJsYWJlbCI6ICJQeXRob24iLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTEsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE1fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInVvZmFfZWR1Y2F0aW9uIiwgImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAicm92ZXJfZXhwZXJpZW5jZSIsICJsaW5lYXJfYWxnZWJyYSJdLCAiZGVzY3JpcHRpb24iOiAiUHJpbWFyeSBwcm9ncmFtbWluZyBsYW5ndWFnZSBmb3IgZGF0YSBzY2llbmNlLCBtYWNoaW5lIGxlYXJuaW5nLCBhbmQgc2NpZW50aWZpYyBjb21wdXRpbmcuIn0sIHsiaWQiOiAic3FsIiwgImxhYmVsIjogIlNRTCIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxMSwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJyb3Zlcl9leHBlcmllbmNlIiwgImRhdGFfZW5naW5lZXJpbmciXSwgImRlc2NyaXB0aW9uIjogIkRhdGFiYXNlIHF1ZXJ5IGxhbmd1YWdlIGVzc2VudGlhbCBmb3IgZGF0YSBleHRyYWN0aW9uIGFuZCBtYW5pcHVsYXRpb24uIEkgdXNlZCBTUUwgZXh0ZW5zaXZlbHkgaW4gbXkgcm9sZXMgYXQgUm92ZXIgYW5kIFR1cm5vIGZvciBxdWVyeWluZyBsYXJnZSBkYXRhc2V0cywgYnVpbGRpbmcgRVRMIHBpcGVsaW5lcywgYW5kIHBlcmZvcm1pbmcgZGF0YSBhbmFseXNpcyB0byBpbmZvcm0gYnVzaW5lc3MgZGVjaXNpb25zLiJ9LCB7ImlkIjogImdpdCIsICJsYWJlbCI6ICJHaXQiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE4fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInVvZmFfZWR1Y2F0aW9uIiwgInB5dGhvbiIsICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIl0sICJkZXNjcmlwdGlvbiI6ICJWZXJzaW9uIGNvbnRyb2wgc3lzdGVtIGZvciBjb2xsYWJvcmF0aXZlIHNvZnR3YXJlIGRldmVsb3BtZW50IGFuZCBjb2RlIG1hbmFnZW1lbnQuIEkndmUgdXNlZCBHaXQgZXh0ZW5zaXZlbHkgdGhyb3VnaG91dCBteSByZXNlYXJjaCBhbmQgZGF0YSBzY2llbmNlIHByb2plY3RzIHRvIG1hbmFnZSBjb2RlIHZlcnNpb25zLCBjb2xsYWJvcmF0ZSB3aXRoIG90aGVycywgYW5kIG1haW50YWluIHJlcHJvZHVjaWJpbGl0eS4ifSwgeyJpZCI6ICJhd3NfZ2NwIiwgImxhYmVsIjogIkFXUy9HQ1AiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTEsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJweXRob24iLCAiZGF0YV9lbmdpbmVlcmluZyJdLCAiZGVzY3JpcHRpb24iOiAiQ2xvdWQgY29tcHV0aW5nIHBsYXRmb3JtcyBmb3Igc2NhbGFibGUgZGF0YSBwcm9jZXNzaW5nIGFuZCBtYWNoaW5lIGxlYXJuaW5nIGRlcGxveW1lbnQuIEkgdXNlZCBBV1MgYXQgUm92ZXIgYW5kIEdDUCBhdCBUdXJubywgZm9yIHZhcmlvdXMgdXNlIGNhc2VzIGluIHRoZSBEYXRhIFNjaWVuY2Ugd29ya2Zsb3dzLiJ9LCB7ImlkIjogImRhZ3N0ZXJfYWlyZmxvdyIsICJsYWJlbCI6ICJEYWdzdGVyL0FpcmZsb3ciLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJweXRob24iLCAiZGF0YV9lbmdpbmVlcmluZyJdLCAiZGVzY3JpcHRpb24iOiAiV29ya2Zsb3cgb3JjaGVzdHJhdGlvbiB0b29scyBmb3IgbWFuYWdpbmcgY29tcGxleCBkYXRhIHBpcGVsaW5lcyBhbmQgRVRMIHByb2Nlc3Nlcy4gSSd2ZSB1c2VkIERhZ3N0ZXIgZXh0ZW5zaXZlbHkgYXQgVHVybm8gdG8gYnVpbGQgYW5kIG1haW50YWluIGRhdGEgcGlwZWxpbmVzIHRoYXQgcmVxdWlyZSBib3RoIFNRTC1saWtlLCBweXRob24gYmFzZWQgcHJvY2Vzc2luZyBhbmQgZW5kIHVwIGluIE1MIG1vZGVscyB0aGF0IGFyZSBkZXBsb3llZCB0byBwcm9kdWN0aW9uLiJ9LCB7ImlkIjogImRidCIsICJsYWJlbCI6ICJEQlQiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTMsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJzcWwiLCAiZGF0YV9lbmdpbmVlcmluZyJdLCAiZGVzY3JpcHRpb24iOiAiRGF0YSB0cmFuc2Zvcm1hdGlvbiB0b29sIGZvciBidWlsZGluZyByZWxpYWJsZSBkYXRhIG1vZGVscyBhbmQgYW5hbHl0aWNzIHdvcmtmbG93cy4gTXkgZXhwZXJpZW5jZSB3aXRoIERCVCBpcyBleHRlbnNpdmUsIGhhdmluZyB1c2VkIGl0IGF0IGJvdGggUm92ZXIgYW5kIFR1cm5vIHRvIGNyZWF0ZSBtb2R1bGFyLCB0ZXN0YWJsZSBkYXRhIHRyYW5zZm9ybWF0aW9ucyB0aGF0IGZvcm0gdGhlIGJhY2tib25lIG9mIG91ciBhbmFseXRpY3MgYW5kIG1hY2hpbmUgbGVhcm5pbmcgcGlwZWxpbmVzLiJ9LCB7ImlkIjogInRhYmxlYXVfbW9kZSIsICJsYWJlbCI6ICJUYWJsZWF1L01vZGUvUGVyaXNjb3BlIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDcsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJ0dXJub19leHBlcmllbmNlIiwgInNxbCIsICJzdGF0aXN0aWNzIl0sICJkZXNjcmlwdGlvbiI6ICJCdXNpbmVzcyBpbnRlbGxpZ2VuY2UgYW5kIGRhdGEgdmlzdWFsaXphdGlvbiBwbGF0Zm9ybXMgZm9yIGNyZWF0aW5nIGRhc2hib2FyZHMgYW5kIHJlcG9ydHMuIEkgdXNlZCBQZXJpc2NvcGUgYW5kIE1vZGUgYXQgUm92ZXIsIGFuZCBUYWJsZWF1IGF0IFR1cm5vIHRvIGJ1aWxkIGludGVyYWN0aXZlIGRhc2hib2FyZHMgdGhhdCBwcm92aWRlZCBpbnNpZ2h0cyBpbnRvIGtleSBidXNpbmVzcyBtZXRyaWNzIGFuZCBzdXBwb3J0ZWQgZGF0YS1kcml2ZW4gZGVjaXNpb24tbWFraW5nIGFjcm9zcyB0ZWFtcy4ifSwgeyJpZCI6ICJpc2FpX3Byb2plY3QiLCAibGFiZWwiOiAiSXNBSSIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMSwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIiwgInB5dGhvbiIsICJjbGFzc2lmaWNhdGlvbiIsICJmb3VyaWVyX2xhcGxhY2UiLCAiY2x1c3RlcmluZ19hbGdvcml0aG1zIl0sICJkZXNjcmlwdGlvbiI6ICJBcyBhIGNhcm5hdGljIG11c2ljIGVudGh1c2lhc3QsIEkgd2FudGVkIHRvIGJ1aWxkIGEgbW9kZWwgdGhhdCBjYW4gaWRlbnRpZnkgdGhlIFJhZ2FtIG9mIGFueSBnaXZlbiBjbGlwIG9mIG11c2ljLiBJIGJ1aWx0IElzQUksIGEgTWFjaGluZSBsZWFybmluZyBwcm9qZWN0IGZvciBpZGVudGlmeWluZyBTb3V0aCBJbmRpYW4gY2xhc3NpY2FsIG11c2ljIHJhZ2FtcyBmcm9tIGF1ZGlvLCBhY2hpZXZpbmcgNzUlIGFjY3VyYWN5IHVzaW5nIFJOTnMgYW5kIExTVE1zLiJ9LCB7ImlkIjogImVwaWRlbWljX3NpbXVsYXRpb24iLCAibGFiZWwiOiAiU2ltdWxhdGluZyBhbiBFcGlkZW1pYyIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMSwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAicHl0aG9uIiwgImJvdHRvbV91cF9hcHByb2FjaCJdLCAiZGVzY3JpcHRpb24iOiAiTXkgZmlyc3QgQWdlbnQtYmFzZWQgbW9kZWxpbmcgcHJvamVjdCwgd2hlcmUgSSBzaW11bGF0ZWQgZGlzZWFzZSBzcHJlYWQgZHluYW1pY3MgZHVyaW5nIHRoZSBDT1ZJRC0xOSBwYW5kZW1pYy4gVGhpcyB3YXMgbXkgZmlyc3QgT2JqZWN0IE9yaWVudGVkIFByb2dyYW1taW5nIGV4ZXJjaXNlIGFzIHdlbGwuIn0sIHsiaWQiOiAic3VwcGx5X2RlbWFuZF9mb3JlY2FzdCIsICJsYWJlbCI6ICJNYXJrZXQgU3VwcGx5LURlbWFuZCBCYWxhbmNlIEZvcmVjYXN0IiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDEyLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMiwgImVuZCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJtYXJrb3ZfY2hhaW5fbW9kZWxzIiwgImdlb3NwYXRpYWxfYW5hbHlzaXMiXSwgImRlc2NyaXB0aW9uIjogIkFzIGEgbWFya2V0cGxhY2UgdGhhdCByZXF1aXJlcyBzdXBwbHkgYW5kIGRlbWFuZCB0byBiZSBpbiBwcm94aW1pdHkgb2Ygb25lIGFub3RoZXIgYXQgUm92ZXIsIG1hbmFnaW5nIHRoZSBzdXBwbHktZGVtYW5kIGJhbGFuY2UgYWNyb3NzIHRoZSBtYXJrZXRwbGFjZSByZXF1aXJlZCBicmVha2luZyBpdCBkb3duIGludG8gbWFuYWdlYWJsZSBtYXJrZXRzLiBBIHdheSBvZiBkb2luZyB0aGlzIHdhcyB0byB1c2UgaW5kZXBlbmRlbnQgbWFya2V0IHN1cHBseSBmb3JlY2FzdCAoVGltZSBzZXJpZXMgRm9yZWNhc3RzICsgTWFya292IENoYWluIE1vZGVscykgYW5kIG1hcmtldCBkZW1hbmQgZm9yZWNhc3QgKFRpbWUgc2VyaWVzIEZvcmVjYXN0cykgbW9kZWxzIHRoYXQgY29tZSB0b2dldGhlciB0byByZXBvcnQgbWFya2V0IGhlYWx0aC4gSSBidWlsdCBhbmQgbWFpbnRhaW5lZCB0aGVzZSBtb2RlbHMgRm9yZWNhc3RpbmcgbW9kZWxzIHRvIHJlY29tbWVuZCBhY3Rpb25zIHRvIGhlbHAgb3B0aW1pemUgbWFya2V0cGxhY2UgYmFsYW5jZSBhY3Jvc3MgZ2xvYmFsIG1hcmtldHMuIn0sIHsiaWQiOiAiZGF0YV9lbmdpbmVlcmluZyIsICJsYWJlbCI6ICJEYXRhIEVuZ2luZWVyaW5nIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDExLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMn0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAicHl0aG9uIiwgInNxbCIsICJhd3NfZ2NwIiwgImRhZ3N0ZXJfYWlyZmxvdyIsICJkYnQiXSwgImRlc2NyaXB0aW9uIjogIkVUTCBwaXBlbGluZSBkZXZlbG9wbWVudCBhbmQgZGF0YSBpbmZyYXN0cnVjdHVyZSBmb3IgYm90aCByZWFsLXRpbWUgYW5hbHl0aWNzIGFuZCByZXBvcnRpbmcgc3lzdGVtcy4gSSBhbHNvIGxlZCB0aGUgZGF0YSBzY2llbmNlIHRlYW0gaW4gYSBjcm9zcy1mdW5jdGlvbmFsIGVmZm9ydCBpbiBwcm92aWRpbmcgcmVhbC10aW1lIGluc2lnaHRzIHRvIHVzZXJzIG9uIHRoZSBSb3ZlciBwbGF0Zm9ybS4ifSwgeyJpZCI6ICJtYXJrZXRwbGFjZV9pbmZsYXRpb25fcmVjcyIsICJsYWJlbCI6ICJNYXJrZXRwbGFjZSBJbmZsYXRpb24gJiBSZWNvbW1lbmRhdGlvbiBTeXN0ZW1zIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDEzLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMiwgImVuZCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAiZ2FtZV90aGVvcnkiLCAicHJpY2luZ19lbGFzdGljaXR5Il0sICJkZXNjcmlwdGlvbiI6ICJEZXNpZ25lZCBhbiBleHBlcmltZW50IHRvIG1lYXN1cmUgdGhlIGltcGFjdCBvZiByZWNvbW1lbmRhdGlvbiBzeXN0ZW1zIHRoYXQgZGlmZmVyZW50aWFsbHkgcHJpY2VkIHNlcnZpY2UgcHJvdmlkZXJzIG9uIGxvbmctdGVybSBtYXJrZXRwbGFjZSBpbmZsYXRpb24uIEdpdmVuIHRoZSBuYXR1cmUgb2YgaW50ZXJhY3Rpb24gYmV0d2VlbiB2YXJpb3VzIHVzZXJzLCBJIGRlc2lnbmVkIGEgZnJhbWV3b3JrIHRvIHNwbGl0IHVzZXJzIGJhc2VkIG9uIHRoZWlyIGdlb2dyYXBoeSwgYW5kIHN0dWR5IHRoZSBpbXBhY3Qgb2YgcmVjb21tZW5kYXRpb25zIG9uIG1hcmtldHBsYWNlIGluZmxhdGlvbi4ifSwgeyJpZCI6ICJnZW9fc3BsaXRfZXhwZXJpbWVudGF0aW9uIiwgImxhYmVsIjogIkdlbyBTcGxpdCBFeHBlcmltZW50YXRpb24gRnJhbWV3b3JrIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDEwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMywgImVuZCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJleHBlcmltZW50YWxfZGVzaWduIiwgInN0YXRpc3RpY3MiLCAiZ2Vvc3BhdGlhbF9hbmFseXNpcyJdLCAiZGVzY3JpcHRpb24iOiAiSSBoZWxwZWQgY3JlYXRlIHRoZSBmcmFtZXdvcmsgZm9yIGRlc2lnbmluZyBhbmQgYW5hbHl6aW5nIGdlby1zcGxpdCBleHBlcmltZW50cyBhdCBSb3Zlciwgd2hpY2ggYXJlIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIG1hcmtldHBsYWNlIGV4cGVyaW1lbnRzIHdoZXJlIGludGVyZmVyZW5jZSBiZXR3ZWVuIHVzZXJzIGNhbiBiaWFzIHJlc3VsdHMuIn0sIHsiaWQiOiAiZmluYW5jaWFsX21vZGVsbGluZyIsICJsYWJlbCI6ICJGaW5hbmNpYWwgTW9kZWxsaW5nIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDcsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJzdGF0aXN0aWNzIiwgInJlZ3Jlc3Npb24iLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJRdWFudGl0YXRpdmUgbW9kZWxzIGZvciBidXNpbmVzcyBzdHJhdGVneSwgcHJpY2luZyBvcHRpbWl6YXRpb24sIGFuZCByZXZlbnVlIGZvcmVjYXN0aW5nLiBJIHdhcyBpbnZvbHZlZCBpbiBzdHJhdGVnaWMgZmluYW5jaWFsIHBsYW5uaW5nIGF0IGJvdGggUm92ZXIgYW5kIFR1cm5vLCBidWlsZGluZyBtb2RlbHMgdG8gZm9yZWNhc3QgcmV2ZW51ZSwgb3B0aW1pemUgcHJpY2luZyBzdHJhdGVnaWVzLCBhbmQgZXZhbHVhdGUgdGhlIGZpbmFuY2lhbCBpbXBhY3Qgb2YgdmFyaW91cyBidXNpbmVzcyBpbml0aWF0aXZlcy4ifSwgeyJpZCI6ICJnZW9zcGF0aWFsX2FuYWx5c2lzIiwgImxhYmVsIjogIkdlb3NwYXRpYWwgRGF0YSBBbmFseXNpcyIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJ0dXJub19leHBlcmllbmNlIiwgInB5dGhvbiIsICJjbHVzdGVyaW5nX2FsZ29yaXRobXMiXSwgImRlc2NyaXB0aW9uIjogIkxvY2F0aW9uLWJhc2VkIGFuYWx5dGljcyBmb3IgbWFya2V0IGV4cGFuc2lvbiBhbmQgc3VwcGx5LWRlbWFuZCBvcHRpbWl6YXRpb24uIEkgYnVpbHQgZ2Vvc3BhdGlhbCBkYXRhIHBpcGVsaW5lcyBhbmQgYW5hbHlzaXMgZnJhbWV3b3JrcyB0byB1bmRlcnN0YW5kIG1hcmtldCBkeW5hbWljcyBhbmQgb3B0aW1pemUgc3VwcGx5IGRpc3RyaWJ1dGlvbiBhY3Jvc3MgZGlmZmVyZW50IHJlZ2lvbnMsIGF0IGJvdGggUm92ZXIgYW5kIFR1cm5vLiJ9LCB7ImlkIjogInByaWNpbmdfZWxhc3RpY2l0eSIsICJsYWJlbCI6ICJQcmljaW5nLCBQcmljZSBFbGFzdGljaXR5IiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDEyLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMn0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJ0dXJub19leHBlcmllbmNlIiwgImdhbWVfdGhlb3J5IiwgImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAicmVncmVzc2lvbiJdLCAiZGVzY3JpcHRpb24iOiAiRWNvbm9taWMgbW9kZWxpbmcgb2YgcHJpY2Ugc2Vuc2l0aXZpdHkgYW5kIGRlbWFuZCByZXNwb25zZSBpbiBtYXJrZXRwbGFjZSBlbnZpcm9ubWVudHMuIEF0IFJvdmVyLCBJIGluc3RydW1lbnRlZCBhIGNvdXBsZSBvZiBleHBlcmltZW50cyByZWxhdGVkIHRvIHByaWNpbmcgYW5kIHByaWNlIGVsYXN0aWNpdHksIGFuZCBhdCBUdXJubywgbWFkZSByZWNvbW1lbmRhdGlvbnMgZm9yIGhvdyB0byBkZXNpZ24gcHJpY2luZyBleHBlcmltZW50cyJ9LCB7ImlkIjogInRhbV9hbmFseXNpcyIsICJsYWJlbCI6ICJUQU0iLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogNiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsidHVybm9fZXhwZXJpZW5jZSIsICJzdGF0aXN0aWNzIiwgImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJUb3RhbCBBZGRyZXNzYWJsZSBNYXJrZXQgYW5hbHlzaXMgZm9yIHN0cmF0ZWdpYyBleHBhbnNpb24gYW5kIG1hcmtldCBvcHBvcnR1bml0eSBhc3Nlc3NtZW50LiBBdCBUdXJubywgdXNpbmcgYSBjb21iaW5hdGlvbiBvZiBwdWJsaWMgZGF0YXNldHMsIGFuZCBtb2RlbGxpbmcsIEkgZXN0aW1hdGVkIHRoZSBUQU0gZm9yIFR1cm5vIGJ5IGxvY2FsIHJlZ2lvbiBpbiBhIGZldyBjb3VudHJpZXMuIn0sIHsiaWQiOiAibHR2X21vZGVsaW5nIiwgImxhYmVsIjogIkxUViIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiA3LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyNH0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJ0dXJub19leHBlcmllbmNlIiwgInJlZ3Jlc3Npb24iLCAidGltZV9zZXJpZXNfZm9yZWNhc3RpbmciLCAiYmF5ZXNpYW5fc3RhdGlzdGljcyJdLCAiZGVzY3JpcHRpb24iOiAiQ3VzdG9tZXIgTGlmZXRpbWUgVmFsdWUgcHJlZGljdGlvbiBtb2RlbHMgZm9yIG9wdGltaXppbmcgYWNxdWlzaXRpb24gY29zdHMgYW5kIG1hcmtldGluZyBzcGVuZC4gSSBidWlsdCBvdXQgZnJvbSBzY3JhdGNoIGEgZnJhbWV3b3JrIGZvciB1bmRlcnN0YW5kaW5nIHRoZSBMaWZldGltZSBWYWx1ZSBvZiBhIGN1c3RvbWVyIGF0IFR1cm5vLCB3aGljaCB0aGVuIGhlbHBlZCBpbmZvcm0gbWFya2V0aW5nIHNwZW5kIGRlY2lzaW9ucy4ifSwgeyJpZCI6ICJsbG1zX3Byb2R1Y3QiLCAibGFiZWwiOiAiTGFyZ2UgTGFuZ3VhZ2UgTW9kZWxzIGluIFByb2R1Y3QiLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImxhcmdlX2xhbmd1YWdlX21vZGVscyIsICJyb3Zlcl9leHBlcmllbmNlIiwgInR1cm5vX2V4cGVyaWVuY2UiLCAicHl0aG9uIiwgInNlbWFudGljX3NlYXJjaCJdLCAiZGVzY3JpcHRpb24iOiAiSSd2ZSB1c2VkIHRvb2xzIGxpa2UgTGFuZ2NoYWluIHRvIGJ1aWxkIGludGVybmFsIHRvb2xzIHRoYXQgZmVlZCBpbnRvLCBhbmQgb3B0aW1pemUgYnVzaW5lc3MgcHJvY2Vzc2VzIHRoYXQgaW52b2x2ZSBhIGxvdCBvZiBodW1hbiBqdWRnZW1lbnQgYXQgYm90aCBSb3ZlciBhbmQgVHVybm8uIFRoaXMgaGFzIHJlcXVpcmVkIGNyZWF0aW5nIHN0cnVjdHVyZWQgUkFHIHBpcGVsaW5lcyB0aGF0IGNvbWJpbmUgdGV4dCBhbG9uZyB3aXRoIHN0cnVjdHVyZWQgZGF0YSB0byBvYnRhaW4gc3RydWN0dXJlZCBvdXRwdXQuIn0sIHsiaWQiOiAibWxfcHJvZHVjdGlvbiIsICJsYWJlbCI6ICJNTCBpbiBQcm9kdWN0aW9uIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDEyLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJweXRob24iLCAiYXdzX2djcCIsICJkYWdzdGVyX2FpcmZsb3ciLCAiZXhwZXJpbWVudGFsX2Rlc2lnbiJdLCAiZGVzY3JpcHRpb24iOiAiRW5kLXRvLWVuZCBtYWNoaW5lIGxlYXJuaW5nIGlkZWF0aW9uLCBmZWF0dXJlIGVuZ2luZWVyaW5nLCB0cmFpbmluZywgZGVwbG95bWVudCwgbW9uaXRvcmluZywgdGVzdGluZywgYW5kIG1haW50ZW5hbmNlIGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLiBJJ3ZlIGJlZW4gaW52b2x2ZWQgaW4gdGhpcyBhdCBib3RoIFJvdmVyIGFuZCBUdXJubywgd2hlcmUgSSBidWlsdCBhbmQgZGVwbG95ZWQgTUwgbW9kZWxzIHRvIHByb2R1Y3Rpb24sIHNldCB1cCBtb25pdG9yaW5nIHN5c3RlbXMgdG8gdHJhY2sgbW9kZWwgcGVyZm9ybWFuY2UsIGFuZCBpbXBsZW1lbnRlZCBwcm9jZXNzZXMgZm9yIHJlZ3VsYXIgbW9kZWwgcmV0cmFpbmluZyBhbmQgdXBkYXRlcy4ifSwgeyJpZCI6ICJyZWluZm9yY2VtZW50X2xlYXJuaW5nIiwgImxhYmVsIjogIlJlaW5mb3JjZW1lbnQgTGVhcm5pbmciLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsic3RhbmZvcmRfYWlfY2VydCIsICJib3R0b21fdXBfYXBwcm9hY2giLCAiZ2FtZV90aGVvcnkiLCAiZGVjaXNpb25fbWFraW5nX2FnZW50cyJdLCAiZGVzY3JpcHRpb24iOiAiTXkgZmFzY2luYXRpb24gZm9yIHVuZGVyc3RhbmRpbmcgb3B0aW1hbCBkZWNpc2lvbiBtYWtpbmcgYnkgYWdlbnRzIHVuZGVyIHVuY2VydGFpbnR5IGlzIHdoYXQgYnJpbmdzIG1lIHRvIFJlaW5mb3JjZW1lbnQgTGVhcm5pbmcuIEkgZmluZCB0aGlzIHRvIGJlIHNvbWV3aGF0IG1pZC13YXkgYmV0d2VlbiB0aGUgYm90dG9tLXVwIGFwcHJvYWNoIChmcm9tIG15IHBoeXNpY3MgZGF5cykgdG8gdGhlIHRvcC1kb3duIGFwcHJvYWNoIChmcm9tIG15IHRpbWUgYXMgYSBkYXRhIHNjaWVudGlzdCkgdG8gbGVhcm4gYWJvdXQgZW1lcmdlbnQgYmVoYXZpb3Igd2l0aCBwcmFjdGljYWwgYXBwbGljYXRpb25zIGluIGdhbWUgdGhlb3J5IGFuZCBtYXJrZXRwbGFjZSBkeW5hbWljcy4ifSwgeyJpZCI6ICJkZWNpc2lvbl9tYWtpbmdfYWdlbnRzIiwgImxhYmVsIjogIkRlY2lzaW9uIE1ha2luZyBpbiBBZ2VudHMiLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTQsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIzfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZ2FtZV90aGVvcnkiLCAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAiYm90dG9tX3VwX2FwcHJvYWNoIl0sICJkZXNjcmlwdGlvbiI6ICJJJ20gaW50cmlndWVkIGJ5IHRoZSBwYXJhbGxlbHMgYmV0d2VlbiBteSBib3R0b20tdXAgcGh5c2ljcyBhcHByb2FjaCBhbmQgaG93IGluZGl2aWR1YWwgcmF0aW9uYWwgYWdlbnRzIG1ha2UgZGVjaXNpb25zIHRoYXQgbGVhZCB0byBjb21wbGV4IGVtZXJnZW50IG1hcmtldCBiZWhhdmlvcnMuIn0sIHsiaWQiOiAiYXVjdGlvbnNfZGVzaWduIiwgImxhYmVsIjogIkF1Y3Rpb25zICYgQXVjdGlvbiBEZXNpZ24iLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIzfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZ2FtZV90aGVvcnkiLCAiZGVjaXNpb25fbWFraW5nX2FnZW50cyIsICJtYXJrZXRwbGFjZXMiLCAicHJpY2luZ19lbGFzdGljaXR5Il0sICJkZXNjcmlwdGlvbiI6ICJJJ20gZHJhd24gdG8gdGhlIG1hdGhlbWF0aWNhbCBlbGVnYW5jZSBvZiBtZWNoYW5pc20gZGVzaWduIGFuZCBpdHMgcHJhY3RpY2FsIGFwcGxpY2F0aW9ucyBpbiBvcHRpbWl6aW5nIG1hcmtldHBsYWNlIG91dGNvbWVzIC0gYSBwZXJmZWN0IGJsZW5kIG9mIGdhbWUgdGhlb3J5IGFuZCByZWFsLXdvcmxkIGltcGFjdC4ifSwgeyJpZCI6ICJzdGFuZm9yZF9haV9jZXJ0IiwgImxhYmVsIjogIlN0YW5mb3JkIEFJIENlcnRpZmljYXRlIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDE0LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyNH0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJ2YW5jb3V2ZXIiLCAibGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzIiwgInJlaW5mb3JjZW1lbnRfbGVhcm5pbmciLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJJJ20gcHVyc3VpbmcgdGhpcyB0byBkZWVwZW4gbXkgdW5kZXJzdGFuZGluZyBvZiBjdXR0aW5nLWVkZ2UgQUkgdGVjaG5pcXVlcyBhbmQgbWFpbnRhaW4gY29ubmVjdGlvbiB0byBhY2FkZW1pYyByaWdvciB3aGlsZSBhcHBseWluZyBNTCBpbiBpbmR1c3RyeSBzZXR0aW5ncy4gSSdtIG9wZW4gdG8gd2hlcmUgdGhpcyB0YWtlcyBtZSBpbiB0aGUgZnV0dXJlLiJ9LCB7ImlkIjogImxhcmdlX2xhbmd1YWdlX21vZGVscyIsICJsYWJlbCI6ICJMYXJnZSBMYW5ndWFnZSBNb2RlbHMiLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTMsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIzfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJzdGFuZm9yZF9haV9jZXJ0IiwgInB5dGhvbiIsICJzZW1hbnRpY19zZWFyY2giLCAibGxtc19wcm9kdWN0Il0sICJkZXNjcmlwdGlvbiI6ICJFeGNpdGVkIGJ5IHRoZWlyIHBvdGVudGlhbCB0byB0cmFuc2Zvcm0gaG93IHdlIGludGVyYWN0IHdpdGggZGF0YSBhbmQgYXV0b21hdGUgY29tcGxleCByZWFzb25pbmcgdGFza3MsIGhhdmluZyBzZWVuIHRoZWlyIHByYWN0aWNhbCBpbXBhY3QgaW4gcHJvZHVjdGlvbiBzeXN0ZW1zIGF0IFJvdmVyIGFuZCBUdXJuby4gSSdtIGludGVyZXN0ZWQgaW4gYWdlbnRpYyBBSSBhbmQgd291bGQgbG92ZSB0byBleHBsb3JlIGhvdyBtZW1vcnktYXVnbWVudGVkIExMTXMgY2FuIGJlIHVzZWQgdG8gYnVpbGQgbW9yZSBhdXRvbm9tb3VzIHN5c3RlbXMuIn0sIHsiaWQiOiAic2VtYW50aWNfc2VhcmNoIiwgImxhYmVsIjogIlNlbWFudGljIFNlYXJjaCIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiAxMiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJsYXJnZV9sYW5ndWFnZV9tb2RlbHMiLCAiY2x1c3RlcmluZ19hbGdvcml0aG1zIiwgInJlY29tbWVuZGF0aW9uX3N5c3RlbXMiXSwgImRlc2NyaXB0aW9uIjogIkludGVyZXN0ZWQgaW4gaG93IHZlY3RvciBlbWJlZGRpbmdzIGNhcHR1cmUgbWVhbmluZyBhbmQgZW5hYmxlIG1vcmUgaW50ZWxsaWdlbnQgaW5mb3JtYXRpb24gcmV0cmlldmFsLCBicmlkZ2luZyBteSBhcHByZWNpYXRpb24gZm9yIG1hdGhlbWF0aWNhbCByZXByZXNlbnRhdGlvbnMgd2l0aCBwcmFjdGljYWwgc2VhcmNoIGFwcGxpY2F0aW9ucy4ifSwgeyJpZCI6ICJtb2xlY3VsYXJfZHluYW1pY3MiLCAibGFiZWwiOiAiTW9sZWN1bGFyIER5bmFtaWNzIiwgImxheWVyIjogImFwcGxpY2F0aW9ucyIsICJzaXplIjogNywgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZHJ1Z19kaXNjb3ZlcnkiLCAicHl0aG9uIiwgImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJwZXJ0dXJiYXRpb25fdGhlb3J5Il0sICJkZXNjcmlwdGlvbiI6ICJBdHRyYWN0ZWQgdG8gaG93IGNvbXB1dGF0aW9uYWwgcGh5c2ljcyBtZXRob2RzIEkga25vdyBjYW4gYWNjZWxlcmF0ZSBkcnVnIGRpc2NvdmVyeSwgcG90ZW50aWFsbHkgcmVkdWNpbmcgcmVsaWFuY2Ugb24gYW5pbWFsIHRlc3Rpbmcgd2hpbGUgbGV2ZXJhZ2luZyBteSBtYXRoZW1hdGljYWwgcGh5c2ljcyBiYWNrZ3JvdW5kLiJ9LCB7ImlkIjogImRydWdfZGlzY292ZXJ5IiwgImxhYmVsIjogIkRydWcgRGlzY292ZXJ5IiwgImxheWVyIjogImFwcGxpY2F0aW9ucyIsICJzaXplIjogNywgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzIiwgImJpdHNfZWR1Y2F0aW9uIiwgIm1vbGVjdWxhcl9keW5hbWljcyIsICJweXRob24iXSwgImRlc2NyaXB0aW9uIjogIk1vdGl2YXRlZCBieSB0aGUgcG90ZW50aWFsIHRvIGFwcGx5IE1MIHRlY2huaXF1ZXMgdG8gYWNjZWxlcmF0ZSBwaGFybWFjZXV0aWNhbCBkZXZlbG9wbWVudCB3aGlsZSBzdXBwb3J0aW5nIG1vcmUgaHVtYW5lIHJlc2VhcmNoIG1ldGhvZHMsIGNvbWJpbmluZyBteSBwaGFybWFjeSBiYWNrZ3JvdW5kIHdpdGggY3VycmVudCBkYXRhIHNjaWVuY2Ugc2tpbGxzLiJ9LCB7ImlkIjogIm51Y2xlYXJfZnVzaW9uIiwgImxhYmVsIjogIk51Y2xlYXIgRnVzaW9uIiwgImxheWVyIjogImFwcGxpY2F0aW9ucyIsICJzaXplIjogNywgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjB9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJjbGltYXRlX3RlY2giLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5IiwgInBlcnR1cmJhdGlvbl90aGVvcnkiLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJGYXNjaW5hdGVkIGJ5IHRoZSBpbnRlcnNlY3Rpb24gb2YgZnVuZGFtZW50YWwgcGh5c2ljcyBhbmQgY2xpbWF0ZSBzb2x1dGlvbnMsIHdoZXJlIG15IHRoZW9yZXRpY2FsIHBoeXNpY3MgYmFja2dyb3VuZCBjb3VsZCBjb250cmlidXRlIHRvIG9uZSBvZiBodW1hbml0eSdzIG1vc3QgaW1wb3J0YW50IGVuZXJneSBjaGFsbGVuZ2VzLiJ9LCB7ImlkIjogIm9yZ2FuX29uX2NoaXAiLCAibGFiZWwiOiAiT3JnYW4gb24gYSBDaGlwIiwgImxheWVyIjogImFwcGxpY2F0aW9ucyIsICJzaXplIjogNiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTl9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzIiwgImJpdHNfZWR1Y2F0aW9uIiwgInB5dGhvbiJdLCAiZGVzY3JpcHRpb24iOiAiRHJhd24gdG8gdGhpcyB0ZWNobm9sb2d5IGFzIGEgaHVtYW5lIGFsdGVybmF0aXZlIHRvIGFuaW1hbCB0ZXN0aW5nIHRoYXQgYWxpZ25zIHdpdGggbXkgdmVnYW4gdmFsdWVzIHdoaWxlIG9mZmVyaW5nIG9wcG9ydHVuaXRpZXMgdG8gYXBwbHkgZGF0YSBhbmFseXNpcyB0byBiaW9sb2dpY2FsIHN5c3RlbXMuIEF0IHRoaXMgcG9pbnQsIGdpdmVuIG15IHNraWxscywgSSBkb24ndCB5ZXQgc2VlIGhvdyBJIGNvdWxkIGJlIG9mIHZhbHVlIGluIHRoaXMgYXJlYSwgYnV0IEkgd291bGQgbG92ZSB0byBleHBsb3JlIGhvdyBJIGNvdWxkIGNvbnRyaWJ1dGUuIn0sIHsiaWQiOiAiYWx0ZXJuYXRpdmVfcHJvdGVpbnMiLCAibGFiZWwiOiAiQWx0ZXJuYXRpdmUgUHJvdGVpbnMiLCAibGF5ZXIiOiAiYXBwbGljYXRpb25zIiwgInNpemUiOiA2LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsidmVnYW4iLCAiY2xpbWF0ZV90ZWNoIl0sICJkZXNjcmlwdGlvbiI6ICJJbnRlcmVzdGVkIGluIHRoZSBpbnRlcnNlY3Rpb24gb2YgZm9vZCB0ZWNobm9sb2d5IGFuZCBzdXN0YWluYWJpbGl0eSwgc2VlaW5nIHBvdGVudGlhbCBhcHBsaWNhdGlvbnMgZm9yIG9wdGltaXphdGlvbiBhbmQgcHJvY2VzcyBtb2RlbGluZyB0aGF0IGFsaWduIHdpdGggZW52aXJvbm1lbnRhbCBhbmQgZXRoaWNhbCB2YWx1ZXMuIn0sIHsiaWQiOiAibWFya2V0cGxhY2VzIiwgImxhYmVsIjogIk1hcmtldHBsYWNlcyIsICJsYXllciI6ICJhcHBsaWNhdGlvbnMiLCAic2l6ZSI6IDE0LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJ0dXJub19leHBlcmllbmNlIiwgImdhbWVfdGhlb3J5IiwgInJlY29tbWVuZGF0aW9uX3N5c3RlbXMiXSwgImRlc2NyaXB0aW9uIjogIkNhcHRpdmF0ZWQgYnkgdGhlIGNvbXBsZXggZHluYW1pY3Mgb2YgdHdvLXNpZGVkIG1hcmtldHMgYW5kIGhvdyBnYW1lIHRoZW9yeSwgZWNvbm9taWNzLCBhbmQgTUwgY2FuIG9wdGltaXplIG91dGNvbWVzIGZvciBhbGwgcGFydGljaXBhbnRzIC0gbXkgcHJpbWFyeSBhcmVhIG9mIGFwcGxpZWQgZXhwZXJ0aXNlLiJ9LCB7ImlkIjogImdhbWluZyIsICJsYWJlbCI6ICJHYW1pbmciLCAibGF5ZXIiOiAiYXBwbGljYXRpb25zIiwgInNpemUiOiAxMSwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjN9LCAiYXVkaWVuY2UiOiBbImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJlaW5mb3JjZW1lbnRfbGVhcm5pbmciLCAiYWdlbnRfYmFzZWRfbW9kZWxsaW5nIiwgInB5dGhvbiJdLCAiZGVzY3JpcHRpb24iOiAiSW50cmlndWVkIGJ5IGhvdyByZWluZm9yY2VtZW50IGxlYXJuaW5nIGFuZCBhZ2VudC1iYXNlZCBtb2RlbGluZyBjb3VsZCBlbmhhbmNlIGdhbWUgQUkgYW5kIHByb2NlZHVyYWwgY29udGVudCBnZW5lcmF0aW9uLCBhcHBseWluZyB0ZWNobmlxdWVzIEkgdXNlIGluIG1hcmtldHBsYWNlIG9wdGltaXphdGlvbi4ifSwgeyJpZCI6ICJjbGltYXRlX3RlY2giLCAibGFiZWwiOiAiQ2xpbWF0ZSBUZWNoIiwgImxheWVyIjogImFwcGxpY2F0aW9ucyIsICJzaXplIjogNiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjN9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsibnVjbGVhcl9mdXNpb24iLCAiYWx0ZXJuYXRpdmVfcHJvdGVpbnMiLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJNb3RpdmF0ZWQgYnkgdGhlIHVyZ2VudCBuZWVkIHRvIGFwcGx5IHF1YW50aXRhdGl2ZSBtZXRob2RzIHRvIGVudmlyb25tZW50YWwgY2hhbGxlbmdlcywgc2VlaW5nIG9wcG9ydHVuaXRpZXMgdG8gY29udHJpYnV0ZSBteSBhbmFseXRpY2FsIHNraWxscyB0byBtZWFuaW5nZnVsIGNsaW1hdGUgc29sdXRpb25zLiJ9LCB7ImlkIjogImNoZW5uYWkiLCAibGFiZWwiOiAiQ2hlbm5haSIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogOCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDE5OTEsICJlbmQiOiAyMDA5fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogbnVsbCwgImRlc2NyaXB0aW9uIjogIkJpcnRocGxhY2UgaW4gVGFtaWwgTmFkdSwgSW5kaWEsIHdoZXJlIHRoZSBqb3VybmV5IGJlZ2FuLiJ9LCB7ImlkIjogImh5ZGVyYWJhZCIsICJsYWJlbCI6ICJIeWRlcmFiYWQiLCAibGF5ZXIiOiAicGVyc29uYWwiLCAic2l6ZSI6IDEwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAwOSwgImVuZCI6IDIwMTR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImNoZW5uYWkiLCAiYml0c19lZHVjYXRpb24iXSwgImRlc2NyaXB0aW9uIjogIlVuZGVyZ3JhZHVhdGUgVW5pdmVyc2l0eSB5ZWFycyBhdCBCSVRTIFBpbGFuaSwgc3R1ZHlpbmcgcGh5c2ljcyBhbmQgcGhhcm1hY3kgaW4gdGhlIG91dHNraXJ0cyBvZiBIeWRlcmFiYWQuIn0sIHsiaWQiOiAibXVuaWNoIiwgImxhYmVsIjogIk11bmljaCIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDEzLCAiZW5kIjogMjAxNH0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiaHlkZXJhYmFkIiwgImRldGxlZl9kdXJyIiwgImZhc2NpbmF0aW9uX2xlYXJuaW5nIl0sICJkZXNjcmlwdGlvbiI6ICJNYXN0ZXIncyB0aGVzaXMgeWVhciBpbiBHZXJtYW55LCB3b3JraW5nIHdpdGggRGV0bGVmIERcdTAwZmNyciBhbmQgZXhwbG9yaW5nIEV1cm9wZWFuIGFjYWRlbWljIGN1bHR1cmUuIEkgbG92ZSB0aGlzIGNpdHkhIn0sIHsiaWQiOiAidHVjc29uIiwgImxhYmVsIjogIlR1Y3NvbiIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE1LCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsibXVuaWNoIiwgInVvZmFfZWR1Y2F0aW9uIiwgInNhbV9ncmFsbGEiLCAidmVnYW4iXSwgImRlc2NyaXB0aW9uIjogIlBoRCB5ZWFycyBpbiBBcml6b25hIGRlc2VydCwgZGV2ZWxvcGluZyBleHBlcnRpc2UgaW4gYmxhY2sgaG9sZSBwaHlzaWNzIGFuZCBncmF2aXRhdGlvbmFsIHRoZW9yeS4ifSwgeyJpZCI6ICJzZWF0dGxlIiwgImxhYmVsIjogIlNlYXR0bGUiLCAibGF5ZXIiOiAicGVyc29uYWwiLCAic2l6ZSI6IDEzLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMSwgImVuZCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInR1Y3NvbiIsICJyb3Zlcl9leHBlcmllbmNlIiwgImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiXSwgImRlc2NyaXB0aW9uIjogIlRyYW5zaXRpb24gdG8gZGF0YSBzY2llbmNlIGluZHVzdHJ5IGluIHRoZSBQYWNpZmljIE5vcnRod2VzdCwgbGVhcm5pbmcgbWFya2V0cGxhY2UgZHluYW1pY3MgYXQgUm92ZXIuIn0sIHsiaWQiOiAidmFuY291dmVyIiwgImxhYmVsIjogIlZhbmNvdXZlciIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogMTQsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInNlYXR0bGUiLCAidHVybm9fZXhwZXJpZW5jZSIsICJzdGFuZm9yZF9haV9jZXJ0Il0sICJkZXNjcmlwdGlvbiI6ICJDdXJyZW50IGhvbWUgaW4gQ2FuYWRhLCBhcHBseWluZyBNTCBhbmQgZ2FtZSB0aGVvcnkgdG8gcGFya2luZyBtYXJrZXRwbGFjZXMgd2hpbGUgcHVyc3VpbmcgYWR2YW5jZWQgQUkgc3R1ZGllcy4ifSwgeyJpZCI6ICJzY2hudWNraSIsICJsYWJlbCI6ICJTY2hudWNraSIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogMTUsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE4fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJ0dWNzb24iLCAic2VhdHRsZSIsICJ2YW5jb3V2ZXIiXSwgImRlc2NyaXB0aW9uIjogIk15IGJlYXV0aWZ1bCBzb3VsLWRvZyB3aG9zZSBuZWVkIGZvciBvdXRkb29yIGFkdmVudHVyZXMgaW5mbHVlbmNlZCBsaWZlIGRlY2lzaW9ucywgaW5jbHVkaW5nIHRoZSBtb3ZlIHRvIHBldC1mcmllbmRseSBTZWF0dGxlLCBhbmQgbGF0ZXIgVmFuY291dmVyLiJ9LCB7ImlkIjogInZlZ2FuIiwgImxhYmVsIjogIlZlZ2FuIiwgImxheWVyIjogInBlcnNvbmFsIiwgInNpemUiOiAxMiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTV9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInR1Y3NvbiIsICJhbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMiLCAiYWx0ZXJuYXRpdmVfcHJvdGVpbnMiXSwgImRlc2NyaXB0aW9uIjogIkkgYWRvcHRlZCBhIHZlZ2FuIGxpZmVzdHlsZSBpbiAyMDE1LCBkcml2ZW4gYnkgZXRoaWNhbCBjb25zaWRlcmF0aW9ucyByZWdhcmRpbmcgYW5pbWFsIHdlbGZhcmUgd2hlbiBJIGxlYXJudCBhYm91dCBob3cgZGFpcnkgYW5pbWFscyB3ZXJlIHRyZWF0ZWQuIn0sIHsiaWQiOiAiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzIiwgImxhYmVsIjogIkFsdGVybmF0aXZlcyB0byBBbmltYWwgVGVzdGluZyIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInZlZ2FuIiwgImRydWdfZGlzY292ZXJ5IiwgIm9yZ2FuX29uX2NoaXAiXSwgImRlc2NyaXB0aW9uIjogIlBlcnNvbmFsIGludGVyZXN0IGluIGRldmVsb3BpbmcgaHVtYW5lIHJlc2VhcmNoIG1ldGhvZHMsIGNvbm5lY3RpbmcgdG8gb3JnYW4tb24tY2hpcCBhbmQgZHJ1ZyBkaXNjb3ZlcnkgdGVjaG5vbG9naWVzLiJ9XSwgImxpbmtzIjogW3sic291cmNlIjogImJpdHNfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJtYWduZXRpY19tb25vcG9sZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1tYWduZXRpY19tb25vcG9sZXMifSwgeyJzb3VyY2UiOiAiY2FsY3VsdXMiLCAidGFyZ2V0IjogIm1hZ25ldGljX21vbm9wb2xlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNhbGN1bHVzLW1hZ25ldGljX21vbm9wb2xlcyJ9LCB7InNvdXJjZSI6ICJsaW5lYXJfYWxnZWJyYSIsICJ0YXJnZXQiOiAibWFnbmV0aWNfbW9ub3BvbGVzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGluZWFyX2FsZ2VicmEtbWFnbmV0aWNfbW9ub3BvbGVzIn0sIHsic291cmNlIjogImNvbXBsZXhfYW5hbHlzaXMiLCAidGFyZ2V0IjogIm1hZ25ldGljX21vbm9wb2xlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNvbXBsZXhfYW5hbHlzaXMtbWFnbmV0aWNfbW9ub3BvbGVzIn0sIHsic291cmNlIjogImJpdHNfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYml0c19lZHVjYXRpb24tcXVhbnR1bV9mb3VuZGF0aW9ucyJ9LCB7InNvdXJjZSI6ICJtdW5pY2giLCAidGFyZ2V0IjogInF1YW50dW1fZm91bmRhdGlvbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtdW5pY2gtcXVhbnR1bV9mb3VuZGF0aW9ucyJ9LCB7InNvdXJjZSI6ICJkZXRsZWZfZHVyciIsICJ0YXJnZXQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRldGxlZl9kdXJyLXF1YW50dW1fZm91bmRhdGlvbnMifSwgeyJzb3VyY2UiOiAicGhpbG9zb3BoeV9waHlzaWNzIiwgInRhcmdldCI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGhpbG9zb3BoeV9waHlzaWNzLXF1YW50dW1fZm91bmRhdGlvbnMifSwgeyJzb3VyY2UiOiAiYm90dG9tX3VwX2FwcHJvYWNoIiwgInRhcmdldCI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYm90dG9tX3VwX2FwcHJvYWNoLXF1YW50dW1fZm91bmRhdGlvbnMifSwgeyJzb3VyY2UiOiAiaW52aXRlZF90YWxrcyIsICJ0YXJnZXQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImludml0ZWRfdGFsa3MtcXVhbnR1bV9mb3VuZGF0aW9ucyJ9LCB7InNvdXJjZSI6ICJtYXN0ZXJzX3RoZXNpc19sbXUiLCAidGFyZ2V0IjogInF1YW50dW1fZm91bmRhdGlvbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtYXN0ZXJzX3RoZXNpc19sbXUtcXVhbnR1bV9mb3VuZGF0aW9ucyJ9LCB7InNvdXJjZSI6ICJsYXRleCIsICJ0YXJnZXQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxhdGV4LXF1YW50dW1fZm91bmRhdGlvbnMifSwgeyJzb3VyY2UiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJ0YXJnZXQiOiAiZGV0bGVmX2R1cnIiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJxdWFudHVtX2ZvdW5kYXRpb25zLWRldGxlZl9kdXJyIn0sIHsic291cmNlIjogIm11bmljaCIsICJ0YXJnZXQiOiAiZGV0bGVmX2R1cnIiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtdW5pY2gtZGV0bGVmX2R1cnIifSwgeyJzb3VyY2UiOiAibWFzdGVyc190aGVzaXNfbG11IiwgInRhcmdldCI6ICJkZXRsZWZfZHVyciIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm1hc3RlcnNfdGhlc2lzX2xtdS1kZXRsZWZfZHVyciJ9LCB7InNvdXJjZSI6ICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAidGFyZ2V0IjogImRldGxlZl9kdXJyIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGhpbG9zb3BoeV9waHlzaWNzLWRldGxlZl9kdXJyIn0sIHsic291cmNlIjogImJvdHRvbV91cF9hcHByb2FjaCIsICJ0YXJnZXQiOiAiZGV0bGVmX2R1cnIiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtZGV0bGVmX2R1cnIifSwgeyJzb3VyY2UiOiAiZGV0bGVmX2R1cnIiLCAidGFyZ2V0IjogInJlbm9ybWFsaXphdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRldGxlZl9kdXJyLXJlbm9ybWFsaXphdGlvbiJ9LCB7InNvdXJjZSI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInRhcmdldCI6ICJyZW5vcm1hbGl6YXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJxdWFudHVtX2ZvdW5kYXRpb25zLXJlbm9ybWFsaXphdGlvbiJ9LCB7InNvdXJjZSI6ICJjb21wbGV4X2FuYWx5c2lzIiwgInRhcmdldCI6ICJyZW5vcm1hbGl6YXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLXJlbm9ybWFsaXphdGlvbiJ9LCB7InNvdXJjZSI6ICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJ0YXJnZXQiOiAicmVub3JtYWxpemF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3BlY2lhbF9mdW5jdGlvbnMtcmVub3JtYWxpemF0aW9uIn0sIHsic291cmNlIjogImZvdXJpZXJfbGFwbGFjZSIsICJ0YXJnZXQiOiAicmVub3JtYWxpemF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZm91cmllcl9sYXBsYWNlLXJlbm9ybWFsaXphdGlvbiJ9LCB7InNvdXJjZSI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgInRhcmdldCI6ICJyZW5vcm1hbGl6YXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5LXJlbm9ybWFsaXphdGlvbiJ9LCB7InNvdXJjZSI6ICJyZW5vcm1hbGl6YXRpb24iLCAidGFyZ2V0IjogInNlbGZfZm9yY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyZW5vcm1hbGl6YXRpb24tc2VsZl9mb3JjZSJ9LCB7InNvdXJjZSI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAidGFyZ2V0IjogInNlbGZfZm9yY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnktc2VsZl9mb3JjZSJ9LCB7InNvdXJjZSI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgInRhcmdldCI6ICJzZWxmX2ZvcmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGVydHVyYmF0aW9uX3RoZW9yeS1zZWxmX2ZvcmNlIn0sIHsic291cmNlIjogInNwZWNpYWxfZnVuY3Rpb25zIiwgInRhcmdldCI6ICJzZWxmX2ZvcmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3BlY2lhbF9mdW5jdGlvbnMtc2VsZl9mb3JjZSJ9LCB7InNvdXJjZSI6ICJtYXRoZW1hdGljYSIsICJ0YXJnZXQiOiAic2VsZl9mb3JjZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm1hdGhlbWF0aWNhLXNlbGZfZm9yY2UifSwgeyJzb3VyY2UiOiAic2VsZl9mb3JjZSIsICJ0YXJnZXQiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzZWxmX2ZvcmNlLWJsYWNrX2hvbGVfc3RhYmlsaXR5In0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInVvZmFfZWR1Y2F0aW9uLWJsYWNrX2hvbGVfc3RhYmlsaXR5In0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic2FtX2dyYWxsYS1ibGFja19ob2xlX3N0YWJpbGl0eSJ9LCB7InNvdXJjZSI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAidGFyZ2V0IjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LWJsYWNrX2hvbGVfc3RhYmlsaXR5In0sIHsic291cmNlIjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAidGFyZ2V0IjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGVydHVyYmF0aW9uX3RoZW9yeS1ibGFja19ob2xlX3N0YWJpbGl0eSJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLWJsYWNrX2hvbGVfc3RhYmlsaXR5In0sIHsic291cmNlIjogIm1hdGhlbWF0aWNhIiwgInRhcmdldCI6ICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm1hdGhlbWF0aWNhLWJsYWNrX2hvbGVfc3RhYmlsaXR5In0sIHsic291cmNlIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInRhcmdldCI6ICJidHpfYmxhY2tfaG9sZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5LWJ0el9ibGFja19ob2xlIn0sIHsic291cmNlIjogImNvbXBsZXhfYW5hbHlzaXMiLCAidGFyZ2V0IjogImJ0el9ibGFja19ob2xlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY29tcGxleF9hbmFseXNpcy1idHpfYmxhY2tfaG9sZSJ9LCB7InNvdXJjZSI6ICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJ0YXJnZXQiOiAiYnR6X2JsYWNrX2hvbGUiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzcGVjaWFsX2Z1bmN0aW9ucy1idHpfYmxhY2tfaG9sZSJ9LCB7InNvdXJjZSI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAidGFyZ2V0IjogImJ0el9ibGFja19ob2xlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LWJ0el9ibGFja19ob2xlIn0sIHsic291cmNlIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInRhcmdldCI6ICJhcmV0YWtpc19pbnN0YWJpbGl0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5LWFyZXRha2lzX2luc3RhYmlsaXR5In0sIHsic291cmNlIjogImJ0el9ibGFja19ob2xlIiwgInRhcmdldCI6ICJhcmV0YWtpc19pbnN0YWJpbGl0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJ0el9ibGFja19ob2xlLWFyZXRha2lzX2luc3RhYmlsaXR5In0sIHsic291cmNlIjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAidGFyZ2V0IjogImFyZXRha2lzX2luc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGVydHVyYmF0aW9uX3RoZW9yeS1hcmV0YWtpc19pbnN0YWJpbGl0eSJ9LCB7InNvdXJjZSI6ICJmb3VyaWVyX2xhcGxhY2UiLCAidGFyZ2V0IjogImFyZXRha2lzX2luc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZm91cmllcl9sYXBsYWNlLWFyZXRha2lzX2luc3RhYmlsaXR5In0sIHsic291cmNlIjogImFyZXRha2lzX2luc3RhYmlsaXR5IiwgInRhcmdldCI6ICJwX3JuYWRzNSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImFyZXRha2lzX2luc3RhYmlsaXR5LXBfcm5hZHM1In0sIHsic291cmNlIjogImFkc19jZnQiLCAidGFyZ2V0IjogInBfcm5hZHM1IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYWRzX2NmdC1wX3JuYWRzNSJ9LCB7InNvdXJjZSI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAidGFyZ2V0IjogInBfcm5hZHM1IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LXBfcm5hZHM1In0sIHsic291cmNlIjogInBfcm5hZHM1IiwgInRhcmdldCI6ICJjcml0aWNhbF9waGVub21lbmFfc2NhbGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInBfcm5hZHM1LWNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIn0sIHsic291cmNlIjogImJvdHRvbV91cF9hcHByb2FjaCIsICJ0YXJnZXQiOiAiY3JpdGljYWxfcGhlbm9tZW5hX3NjYWxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtY3JpdGljYWxfcGhlbm9tZW5hX3NjYWxpbmcifSwgeyJzb3VyY2UiOiAiYWRzX2NmdCIsICJ0YXJnZXQiOiAiY3JpdGljYWxfcGhlbm9tZW5hX3NjYWxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJhZHNfY2Z0LWNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogImNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3RhdGlzdGljcy1jcml0aWNhbF9waGVub21lbmFfc2NhbGluZyJ9LCB7InNvdXJjZSI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAidGFyZ2V0IjogImNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYWdlbnRfYmFzZWRfbW9kZWxsaW5nLWNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIn0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJzYW1fZ3JhbGxhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidW9mYV9lZHVjYXRpb24tc2FtX2dyYWxsYSJ9LCB7InNvdXJjZSI6ICJzZWxmX2ZvcmNlIiwgInRhcmdldCI6ICJzYW1fZ3JhbGxhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic2VsZl9mb3JjZS1zYW1fZ3JhbGxhIn0sIHsic291cmNlIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInRhcmdldCI6ICJzYW1fZ3JhbGxhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHktc2FtX2dyYWxsYSJ9LCB7InNvdXJjZSI6ICJ0dWNzb24iLCAidGFyZ2V0IjogInNhbV9ncmFsbGEiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dWNzb24tc2FtX2dyYWxsYSJ9LCB7InNvdXJjZSI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAidGFyZ2V0IjogInNhbV9ncmFsbGEiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnktc2FtX2dyYWxsYSJ9LCB7InNvdXJjZSI6ICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJ0YXJnZXQiOiAiYWRzX2NmdCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5LWFkc19jZnQifSwgeyJzb3VyY2UiOiAicF9ybmFkczUiLCAidGFyZ2V0IjogImFkc19jZnQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwX3JuYWRzNS1hZHNfY2Z0In0sIHsic291cmNlIjogImNvbXBsZXhfYW5hbHlzaXMiLCAidGFyZ2V0IjogImFkc19jZnQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLWFkc19jZnQifSwgeyJzb3VyY2UiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5IiwgInRhcmdldCI6ICJhZHNfY2Z0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LWFkc19jZnQifSwgeyJzb3VyY2UiOiAiZGV0bGVmX2R1cnIiLCAidGFyZ2V0IjogImJvdHRvbV91cF9hcHByb2FjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRldGxlZl9kdXJyLWJvdHRvbV91cF9hcHByb2FjaCJ9LCB7InNvdXJjZSI6ICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAidGFyZ2V0IjogImJvdHRvbV91cF9hcHByb2FjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInBoaWxvc29waHlfcGh5c2ljcy1ib3R0b21fdXBfYXBwcm9hY2gifSwgeyJzb3VyY2UiOiAiYWdlbnRfYmFzZWRfbW9kZWxsaW5nIiwgInRhcmdldCI6ICJib3R0b21fdXBfYXBwcm9hY2giLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmctYm90dG9tX3VwX2FwcHJvYWNoIn0sIHsic291cmNlIjogInJlaW5mb3JjZW1lbnRfbGVhcm5pbmciLCAidGFyZ2V0IjogImJvdHRvbV91cF9hcHByb2FjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlaW5mb3JjZW1lbnRfbGVhcm5pbmctYm90dG9tX3VwX2FwcHJvYWNoIn0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInRvcF9kb3duX2FwcHJvYWNoIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZS10b3BfZG93bl9hcHByb2FjaCJ9LCB7InNvdXJjZSI6ICJzdGF0aXN0aWNzIiwgInRhcmdldCI6ICJ0b3BfZG93bl9hcHByb2FjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtdG9wX2Rvd25fYXBwcm9hY2gifSwgeyJzb3VyY2UiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJ0YXJnZXQiOiAidG9wX2Rvd25fYXBwcm9hY2giLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJleHBlcmltZW50YWxfZGVzaWduLXRvcF9kb3duX2FwcHJvYWNoIn0sIHsic291cmNlIjogInF1YW50dW1fZm91bmRhdGlvbnMiLCAidGFyZ2V0IjogInBoaWxvc29waHlfcGh5c2ljcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInF1YW50dW1fZm91bmRhdGlvbnMtcGhpbG9zb3BoeV9waHlzaWNzIn0sIHsic291cmNlIjogImRldGxlZl9kdXJyIiwgInRhcmdldCI6ICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkZXRsZWZfZHVyci1waGlsb3NvcGh5X3BoeXNpY3MifSwgeyJzb3VyY2UiOiAibXVuaWNoIiwgInRhcmdldCI6ICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtdW5pY2gtcGhpbG9zb3BoeV9waHlzaWNzIn0sIHsic291cmNlIjogImJpdHNfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1waGlsb3NvcGh5X3BoeXNpY3MifSwgeyJzb3VyY2UiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHkiLCAidGFyZ2V0IjogInB1YmxpY2F0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5LXB1YmxpY2F0aW9ucyJ9LCB7InNvdXJjZSI6ICJhcmV0YWtpc19pbnN0YWJpbGl0eSIsICJ0YXJnZXQiOiAicHVibGljYXRpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYXJldGFraXNfaW5zdGFiaWxpdHktcHVibGljYXRpb25zIn0sIHsic291cmNlIjogImJ0el9ibGFja19ob2xlIiwgInRhcmdldCI6ICJwdWJsaWNhdGlvbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJidHpfYmxhY2tfaG9sZS1wdWJsaWNhdGlvbnMifSwgeyJzb3VyY2UiOiAicF9ybmFkczUiLCAidGFyZ2V0IjogInB1YmxpY2F0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInBfcm5hZHM1LXB1YmxpY2F0aW9ucyJ9LCB7InNvdXJjZSI6ICJsYXRleCIsICJ0YXJnZXQiOiAicHVibGljYXRpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGF0ZXgtcHVibGljYXRpb25zIn0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogInB1YmxpY2F0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNhbV9ncmFsbGEtcHVibGljYXRpb25zIn0sIHsic291cmNlIjogInB1YmxpY2F0aW9ucyIsICJ0YXJnZXQiOiAiY29uZmVyZW5jZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwdWJsaWNhdGlvbnMtY29uZmVyZW5jZXMifSwgeyJzb3VyY2UiOiAiaW52aXRlZF90YWxrcyIsICJ0YXJnZXQiOiAiY29uZmVyZW5jZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJpbnZpdGVkX3RhbGtzLWNvbmZlcmVuY2VzIn0sIHsic291cmNlIjogImxhdGV4IiwgInRhcmdldCI6ICJjb25mZXJlbmNlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxhdGV4LWNvbmZlcmVuY2VzIn0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJjb25mZXJlbmNlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInVvZmFfZWR1Y2F0aW9uLWNvbmZlcmVuY2VzIn0sIHsic291cmNlIjogImNvbmZlcmVuY2VzIiwgInRhcmdldCI6ICJpbnZpdGVkX3RhbGtzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY29uZmVyZW5jZXMtaW52aXRlZF90YWxrcyJ9LCB7InNvdXJjZSI6ICJwdWJsaWNhdGlvbnMiLCAidGFyZ2V0IjogImludml0ZWRfdGFsa3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwdWJsaWNhdGlvbnMtaW52aXRlZF90YWxrcyJ9LCB7InNvdXJjZSI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInRhcmdldCI6ICJpbnZpdGVkX3RhbGtzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucy1pbnZpdGVkX3RhbGtzIn0sIHsic291cmNlIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInRhcmdldCI6ICJpbnZpdGVkX3RhbGtzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHktaW52aXRlZF90YWxrcyJ9LCB7InNvdXJjZSI6ICJiaXRzX2VkdWNhdGlvbiIsICJ0YXJnZXQiOiAidW9mYV9lZHVjYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi11b2ZhX2VkdWNhdGlvbiJ9LCB7InNvdXJjZSI6ICJ0dWNzb24iLCAidGFyZ2V0IjogInVvZmFfZWR1Y2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVjc29uLXVvZmFfZWR1Y2F0aW9uIn0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogInVvZmFfZWR1Y2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic2FtX2dyYWxsYS11b2ZhX2VkdWNhdGlvbiJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogInVvZmFfZWR1Y2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLXVvZmFfZWR1Y2F0aW9uIn0sIHsic291cmNlIjogImh5ZGVyYWJhZCIsICJ0YXJnZXQiOiAiYml0c19lZHVjYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJoeWRlcmFiYWQtYml0c19lZHVjYXRpb24ifSwgeyJzb3VyY2UiOiAiY2FsY3VsdXMiLCAidGFyZ2V0IjogImJpdHNfZWR1Y2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2FsY3VsdXMtYml0c19lZHVjYXRpb24ifSwgeyJzb3VyY2UiOiAibGluZWFyX2FsZ2VicmEiLCAidGFyZ2V0IjogImJpdHNfZWR1Y2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGluZWFyX2FsZ2VicmEtYml0c19lZHVjYXRpb24ifSwgeyJzb3VyY2UiOiAiY29tcGxleF9hbmFseXNpcyIsICJ0YXJnZXQiOiAiYml0c19lZHVjYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLWJpdHNfZWR1Y2F0aW9uIn0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJncmFkdWF0ZV9yZXNlYXJjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInVvZmFfZWR1Y2F0aW9uLWdyYWR1YXRlX3Jlc2VhcmNoIn0sIHsic291cmNlIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInRhcmdldCI6ICJncmFkdWF0ZV9yZXNlYXJjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5LWdyYWR1YXRlX3Jlc2VhcmNoIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiZ3JhZHVhdGVfcmVzZWFyY2giLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZ3JhZHVhdGVfcmVzZWFyY2gifSwgeyJzb3VyY2UiOiAibWF0aGVtYXRpY2EiLCAidGFyZ2V0IjogImdyYWR1YXRlX3Jlc2VhcmNoIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibWF0aGVtYXRpY2EtZ3JhZHVhdGVfcmVzZWFyY2gifSwgeyJzb3VyY2UiOiAiZGV0bGVmX2R1cnIiLCAidGFyZ2V0IjogIm1hc3RlcnNfdGhlc2lzX2xtdSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRldGxlZl9kdXJyLW1hc3RlcnNfdGhlc2lzX2xtdSJ9LCB7InNvdXJjZSI6ICJtdW5pY2giLCAidGFyZ2V0IjogIm1hc3RlcnNfdGhlc2lzX2xtdSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm11bmljaC1tYXN0ZXJzX3RoZXNpc19sbXUifSwgeyJzb3VyY2UiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJ0YXJnZXQiOiAibWFzdGVyc190aGVzaXNfbG11IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucy1tYXN0ZXJzX3RoZXNpc19sbXUifSwgeyJzb3VyY2UiOiAibGF0ZXgiLCAidGFyZ2V0IjogIm1hc3RlcnNfdGhlc2lzX2xtdSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxhdGV4LW1hc3RlcnNfdGhlc2lzX2xtdSJ9LCB7InNvdXJjZSI6ICJ1b2ZhX2VkdWNhdGlvbiIsICJ0YXJnZXQiOiAidGVhY2hpbmdfdW9mYSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInVvZmFfZWR1Y2F0aW9uLXRlYWNoaW5nX3VvZmEifSwgeyJzb3VyY2UiOiAidHVjc29uIiwgInRhcmdldCI6ICJ0ZWFjaGluZ191b2ZhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVjc29uLXRlYWNoaW5nX3VvZmEifSwgeyJzb3VyY2UiOiAiY2FsY3VsdXMiLCAidGFyZ2V0IjogInRlYWNoaW5nX3VvZmEiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjYWxjdWx1cy10ZWFjaGluZ191b2ZhIn0sIHsic291cmNlIjogImxpbmVhcl9hbGdlYnJhIiwgInRhcmdldCI6ICJ0ZWFjaGluZ191b2ZhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGluZWFyX2FsZ2VicmEtdGVhY2hpbmdfdW9mYSJ9LCB7InNvdXJjZSI6ICJtdW5pY2giLCAidGFyZ2V0IjogImZhc2NpbmF0aW9uX2xlYXJuaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibXVuaWNoLWZhc2NpbmF0aW9uX2xlYXJuaW5nIn0sIHsic291cmNlIjogInBoaWxvc29waHlfcGh5c2ljcyIsICJ0YXJnZXQiOiAiZmFzY2luYXRpb25fbGVhcm5pbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwaGlsb3NvcGh5X3BoeXNpY3MtZmFzY2luYXRpb25fbGVhcm5pbmcifSwgeyJzb3VyY2UiOiAiYm90dG9tX3VwX2FwcHJvYWNoIiwgInRhcmdldCI6ICJmYXNjaW5hdGlvbl9sZWFybmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJvdHRvbV91cF9hcHByb2FjaC1mYXNjaW5hdGlvbl9sZWFybmluZyJ9LCB7InNvdXJjZSI6ICJ2YW5jb3V2ZXIiLCAidGFyZ2V0IjogInR1cm5vX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ2YW5jb3V2ZXItdHVybm9fZXhwZXJpZW5jZSJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJ0dXJub19leHBlcmllbmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS10dXJub19leHBlcmllbmNlIn0sIHsic291cmNlIjogInJlY29tbWVuZGF0aW9uX3N5c3RlbXMiLCAidGFyZ2V0IjogInR1cm5vX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zLXR1cm5vX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAiZ2FtZV90aGVvcnkiLCAidGFyZ2V0IjogInR1cm5vX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJnYW1lX3RoZW9yeS10dXJub19leHBlcmllbmNlIn0sIHsic291cmNlIjogIm1hcmtldHBsYWNlcyIsICJ0YXJnZXQiOiAidHVybm9fZXhwZXJpZW5jZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm1hcmtldHBsYWNlcy10dXJub19leHBlcmllbmNlIn0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInJvdmVyX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlLXJvdmVyX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAic2VhdHRsZSIsICJ0YXJnZXQiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNlYXR0bGUtcm92ZXJfZXhwZXJpZW5jZSJ9LCB7InNvdXJjZSI6ICJzY2hudWNraSIsICJ0YXJnZXQiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNjaG51Y2tpLXJvdmVyX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAibWFya2V0cGxhY2VzIiwgInRhcmdldCI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibWFya2V0cGxhY2VzLXJvdmVyX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLXJvdmVyX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAic3FsIiwgInRhcmdldCI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3FsLXJvdmVyX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAidW9mYV9lZHVjYXRpb24iLCAidGFyZ2V0IjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ1b2ZhX2VkdWNhdGlvbi1kYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1kYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGF0aXN0aWNzLWRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAidG9wX2Rvd25fYXBwcm9hY2giLCAidGFyZ2V0IjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0b3BfZG93bl9hcHByb2FjaC1kYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIn0sIHsic291cmNlIjogInNlYXR0bGUiLCAidGFyZ2V0IjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzZWF0dGxlLWRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHkiLCAidGFyZ2V0IjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJibGFja19ob2xlX3N0YWJpbGl0eS1wZXJ0dXJiYXRpb25fdGhlb3J5In0sIHsic291cmNlIjogImNvbXBsZXhfYW5hbHlzaXMiLCAidGFyZ2V0IjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLXBlcnR1cmJhdGlvbl90aGVvcnkifSwgeyJzb3VyY2UiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5IiwgInRhcmdldCI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LXBlcnR1cmJhdGlvbl90aGVvcnkifSwgeyJzb3VyY2UiOiAiZm91cmllcl9sYXBsYWNlIiwgInRhcmdldCI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZm91cmllcl9sYXBsYWNlLXBlcnR1cmJhdGlvbl90aGVvcnkifSwgeyJzb3VyY2UiOiAiYml0c19lZHVjYXRpb24iLCAidGFyZ2V0IjogImNvbXBsZXhfYW5hbHlzaXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1jb21wbGV4X2FuYWx5c2lzIn0sIHsic291cmNlIjogImNhbGN1bHVzIiwgInRhcmdldCI6ICJjb21wbGV4X2FuYWx5c2lzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2FsY3VsdXMtY29tcGxleF9hbmFseXNpcyJ9LCB7InNvdXJjZSI6ICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJ0YXJnZXQiOiAiY29tcGxleF9hbmFseXNpcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNwZWNpYWxfZnVuY3Rpb25zLWNvbXBsZXhfYW5hbHlzaXMifSwgeyJzb3VyY2UiOiAiZm91cmllcl9sYXBsYWNlIiwgInRhcmdldCI6ICJjb21wbGV4X2FuYWx5c2lzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZm91cmllcl9sYXBsYWNlLWNvbXBsZXhfYW5hbHlzaXMifSwgeyJzb3VyY2UiOiAiY29tcGxleF9hbmFseXNpcyIsICJ0YXJnZXQiOiAic3BlY2lhbF9mdW5jdGlvbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLXNwZWNpYWxfZnVuY3Rpb25zIn0sIHsic291cmNlIjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAidGFyZ2V0IjogInNwZWNpYWxfZnVuY3Rpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGVydHVyYmF0aW9uX3RoZW9yeS1zcGVjaWFsX2Z1bmN0aW9ucyJ9LCB7InNvdXJjZSI6ICJtYXRoZW1hdGljYSIsICJ0YXJnZXQiOiAic3BlY2lhbF9mdW5jdGlvbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtYXRoZW1hdGljYS1zcGVjaWFsX2Z1bmN0aW9ucyJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogInNwZWNpYWxfZnVuY3Rpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLXNwZWNpYWxfZnVuY3Rpb25zIn0sIHsic291cmNlIjogImNvbXBsZXhfYW5hbHlzaXMiLCAidGFyZ2V0IjogImZvdXJpZXJfbGFwbGFjZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNvbXBsZXhfYW5hbHlzaXMtZm91cmllcl9sYXBsYWNlIn0sIHsic291cmNlIjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAidGFyZ2V0IjogImZvdXJpZXJfbGFwbGFjZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInBlcnR1cmJhdGlvbl90aGVvcnktZm91cmllcl9sYXBsYWNlIn0sIHsic291cmNlIjogImlzYWlfcHJvamVjdCIsICJ0YXJnZXQiOiAiZm91cmllcl9sYXBsYWNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiaXNhaV9wcm9qZWN0LWZvdXJpZXJfbGFwbGFjZSJ9LCB7InNvdXJjZSI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJ0YXJnZXQiOiAiZm91cmllcl9sYXBsYWNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidGltZV9zZXJpZXNfZm9yZWNhc3RpbmctZm91cmllcl9sYXBsYWNlIn0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ1b2ZhX2VkdWNhdGlvbi1kaWZmZXJlbnRpYWxfZ2VvbWV0cnkifSwgeyJzb3VyY2UiOiAibGluZWFyX2FsZ2VicmEiLCAidGFyZ2V0IjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxpbmVhcl9hbGdlYnJhLWRpZmZlcmVudGlhbF9nZW9tZXRyeSJ9LCB7InNvdXJjZSI6ICJjYWxjdWx1cyIsICJ0YXJnZXQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2FsY3VsdXMtZGlmZmVyZW50aWFsX2dlb21ldHJ5In0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNhbV9ncmFsbGEtZGlmZmVyZW50aWFsX2dlb21ldHJ5In0sIHsic291cmNlIjogImJpdHNfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJjYWxjdWx1cyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJpdHNfZWR1Y2F0aW9uLWNhbGN1bHVzIn0sIHsic291cmNlIjogIm1hZ25ldGljX21vbm9wb2xlcyIsICJ0YXJnZXQiOiAiY2FsY3VsdXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtYWduZXRpY19tb25vcG9sZXMtY2FsY3VsdXMifSwgeyJzb3VyY2UiOiAiY29tcGxleF9hbmFseXNpcyIsICJ0YXJnZXQiOiAiY2FsY3VsdXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLWNhbGN1bHVzIn0sIHsic291cmNlIjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJ0YXJnZXQiOiAiY2FsY3VsdXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnktY2FsY3VsdXMifSwgeyJzb3VyY2UiOiAiYml0c19lZHVjYXRpb24iLCAidGFyZ2V0IjogImxpbmVhcl9hbGdlYnJhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYml0c19lZHVjYXRpb24tbGluZWFyX2FsZ2VicmEifSwgeyJzb3VyY2UiOiAiY2FsY3VsdXMiLCAidGFyZ2V0IjogImxpbmVhcl9hbGdlYnJhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2FsY3VsdXMtbGluZWFyX2FsZ2VicmEifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJsaW5lYXJfYWxnZWJyYSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1saW5lYXJfYWxnZWJyYSJ9LCB7InNvdXJjZSI6ICJjbGFzc2lmaWNhdGlvbiIsICJ0YXJnZXQiOiAibGluZWFyX2FsZ2VicmEiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjbGFzc2lmaWNhdGlvbi1saW5lYXJfYWxnZWJyYSJ9LCB7InNvdXJjZSI6ICJyZWdyZXNzaW9uIiwgInRhcmdldCI6ICJsaW5lYXJfYWxnZWJyYSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlZ3Jlc3Npb24tbGluZWFyX2FsZ2VicmEifSwgeyJzb3VyY2UiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAic3RhdGlzdGljcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2Utc3RhdGlzdGljcyJ9LCB7InNvdXJjZSI6ICJleHBlcmltZW50YWxfZGVzaWduIiwgInRhcmdldCI6ICJzdGF0aXN0aWNzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbi1zdGF0aXN0aWNzIn0sIHsic291cmNlIjogImJheWVzaWFuX3N0YXRpc3RpY3MiLCAidGFyZ2V0IjogInN0YXRpc3RpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiYXllc2lhbl9zdGF0aXN0aWNzLXN0YXRpc3RpY3MifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJzdGF0aXN0aWNzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLXN0YXRpc3RpY3MifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZ2FtZV90aGVvcnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLWdhbWVfdGhlb3J5In0sIHsic291cmNlIjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMiLCAidGFyZ2V0IjogImdhbWVfdGhlb3J5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGVjaXNpb25fbWFraW5nX2FnZW50cy1nYW1lX3RoZW9yeSJ9LCB7InNvdXJjZSI6ICJhdWN0aW9uc19kZXNpZ24iLCAidGFyZ2V0IjogImdhbWVfdGhlb3J5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYXVjdGlvbnNfZGVzaWduLWdhbWVfdGhlb3J5In0sIHsic291cmNlIjogIm1hcmtldHBsYWNlcyIsICJ0YXJnZXQiOiAiZ2FtZV90aGVvcnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtYXJrZXRwbGFjZXMtZ2FtZV90aGVvcnkifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAicmVjb21tZW5kYXRpb25fc3lzdGVtcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtcmVjb21tZW5kYXRpb25fc3lzdGVtcyJ9LCB7InNvdXJjZSI6ICJ0dXJub19leHBlcmllbmNlIiwgInRhcmdldCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVybm9fZXhwZXJpZW5jZS1yZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAicmVjb21tZW5kYXRpb25fc3lzdGVtcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1yZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIn0sIHsic291cmNlIjogImNsYXNzaWZpY2F0aW9uIiwgInRhcmdldCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2xhc3NpZmljYXRpb24tcmVjb21tZW5kYXRpb25fc3lzdGVtcyJ9LCB7InNvdXJjZSI6ICJsZWFybl90b19yYW5rIiwgInRhcmdldCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGVhcm5fdG9fcmFuay1yZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIn0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImNsdXN0ZXJpbmdfYWxnb3JpdGhtcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UtY2x1c3RlcmluZ19hbGdvcml0aG1zIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiY2x1c3RlcmluZ19hbGdvcml0aG1zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLWNsdXN0ZXJpbmdfYWxnb3JpdGhtcyJ9LCB7InNvdXJjZSI6ICJnZW9zcGF0aWFsX2FuYWx5c2lzIiwgInRhcmdldCI6ICJjbHVzdGVyaW5nX2FsZ29yaXRobXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJnZW9zcGF0aWFsX2FuYWx5c2lzLWNsdXN0ZXJpbmdfYWxnb3JpdGhtcyJ9LCB7InNvdXJjZSI6ICJzZW1hbnRpY19zZWFyY2giLCAidGFyZ2V0IjogImNsdXN0ZXJpbmdfYWxnb3JpdGhtcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNlbWFudGljX3NlYXJjaC1jbHVzdGVyaW5nX2FsZ29yaXRobXMifSwgeyJzb3VyY2UiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiY2xhc3NpZmljYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlLWNsYXNzaWZpY2F0aW9uIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiY2xhc3NpZmljYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tY2xhc3NpZmljYXRpb24ifSwgeyJzb3VyY2UiOiAibGluZWFyX2FsZ2VicmEiLCAidGFyZ2V0IjogImNsYXNzaWZpY2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGluZWFyX2FsZ2VicmEtY2xhc3NpZmljYXRpb24ifSwgeyJzb3VyY2UiOiAic3RhdGlzdGljcyIsICJ0YXJnZXQiOiAiY2xhc3NpZmljYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGF0aXN0aWNzLWNsYXNzaWZpY2F0aW9uIn0sIHsic291cmNlIjogImlzYWlfcHJvamVjdCIsICJ0YXJnZXQiOiAiY2xhc3NpZmljYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJpc2FpX3Byb2plY3QtY2xhc3NpZmljYXRpb24ifSwgeyJzb3VyY2UiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAicmVncmVzc2lvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UtcmVncmVzc2lvbiJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogInJlZ3Jlc3Npb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tcmVncmVzc2lvbiJ9LCB7InNvdXJjZSI6ICJsaW5lYXJfYWxnZWJyYSIsICJ0YXJnZXQiOiAicmVncmVzc2lvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxpbmVhcl9hbGdlYnJhLXJlZ3Jlc3Npb24ifSwgeyJzb3VyY2UiOiAic3RhdGlzdGljcyIsICJ0YXJnZXQiOiAicmVncmVzc2lvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtcmVncmVzc2lvbiJ9LCB7InNvdXJjZSI6ICJwcmljaW5nX2VsYXN0aWNpdHkiLCAidGFyZ2V0IjogInJlZ3Jlc3Npb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwcmljaW5nX2VsYXN0aWNpdHktcmVncmVzc2lvbiJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtdGltZV9zZXJpZXNfZm9yZWNhc3RpbmcifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi10aW1lX3Nlcmllc19mb3JlY2FzdGluZyJ9LCB7InNvdXJjZSI6ICJzdGF0aXN0aWNzIiwgInRhcmdldCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtdGltZV9zZXJpZXNfZm9yZWNhc3RpbmcifSwgeyJzb3VyY2UiOiAiZm91cmllcl9sYXBsYWNlIiwgInRhcmdldCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImZvdXJpZXJfbGFwbGFjZS10aW1lX3Nlcmllc19mb3JlY2FzdGluZyJ9LCB7InNvdXJjZSI6ICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0IiwgInRhcmdldCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN1cHBseV9kZW1hbmRfZm9yZWNhc3QtdGltZV9zZXJpZXNfZm9yZWNhc3RpbmcifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAibWFya292X2NoYWluX21vZGVscyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtbWFya292X2NoYWluX21vZGVscyJ9LCB7InNvdXJjZSI6ICJzdGF0aXN0aWNzIiwgInRhcmdldCI6ICJtYXJrb3ZfY2hhaW5fbW9kZWxzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3RhdGlzdGljcy1tYXJrb3ZfY2hhaW5fbW9kZWxzIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAibWFya292X2NoYWluX21vZGVscyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1tYXJrb3ZfY2hhaW5fbW9kZWxzIn0sIHsic291cmNlIjogInN1cHBseV9kZW1hbmRfZm9yZWNhc3QiLCAidGFyZ2V0IjogIm1hcmtvdl9jaGFpbl9tb2RlbHMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0LW1hcmtvdl9jaGFpbl9tb2RlbHMifSwgeyJzb3VyY2UiOiAicmVjb21tZW5kYXRpb25fc3lzdGVtcyIsICJ0YXJnZXQiOiAibGVhcm5fdG9fcmFuayIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlY29tbWVuZGF0aW9uX3N5c3RlbXMtbGVhcm5fdG9fcmFuayJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImxlYXJuX3RvX3JhbmsiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tbGVhcm5fdG9fcmFuayJ9LCB7InNvdXJjZSI6ICJjbGFzc2lmaWNhdGlvbiIsICJ0YXJnZXQiOiAibGVhcm5fdG9fcmFuayIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNsYXNzaWZpY2F0aW9uLWxlYXJuX3RvX3JhbmsifSwgeyJzb3VyY2UiOiAiYm90dG9tX3VwX2FwcHJvYWNoIiwgInRhcmdldCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtYWdlbnRfYmFzZWRfbW9kZWxsaW5nIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiYWdlbnRfYmFzZWRfbW9kZWxsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLWFnZW50X2Jhc2VkX21vZGVsbGluZyJ9LCB7InNvdXJjZSI6ICJlcGlkZW1pY19zaW11bGF0aW9uIiwgInRhcmdldCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJlcGlkZW1pY19zaW11bGF0aW9uLWFnZW50X2Jhc2VkX21vZGVsbGluZyJ9LCB7InNvdXJjZSI6ICJkZWNpc2lvbl9tYWtpbmdfYWdlbnRzIiwgInRhcmdldCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkZWNpc2lvbl9tYWtpbmdfYWdlbnRzLWFnZW50X2Jhc2VkX21vZGVsbGluZyJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJleHBlcmltZW50YWxfZGVzaWduIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1leHBlcmltZW50YWxfZGVzaWduIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGF0aXN0aWNzLWV4cGVyaW1lbnRhbF9kZXNpZ24ifSwgeyJzb3VyY2UiOiAiYmF5ZXNpYW5fc3RhdGlzdGljcyIsICJ0YXJnZXQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJheWVzaWFuX3N0YXRpc3RpY3MtZXhwZXJpbWVudGFsX2Rlc2lnbiJ9LCB7InNvdXJjZSI6ICJtYXJrZXRwbGFjZV9pbmZsYXRpb25fcmVjcyIsICJ0YXJnZXQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm1hcmtldHBsYWNlX2luZmxhdGlvbl9yZWNzLWV4cGVyaW1lbnRhbF9kZXNpZ24ifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZXhwZXJpbWVudGF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1leHBlcmltZW50YXRpb24ifSwgeyJzb3VyY2UiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJ0YXJnZXQiOiAiZXhwZXJpbWVudGF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbi1leHBlcmltZW50YXRpb24ifSwgeyJzb3VyY2UiOiAic3RhdGlzdGljcyIsICJ0YXJnZXQiOiAiZXhwZXJpbWVudGF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3RhdGlzdGljcy1leHBlcmltZW50YXRpb24ifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJleHBlcmltZW50YXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZXhwZXJpbWVudGF0aW9uIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogImJheWVzaWFuX3N0YXRpc3RpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGF0aXN0aWNzLWJheWVzaWFuX3N0YXRpc3RpY3MifSwgeyJzb3VyY2UiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJ0YXJnZXQiOiAiYmF5ZXNpYW5fc3RhdGlzdGljcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImV4cGVyaW1lbnRhbF9kZXNpZ24tYmF5ZXNpYW5fc3RhdGlzdGljcyJ9LCB7InNvdXJjZSI6ICJsdHZfbW9kZWxpbmciLCAidGFyZ2V0IjogImJheWVzaWFuX3N0YXRpc3RpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJsdHZfbW9kZWxpbmctYmF5ZXNpYW5fc3RhdGlzdGljcyJ9LCB7InNvdXJjZSI6ICJiaXRzX2VkdWNhdGlvbiIsICJ0YXJnZXQiOiAibGF0ZXgiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1sYXRleCJ9LCB7InNvdXJjZSI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInRhcmdldCI6ICJsYXRleCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInF1YW50dW1fZm91bmRhdGlvbnMtbGF0ZXgifSwgeyJzb3VyY2UiOiAicHVibGljYXRpb25zIiwgInRhcmdldCI6ICJsYXRleCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB1YmxpY2F0aW9ucy1sYXRleCJ9LCB7InNvdXJjZSI6ICJjb25mZXJlbmNlcyIsICJ0YXJnZXQiOiAibGF0ZXgiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb25mZXJlbmNlcy1sYXRleCJ9LCB7InNvdXJjZSI6ICJiaXRzX2VkdWNhdGlvbiIsICJ0YXJnZXQiOiAibWF0aGVtYXRpY2EiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1tYXRoZW1hdGljYSJ9LCB7InNvdXJjZSI6ICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJ0YXJnZXQiOiAibWF0aGVtYXRpY2EiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzcGVjaWFsX2Z1bmN0aW9ucy1tYXRoZW1hdGljYSJ9LCB7InNvdXJjZSI6ICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJ0YXJnZXQiOiAibWF0aGVtYXRpY2EiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJibGFja19ob2xlX3N0YWJpbGl0eS1tYXRoZW1hdGljYSJ9LCB7InNvdXJjZSI6ICJjb21wbGV4X2FuYWx5c2lzIiwgInRhcmdldCI6ICJtYXRoZW1hdGljYSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNvbXBsZXhfYW5hbHlzaXMtbWF0aGVtYXRpY2EifSwgeyJzb3VyY2UiOiAidW9mYV9lZHVjYXRpb24iLCAidGFyZ2V0IjogInB5dGhvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInVvZmFfZWR1Y2F0aW9uLXB5dGhvbiJ9LCB7InNvdXJjZSI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJweXRob24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlLXB5dGhvbiJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJweXRob24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLXB5dGhvbiJ9LCB7InNvdXJjZSI6ICJsaW5lYXJfYWxnZWJyYSIsICJ0YXJnZXQiOiAicHl0aG9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGluZWFyX2FsZ2VicmEtcHl0aG9uIn0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInNxbCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2Utc3FsIn0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInNxbCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2Utc3FsIn0sIHsic291cmNlIjogImRhdGFfZW5naW5lZXJpbmciLCAidGFyZ2V0IjogInNxbCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfZW5naW5lZXJpbmctc3FsIn0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJnaXQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ1b2ZhX2VkdWNhdGlvbi1naXQifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJnaXQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZ2l0In0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImdpdCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UtZ2l0In0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImF3c19nY3AiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLWF3c19nY3AifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiYXdzX2djcCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtYXdzX2djcCJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImF3c19nY3AiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tYXdzX2djcCJ9LCB7InNvdXJjZSI6ICJkYXRhX2VuZ2luZWVyaW5nIiwgInRhcmdldCI6ICJhd3NfZ2NwIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGF0YV9lbmdpbmVlcmluZy1hd3NfZ2NwIn0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImRhZ3N0ZXJfYWlyZmxvdyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtZGFnc3Rlcl9haXJmbG93In0sIHsic291cmNlIjogInR1cm5vX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImRhZ3N0ZXJfYWlyZmxvdyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtZGFnc3Rlcl9haXJmbG93In0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiZGFnc3Rlcl9haXJmbG93IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLWRhZ3N0ZXJfYWlyZmxvdyJ9LCB7InNvdXJjZSI6ICJkYXRhX2VuZ2luZWVyaW5nIiwgInRhcmdldCI6ICJkYWdzdGVyX2FpcmZsb3ciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkYXRhX2VuZ2luZWVyaW5nLWRhZ3N0ZXJfYWlyZmxvdyJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJkYnQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLWRidCJ9LCB7InNvdXJjZSI6ICJ0dXJub19leHBlcmllbmNlIiwgInRhcmdldCI6ICJkYnQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLWRidCJ9LCB7InNvdXJjZSI6ICJzcWwiLCAidGFyZ2V0IjogImRidCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNxbC1kYnQifSwgeyJzb3VyY2UiOiAiZGF0YV9lbmdpbmVlcmluZyIsICJ0YXJnZXQiOiAiZGJ0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGF0YV9lbmdpbmVlcmluZy1kYnQifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAidGFibGVhdV9tb2RlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS10YWJsZWF1X21vZGUifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAidGFibGVhdV9tb2RlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVybm9fZXhwZXJpZW5jZS10YWJsZWF1X21vZGUifSwgeyJzb3VyY2UiOiAic3FsIiwgInRhcmdldCI6ICJ0YWJsZWF1X21vZGUiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzcWwtdGFibGVhdV9tb2RlIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogInRhYmxlYXVfbW9kZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtdGFibGVhdV9tb2RlIn0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImlzYWlfcHJvamVjdCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UtaXNhaV9wcm9qZWN0In0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiaXNhaV9wcm9qZWN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLWlzYWlfcHJvamVjdCJ9LCB7InNvdXJjZSI6ICJjbGFzc2lmaWNhdGlvbiIsICJ0YXJnZXQiOiAiaXNhaV9wcm9qZWN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2xhc3NpZmljYXRpb24taXNhaV9wcm9qZWN0In0sIHsic291cmNlIjogImZvdXJpZXJfbGFwbGFjZSIsICJ0YXJnZXQiOiAiaXNhaV9wcm9qZWN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZm91cmllcl9sYXBsYWNlLWlzYWlfcHJvamVjdCJ9LCB7InNvdXJjZSI6ICJjbHVzdGVyaW5nX2FsZ29yaXRobXMiLCAidGFyZ2V0IjogImlzYWlfcHJvamVjdCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNsdXN0ZXJpbmdfYWxnb3JpdGhtcy1pc2FpX3Byb2plY3QifSwgeyJzb3VyY2UiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZXBpZGVtaWNfc2ltdWxhdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UtZXBpZGVtaWNfc2ltdWxhdGlvbiJ9LCB7InNvdXJjZSI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAidGFyZ2V0IjogImVwaWRlbWljX3NpbXVsYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmctZXBpZGVtaWNfc2ltdWxhdGlvbiJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImVwaWRlbWljX3NpbXVsYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZXBpZGVtaWNfc2ltdWxhdGlvbiJ9LCB7InNvdXJjZSI6ICJib3R0b21fdXBfYXBwcm9hY2giLCAidGFyZ2V0IjogImVwaWRlbWljX3NpbXVsYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtZXBpZGVtaWNfc2ltdWxhdGlvbiJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1zdXBwbHlfZGVtYW5kX2ZvcmVjYXN0In0sIHsic291cmNlIjogInRpbWVfc2VyaWVzX2ZvcmVjYXN0aW5nIiwgInRhcmdldCI6ICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidGltZV9zZXJpZXNfZm9yZWNhc3Rpbmctc3VwcGx5X2RlbWFuZF9mb3JlY2FzdCJ9LCB7InNvdXJjZSI6ICJtYXJrb3ZfY2hhaW5fbW9kZWxzIiwgInRhcmdldCI6ICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibWFya292X2NoYWluX21vZGVscy1zdXBwbHlfZGVtYW5kX2ZvcmVjYXN0In0sIHsic291cmNlIjogImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAidGFyZ2V0IjogInN1cHBseV9kZW1hbmRfZm9yZWNhc3QiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJnZW9zcGF0aWFsX2FuYWx5c2lzLXN1cHBseV9kZW1hbmRfZm9yZWNhc3QifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZGF0YV9lbmdpbmVlcmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtZGF0YV9lbmdpbmVlcmluZyJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImRhdGFfZW5naW5lZXJpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZGF0YV9lbmdpbmVlcmluZyJ9LCB7InNvdXJjZSI6ICJzcWwiLCAidGFyZ2V0IjogImRhdGFfZW5naW5lZXJpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzcWwtZGF0YV9lbmdpbmVlcmluZyJ9LCB7InNvdXJjZSI6ICJhd3NfZ2NwIiwgInRhcmdldCI6ICJkYXRhX2VuZ2luZWVyaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYXdzX2djcC1kYXRhX2VuZ2luZWVyaW5nIn0sIHsic291cmNlIjogImRhZ3N0ZXJfYWlyZmxvdyIsICJ0YXJnZXQiOiAiZGF0YV9lbmdpbmVlcmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhZ3N0ZXJfYWlyZmxvdy1kYXRhX2VuZ2luZWVyaW5nIn0sIHsic291cmNlIjogImRidCIsICJ0YXJnZXQiOiAiZGF0YV9lbmdpbmVlcmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRidC1kYXRhX2VuZ2luZWVyaW5nIn0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogIm1hcmtldHBsYWNlX2luZmxhdGlvbl9yZWNzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1tYXJrZXRwbGFjZV9pbmZsYXRpb25fcmVjcyJ9LCB7InNvdXJjZSI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgInRhcmdldCI6ICJtYXJrZXRwbGFjZV9pbmZsYXRpb25fcmVjcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlY29tbWVuZGF0aW9uX3N5c3RlbXMtbWFya2V0cGxhY2VfaW5mbGF0aW9uX3JlY3MifSwgeyJzb3VyY2UiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJ0YXJnZXQiOiAibWFya2V0cGxhY2VfaW5mbGF0aW9uX3JlY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJleHBlcmltZW50YWxfZGVzaWduLW1hcmtldHBsYWNlX2luZmxhdGlvbl9yZWNzIn0sIHsic291cmNlIjogImdhbWVfdGhlb3J5IiwgInRhcmdldCI6ICJtYXJrZXRwbGFjZV9pbmZsYXRpb25fcmVjcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdhbWVfdGhlb3J5LW1hcmtldHBsYWNlX2luZmxhdGlvbl9yZWNzIn0sIHsic291cmNlIjogInByaWNpbmdfZWxhc3RpY2l0eSIsICJ0YXJnZXQiOiAibWFya2V0cGxhY2VfaW5mbGF0aW9uX3JlY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwcmljaW5nX2VsYXN0aWNpdHktbWFya2V0cGxhY2VfaW5mbGF0aW9uX3JlY3MifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZ2VvX3NwbGl0X2V4cGVyaW1lbnRhdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtZ2VvX3NwbGl0X2V4cGVyaW1lbnRhdGlvbiJ9LCB7InNvdXJjZSI6ICJleHBlcmltZW50YWxfZGVzaWduIiwgInRhcmdldCI6ICJnZW9fc3BsaXRfZXhwZXJpbWVudGF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbi1nZW9fc3BsaXRfZXhwZXJpbWVudGF0aW9uIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogImdlb19zcGxpdF9leHBlcmltZW50YXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGF0aXN0aWNzLWdlb19zcGxpdF9leHBlcmltZW50YXRpb24ifSwgeyJzb3VyY2UiOiAiZ2Vvc3BhdGlhbF9hbmFseXNpcyIsICJ0YXJnZXQiOiAiZ2VvX3NwbGl0X2V4cGVyaW1lbnRhdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdlb3NwYXRpYWxfYW5hbHlzaXMtZ2VvX3NwbGl0X2V4cGVyaW1lbnRhdGlvbiJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJmaW5hbmNpYWxfbW9kZWxsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1maW5hbmNpYWxfbW9kZWxsaW5nIn0sIHsic291cmNlIjogInR1cm5vX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImZpbmFuY2lhbF9tb2RlbGxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLWZpbmFuY2lhbF9tb2RlbGxpbmcifSwgeyJzb3VyY2UiOiAic3RhdGlzdGljcyIsICJ0YXJnZXQiOiAiZmluYW5jaWFsX21vZGVsbGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtZmluYW5jaWFsX21vZGVsbGluZyJ9LCB7InNvdXJjZSI6ICJyZWdyZXNzaW9uIiwgInRhcmdldCI6ICJmaW5hbmNpYWxfbW9kZWxsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicmVncmVzc2lvbi1maW5hbmNpYWxfbW9kZWxsaW5nIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiZmluYW5jaWFsX21vZGVsbGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1maW5hbmNpYWxfbW9kZWxsaW5nIn0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLWdlb3NwYXRpYWxfYW5hbHlzaXMifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZ2Vvc3BhdGlhbF9hbmFseXNpcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtZ2Vvc3BhdGlhbF9hbmFseXNpcyJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZ2Vvc3BhdGlhbF9hbmFseXNpcyJ9LCB7InNvdXJjZSI6ICJjbHVzdGVyaW5nX2FsZ29yaXRobXMiLCAidGFyZ2V0IjogImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjbHVzdGVyaW5nX2FsZ29yaXRobXMtZ2Vvc3BhdGlhbF9hbmFseXNpcyJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJwcmljaW5nX2VsYXN0aWNpdHkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLXByaWNpbmdfZWxhc3RpY2l0eSJ9LCB7InNvdXJjZSI6ICJ0dXJub19leHBlcmllbmNlIiwgInRhcmdldCI6ICJwcmljaW5nX2VsYXN0aWNpdHkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLXByaWNpbmdfZWxhc3RpY2l0eSJ9LCB7InNvdXJjZSI6ICJnYW1lX3RoZW9yeSIsICJ0YXJnZXQiOiAicHJpY2luZ19lbGFzdGljaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZ2FtZV90aGVvcnktcHJpY2luZ19lbGFzdGljaXR5In0sIHsic291cmNlIjogImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAidGFyZ2V0IjogInByaWNpbmdfZWxhc3RpY2l0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImV4cGVyaW1lbnRhbF9kZXNpZ24tcHJpY2luZ19lbGFzdGljaXR5In0sIHsic291cmNlIjogInJlZ3Jlc3Npb24iLCAidGFyZ2V0IjogInByaWNpbmdfZWxhc3RpY2l0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlZ3Jlc3Npb24tcHJpY2luZ19lbGFzdGljaXR5In0sIHsic291cmNlIjogInR1cm5vX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInRhbV9hbmFseXNpcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtdGFtX2FuYWx5c2lzIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogInRhbV9hbmFseXNpcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtdGFtX2FuYWx5c2lzIn0sIHsic291cmNlIjogImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAidGFyZ2V0IjogInRhbV9hbmFseXNpcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdlb3NwYXRpYWxfYW5hbHlzaXMtdGFtX2FuYWx5c2lzIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAidGFtX2FuYWx5c2lzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLXRhbV9hbmFseXNpcyJ9LCB7InNvdXJjZSI6ICJ0dXJub19leHBlcmllbmNlIiwgInRhcmdldCI6ICJsdHZfbW9kZWxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLWx0dl9tb2RlbGluZyJ9LCB7InNvdXJjZSI6ICJyZWdyZXNzaW9uIiwgInRhcmdldCI6ICJsdHZfbW9kZWxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyZWdyZXNzaW9uLWx0dl9tb2RlbGluZyJ9LCB7InNvdXJjZSI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJ0YXJnZXQiOiAibHR2X21vZGVsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidGltZV9zZXJpZXNfZm9yZWNhc3RpbmctbHR2X21vZGVsaW5nIn0sIHsic291cmNlIjogImJheWVzaWFuX3N0YXRpc3RpY3MiLCAidGFyZ2V0IjogImx0dl9tb2RlbGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJheWVzaWFuX3N0YXRpc3RpY3MtbHR2X21vZGVsaW5nIn0sIHsic291cmNlIjogImxhcmdlX2xhbmd1YWdlX21vZGVscyIsICJ0YXJnZXQiOiAibGxtc19wcm9kdWN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzLWxsbXNfcHJvZHVjdCJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJsbG1zX3Byb2R1Y3QiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLWxsbXNfcHJvZHVjdCJ9LCB7InNvdXJjZSI6ICJ0dXJub19leHBlcmllbmNlIiwgInRhcmdldCI6ICJsbG1zX3Byb2R1Y3QiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLWxsbXNfcHJvZHVjdCJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImxsbXNfcHJvZHVjdCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1sbG1zX3Byb2R1Y3QifSwgeyJzb3VyY2UiOiAic2VtYW50aWNfc2VhcmNoIiwgInRhcmdldCI6ICJsbG1zX3Byb2R1Y3QiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzZW1hbnRpY19zZWFyY2gtbGxtc19wcm9kdWN0In0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogIm1sX3Byb2R1Y3Rpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLW1sX3Byb2R1Y3Rpb24ifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAibWxfcHJvZHVjdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtbWxfcHJvZHVjdGlvbiJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogIm1sX3Byb2R1Y3Rpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tbWxfcHJvZHVjdGlvbiJ9LCB7InNvdXJjZSI6ICJhd3NfZ2NwIiwgInRhcmdldCI6ICJtbF9wcm9kdWN0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYXdzX2djcC1tbF9wcm9kdWN0aW9uIn0sIHsic291cmNlIjogImRhZ3N0ZXJfYWlyZmxvdyIsICJ0YXJnZXQiOiAibWxfcHJvZHVjdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhZ3N0ZXJfYWlyZmxvdy1tbF9wcm9kdWN0aW9uIn0sIHsic291cmNlIjogImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAidGFyZ2V0IjogIm1sX3Byb2R1Y3Rpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJleHBlcmltZW50YWxfZGVzaWduLW1sX3Byb2R1Y3Rpb24ifSwgeyJzb3VyY2UiOiAic3RhbmZvcmRfYWlfY2VydCIsICJ0YXJnZXQiOiAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YW5mb3JkX2FpX2NlcnQtcmVpbmZvcmNlbWVudF9sZWFybmluZyJ9LCB7InNvdXJjZSI6ICJib3R0b21fdXBfYXBwcm9hY2giLCAidGFyZ2V0IjogInJlaW5mb3JjZW1lbnRfbGVhcm5pbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtcmVpbmZvcmNlbWVudF9sZWFybmluZyJ9LCB7InNvdXJjZSI6ICJnYW1lX3RoZW9yeSIsICJ0YXJnZXQiOiAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdhbWVfdGhlb3J5LXJlaW5mb3JjZW1lbnRfbGVhcm5pbmcifSwgeyJzb3VyY2UiOiAiZGVjaXNpb25fbWFraW5nX2FnZW50cyIsICJ0YXJnZXQiOiAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMtcmVpbmZvcmNlbWVudF9sZWFybmluZyJ9LCB7InNvdXJjZSI6ICJnYW1lX3RoZW9yeSIsICJ0YXJnZXQiOiAiZGVjaXNpb25fbWFraW5nX2FnZW50cyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdhbWVfdGhlb3J5LWRlY2lzaW9uX21ha2luZ19hZ2VudHMifSwgeyJzb3VyY2UiOiAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJ0YXJnZXQiOiAiZGVjaXNpb25fbWFraW5nX2FnZW50cyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlaW5mb3JjZW1lbnRfbGVhcm5pbmctZGVjaXNpb25fbWFraW5nX2FnZW50cyJ9LCB7InNvdXJjZSI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAidGFyZ2V0IjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmctZGVjaXNpb25fbWFraW5nX2FnZW50cyJ9LCB7InNvdXJjZSI6ICJib3R0b21fdXBfYXBwcm9hY2giLCAidGFyZ2V0IjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtZGVjaXNpb25fbWFraW5nX2FnZW50cyJ9LCB7InNvdXJjZSI6ICJnYW1lX3RoZW9yeSIsICJ0YXJnZXQiOiAiYXVjdGlvbnNfZGVzaWduIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZ2FtZV90aGVvcnktYXVjdGlvbnNfZGVzaWduIn0sIHsic291cmNlIjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMiLCAidGFyZ2V0IjogImF1Y3Rpb25zX2Rlc2lnbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMtYXVjdGlvbnNfZGVzaWduIn0sIHsic291cmNlIjogIm1hcmtldHBsYWNlcyIsICJ0YXJnZXQiOiAiYXVjdGlvbnNfZGVzaWduIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibWFya2V0cGxhY2VzLWF1Y3Rpb25zX2Rlc2lnbiJ9LCB7InNvdXJjZSI6ICJwcmljaW5nX2VsYXN0aWNpdHkiLCAidGFyZ2V0IjogImF1Y3Rpb25zX2Rlc2lnbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInByaWNpbmdfZWxhc3RpY2l0eS1hdWN0aW9uc19kZXNpZ24ifSwgeyJzb3VyY2UiOiAidmFuY291dmVyIiwgInRhcmdldCI6ICJzdGFuZm9yZF9haV9jZXJ0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidmFuY291dmVyLXN0YW5mb3JkX2FpX2NlcnQifSwgeyJzb3VyY2UiOiAibGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzIiwgInRhcmdldCI6ICJzdGFuZm9yZF9haV9jZXJ0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzLXN0YW5mb3JkX2FpX2NlcnQifSwgeyJzb3VyY2UiOiAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJ0YXJnZXQiOiAic3RhbmZvcmRfYWlfY2VydCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlaW5mb3JjZW1lbnRfbGVhcm5pbmctc3RhbmZvcmRfYWlfY2VydCJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogInN0YW5mb3JkX2FpX2NlcnQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tc3RhbmZvcmRfYWlfY2VydCJ9LCB7InNvdXJjZSI6ICJzdGFuZm9yZF9haV9jZXJ0IiwgInRhcmdldCI6ICJsYXJnZV9sYW5ndWFnZV9tb2RlbHMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGFuZm9yZF9haV9jZXJ0LWxhcmdlX2xhbmd1YWdlX21vZGVscyJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImxhcmdlX2xhbmd1YWdlX21vZGVscyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1sYXJnZV9sYW5ndWFnZV9tb2RlbHMifSwgeyJzb3VyY2UiOiAic2VtYW50aWNfc2VhcmNoIiwgInRhcmdldCI6ICJsYXJnZV9sYW5ndWFnZV9tb2RlbHMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzZW1hbnRpY19zZWFyY2gtbGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzIn0sIHsic291cmNlIjogImxsbXNfcHJvZHVjdCIsICJ0YXJnZXQiOiAibGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGxtc19wcm9kdWN0LWxhcmdlX2xhbmd1YWdlX21vZGVscyJ9LCB7InNvdXJjZSI6ICJsYXJnZV9sYW5ndWFnZV9tb2RlbHMiLCAidGFyZ2V0IjogInNlbWFudGljX3NlYXJjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxhcmdlX2xhbmd1YWdlX21vZGVscy1zZW1hbnRpY19zZWFyY2gifSwgeyJzb3VyY2UiOiAiY2x1c3RlcmluZ19hbGdvcml0aG1zIiwgInRhcmdldCI6ICJzZW1hbnRpY19zZWFyY2giLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjbHVzdGVyaW5nX2FsZ29yaXRobXMtc2VtYW50aWNfc2VhcmNoIn0sIHsic291cmNlIjogInJlY29tbWVuZGF0aW9uX3N5c3RlbXMiLCAidGFyZ2V0IjogInNlbWFudGljX3NlYXJjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlY29tbWVuZGF0aW9uX3N5c3RlbXMtc2VtYW50aWNfc2VhcmNoIn0sIHsic291cmNlIjogImRydWdfZGlzY292ZXJ5IiwgInRhcmdldCI6ICJtb2xlY3VsYXJfZHluYW1pY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkcnVnX2Rpc2NvdmVyeS1tb2xlY3VsYXJfZHluYW1pY3MifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJtb2xlY3VsYXJfZHluYW1pY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tbW9sZWN1bGFyX2R5bmFtaWNzIn0sIHsic291cmNlIjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJ0YXJnZXQiOiAibW9sZWN1bGFyX2R5bmFtaWNzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LW1vbGVjdWxhcl9keW5hbWljcyJ9LCB7InNvdXJjZSI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgInRhcmdldCI6ICJtb2xlY3VsYXJfZHluYW1pY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5LW1vbGVjdWxhcl9keW5hbWljcyJ9LCB7InNvdXJjZSI6ICJhbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMiLCAidGFyZ2V0IjogImRydWdfZGlzY292ZXJ5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzLWRydWdfZGlzY292ZXJ5In0sIHsic291cmNlIjogImJpdHNfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJkcnVnX2Rpc2NvdmVyeSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJpdHNfZWR1Y2F0aW9uLWRydWdfZGlzY292ZXJ5In0sIHsic291cmNlIjogIm1vbGVjdWxhcl9keW5hbWljcyIsICJ0YXJnZXQiOiAiZHJ1Z19kaXNjb3ZlcnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtb2xlY3VsYXJfZHluYW1pY3MtZHJ1Z19kaXNjb3ZlcnkifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJkcnVnX2Rpc2NvdmVyeSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1kcnVnX2Rpc2NvdmVyeSJ9LCB7InNvdXJjZSI6ICJjbGltYXRlX3RlY2giLCAidGFyZ2V0IjogIm51Y2xlYXJfZnVzaW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2xpbWF0ZV90ZWNoLW51Y2xlYXJfZnVzaW9uIn0sIHsic291cmNlIjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJ0YXJnZXQiOiAibnVjbGVhcl9mdXNpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnktbnVjbGVhcl9mdXNpb24ifSwgeyJzb3VyY2UiOiAicGVydHVyYmF0aW9uX3RoZW9yeSIsICJ0YXJnZXQiOiAibnVjbGVhcl9mdXNpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5LW51Y2xlYXJfZnVzaW9uIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAibnVjbGVhcl9mdXNpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tbnVjbGVhcl9mdXNpb24ifSwgeyJzb3VyY2UiOiAiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzIiwgInRhcmdldCI6ICJvcmdhbl9vbl9jaGlwIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzLW9yZ2FuX29uX2NoaXAifSwgeyJzb3VyY2UiOiAiYml0c19lZHVjYXRpb24iLCAidGFyZ2V0IjogIm9yZ2FuX29uX2NoaXAiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1vcmdhbl9vbl9jaGlwIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAib3JnYW5fb25fY2hpcCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1vcmdhbl9vbl9jaGlwIn0sIHsic291cmNlIjogInZlZ2FuIiwgInRhcmdldCI6ICJhbHRlcm5hdGl2ZV9wcm90ZWlucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInZlZ2FuLWFsdGVybmF0aXZlX3Byb3RlaW5zIn0sIHsic291cmNlIjogImNsaW1hdGVfdGVjaCIsICJ0YXJnZXQiOiAiYWx0ZXJuYXRpdmVfcHJvdGVpbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjbGltYXRlX3RlY2gtYWx0ZXJuYXRpdmVfcHJvdGVpbnMifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAibWFya2V0cGxhY2VzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1tYXJrZXRwbGFjZXMifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAibWFya2V0cGxhY2VzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVybm9fZXhwZXJpZW5jZS1tYXJrZXRwbGFjZXMifSwgeyJzb3VyY2UiOiAiZ2FtZV90aGVvcnkiLCAidGFyZ2V0IjogIm1hcmtldHBsYWNlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdhbWVfdGhlb3J5LW1hcmtldHBsYWNlcyJ9LCB7InNvdXJjZSI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgInRhcmdldCI6ICJtYXJrZXRwbGFjZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zLW1hcmtldHBsYWNlcyJ9LCB7InNvdXJjZSI6ICJyZWluZm9yY2VtZW50X2xlYXJuaW5nIiwgInRhcmdldCI6ICJnYW1pbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyZWluZm9yY2VtZW50X2xlYXJuaW5nLWdhbWluZyJ9LCB7InNvdXJjZSI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAidGFyZ2V0IjogImdhbWluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImFnZW50X2Jhc2VkX21vZGVsbGluZy1nYW1pbmcifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJnYW1pbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZ2FtaW5nIn0sIHsic291cmNlIjogIm51Y2xlYXJfZnVzaW9uIiwgInRhcmdldCI6ICJjbGltYXRlX3RlY2giLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJudWNsZWFyX2Z1c2lvbi1jbGltYXRlX3RlY2gifSwgeyJzb3VyY2UiOiAiYWx0ZXJuYXRpdmVfcHJvdGVpbnMiLCAidGFyZ2V0IjogImNsaW1hdGVfdGVjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImFsdGVybmF0aXZlX3Byb3RlaW5zLWNsaW1hdGVfdGVjaCJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImNsaW1hdGVfdGVjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1jbGltYXRlX3RlY2gifSwgeyJzb3VyY2UiOiAiY2hlbm5haSIsICJ0YXJnZXQiOiAiaHlkZXJhYmFkIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2hlbm5haS1oeWRlcmFiYWQifSwgeyJzb3VyY2UiOiAiYml0c19lZHVjYXRpb24iLCAidGFyZ2V0IjogImh5ZGVyYWJhZCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJpdHNfZWR1Y2F0aW9uLWh5ZGVyYWJhZCJ9LCB7InNvdXJjZSI6ICJoeWRlcmFiYWQiLCAidGFyZ2V0IjogIm11bmljaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImh5ZGVyYWJhZC1tdW5pY2gifSwgeyJzb3VyY2UiOiAiZGV0bGVmX2R1cnIiLCAidGFyZ2V0IjogIm11bmljaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRldGxlZl9kdXJyLW11bmljaCJ9LCB7InNvdXJjZSI6ICJmYXNjaW5hdGlvbl9sZWFybmluZyIsICJ0YXJnZXQiOiAibXVuaWNoIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZmFzY2luYXRpb25fbGVhcm5pbmctbXVuaWNoIn0sIHsic291cmNlIjogIm11bmljaCIsICJ0YXJnZXQiOiAidHVjc29uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibXVuaWNoLXR1Y3NvbiJ9LCB7InNvdXJjZSI6ICJ1b2ZhX2VkdWNhdGlvbiIsICJ0YXJnZXQiOiAidHVjc29uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidW9mYV9lZHVjYXRpb24tdHVjc29uIn0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogInR1Y3NvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNhbV9ncmFsbGEtdHVjc29uIn0sIHsic291cmNlIjogInZlZ2FuIiwgInRhcmdldCI6ICJ0dWNzb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ2ZWdhbi10dWNzb24ifSwgeyJzb3VyY2UiOiAidHVjc29uIiwgInRhcmdldCI6ICJzZWF0dGxlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVjc29uLXNlYXR0bGUifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAic2VhdHRsZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2Utc2VhdHRsZSJ9LCB7InNvdXJjZSI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJzZWF0dGxlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZS1zZWF0dGxlIn0sIHsic291cmNlIjogInNlYXR0bGUiLCAidGFyZ2V0IjogInZhbmNvdXZlciIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNlYXR0bGUtdmFuY291dmVyIn0sIHsic291cmNlIjogInR1cm5vX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInZhbmNvdXZlciIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtdmFuY291dmVyIn0sIHsic291cmNlIjogInN0YW5mb3JkX2FpX2NlcnQiLCAidGFyZ2V0IjogInZhbmNvdXZlciIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YW5mb3JkX2FpX2NlcnQtdmFuY291dmVyIn0sIHsic291cmNlIjogInR1Y3NvbiIsICJ0YXJnZXQiOiAic2NobnVja2kiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dWNzb24tc2NobnVja2kifSwgeyJzb3VyY2UiOiAic2VhdHRsZSIsICJ0YXJnZXQiOiAic2NobnVja2kiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzZWF0dGxlLXNjaG51Y2tpIn0sIHsic291cmNlIjogInZhbmNvdXZlciIsICJ0YXJnZXQiOiAic2NobnVja2kiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ2YW5jb3V2ZXItc2NobnVja2kifSwgeyJzb3VyY2UiOiAidHVjc29uIiwgInRhcmdldCI6ICJ2ZWdhbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1Y3Nvbi12ZWdhbiJ9LCB7InNvdXJjZSI6ICJhbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMiLCAidGFyZ2V0IjogInZlZ2FuIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzLXZlZ2FuIn0sIHsic291cmNlIjogImFsdGVybmF0aXZlX3Byb3RlaW5zIiwgInRhcmdldCI6ICJ2ZWdhbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImFsdGVybmF0aXZlX3Byb3RlaW5zLXZlZ2FuIn0sIHsic291cmNlIjogInZlZ2FuIiwgInRhcmdldCI6ICJhbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ2ZWdhbi1hbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMifSwgeyJzb3VyY2UiOiAiZHJ1Z19kaXNjb3ZlcnkiLCAidGFyZ2V0IjogImFuaW1hbF90ZXN0aW5nX2FsdGVybmF0aXZlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRydWdfZGlzY292ZXJ5LWFuaW1hbF90ZXN0aW5nX2FsdGVybmF0aXZlcyJ9LCB7InNvdXJjZSI6ICJvcmdhbl9vbl9jaGlwIiwgInRhcmdldCI6ICJhbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJvcmdhbl9vbl9jaGlwLWFuaW1hbF90ZXN0aW5nX2FsdGVybmF0aXZlcyJ9XX0=');
                const configStr = atob('eyJ3aWR0aCI6IDEyMDAsICJoZWlnaHQiOiAiNzV2aCIsICJoZXJvX21vZGUiOiB0cnVlLCAidGl0bGVfb3ZlcmxheSI6ICJBcnVuJ3MgS25vd2xlZGdlIEdyYXBoIiwgInRoZW1lIjogeyJwcmltYXJ5Q29sb3IiOiAiIzI3ODBlMyIsICJzZWNvbmRhcnlDb2xvciI6ICIjM2ZiNjE4IiwgImFjY2VudENvbG9yIjogIiNmZmRkM2MiLCAiZGFuZ2VyQ29sb3IiOiAiI2ZmMDAzOSIsICJtdXRlZENvbG9yIjogIiM4NjhlOTYiLCAiYmFja2dyb3VuZENvbG9yIjogIiNmZmZmZmYiLCAic3VyZmFjZUNvbG9yIjogIiNmOGY5ZmEiLCAidGV4dFByaW1hcnkiOiAiIzIxMjUyOSIsICJ0ZXh0U2Vjb25kYXJ5IjogIiM0OTUwNTciLCAiZm9udEZhbWlseSI6ICJzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sICdTZWdvZSBVSScsIFJvYm90bywgc2Fucy1zZXJpZiIsICJmb250U2l6ZUJhc2UiOiAxNH0sICJub2RlQ29sb3JzIjogeyJwaHlzaWNzIjogIiMyNzgwZTMiLCAiZGF0YSI6ICIjM2ZiNjE4IiwgInRvb2xraXQiOiAiI2ZmZGQzYyIsICJhcHBsaWNhdGlvbnMiOiAiI2ZmMDAzOSIsICJwZXJzb25hbCI6ICIjNjEzZDdjIn0sICJsYXllcnMiOiBbeyJpZCI6ICJwaHlzaWNzIiwgIm5hbWUiOiAiUGh5c2ljcyIsICJjb2xvciI6ICIjMjc4MGUzIn0sIHsiaWQiOiAiZGF0YSIsICJuYW1lIjogIkRhdGEgJiBBSSIsICJjb2xvciI6ICIjM2ZiNjE4In0sIHsiaWQiOiAidG9vbGtpdCIsICJuYW1lIjogIlRvb2xraXQiLCAiY29sb3IiOiAiI2ZmZGQzYyJ9LCB7ImlkIjogImFwcGxpY2F0aW9ucyIsICJuYW1lIjogIkFwcGxpY2F0aW9ucyIsICJjb2xvciI6ICIjZmYwMDM5In0sIHsiaWQiOiAicGVyc29uYWwiLCAibmFtZSI6ICJQZXJzb25hbCIsICJjb2xvciI6ICIjNjEzZDdjIn1dLCAidGltZWxpbmUiOiB7ImVuYWJsZWQiOiB0cnVlLCAic3RhcnQiOiAyMDA5LCAiZW5kIjogMjAyNX0sICJmZWF0dXJlcyI6IHsic2hvd01pbmlNYXAiOiB0cnVlLCAic2hvd1RpbWVsaW5lIjogdHJ1ZSwgInNob3dMZWdlbmQiOiB0cnVlLCAiZW5hYmxlSG92ZXIiOiB0cnVlLCAiZW5hYmxlRHJhZyI6IHRydWV9LCAic2ltdWxhdGlvbiI6IHsibGlua0Rpc3RhbmNlIjogMjAwLCAiY2hhcmdlU3RyZW5ndGgiOiAtMzAwLCAiY29sbGlzaW9uUmFkaXVzIjogNjAsICJsaW5rU3RyZW5ndGgiOiAwLjI1LCAiY2VudGVyU3RyZW5ndGgiOiAwLjUsICJjaGFyZ2VEaXN0YW5jZU1heCI6IDUwMCwgInZlbG9jaXR5RGVjYXkiOiAwLjh9fQ==');
                const data = JSON.parse(dataStr);
                const config = JSON.parse(configStr);

                // Apply Quarto dark mode theme if active
                function applyQuartoTheme() {
                    const isDarkMode = document.documentElement.classList.contains('quarto-dark');

                    if (isDarkMode) {
                        // Dark mode theme
                        config.theme = {
                            ...config.theme,
                            backgroundColor: '#1f1f1f',
                            surfaceColor: '#262626',
                            textPrimary: '#e9ecef',
                            textSecondary: '#adb5bd',
                            textMuted: '#6c757d',
                            borderColor: '#404040',
                            mutedColor: '#6c757d'
                        };

                        // Update hero section background if in hero mode
                        if (config.hero_mode) {
                            const heroSection = document.querySelector('.hero-section');
                            if (heroSection) {
                                heroSection.style.background = '#1f1f1f';
                            }
                        }
                    } else {
                        // Light mode theme (default)
                        config.theme = {
                            ...config.theme,
                            backgroundColor: '#ffffff',
                            surfaceColor: '#f8f9fa',
                            textPrimary: '#212529',
                            textSecondary: '#495057',
                            textMuted: '#868e96',
                            borderColor: '#dee2e6',
                            mutedColor: '#868e96'
                        };

                        // Update hero section background if in hero mode
                        if (config.hero_mode) {
                            const heroSection = document.querySelector('.hero-section');
                            if (heroSection) {
                                heroSection.style.background = '#f9f9f9';
                            }
                        }
                    }
                }

                applyQuartoTheme();

                const container = document.getElementById('kg_c86fdab8');
                const wrapper = document.getElementById('kg_c86fdab8_wrapper');
                container.innerHTML = ''; // Clear loading message

                // Fix dimensions for hero mode - convert viewport units to pixels
                if (config.hero_mode) {
                    const rect = wrapper.getBoundingClientRect();
                    config.width = rect.width;
                    config.height = rect.height;
                    console.log(`Hero mode dimensions: ${config.width} x ${config.height}`);
                }
                
                console.log('Creating KnowledgeGraphExplorer...');
                const graph = new KnowledgeGraphExplorer(container, data, config);
                window.kg_c86fdab8 = graph;
                
                console.log('Graph created, adding UI controls to wrapper...');

                // Add UI controls to the wrapper, not the graph container
                setTimeout(() => {
                    try {
                        const uiControls = new UIControlsManager(config);
                        // Merge data and config for UI controls
                        const dataWithConfig = Object.assign({}, data, {
                            layers: config.layers,
                            timeline: config.timeline
                        });
                        uiControls.initialize(wrapper, graph, dataWithConfig);
                        window['kg_c86fdab8_ui'] = uiControls;
                        console.log('UI controls added to wrapper successfully');
                    } catch (uiError) {
                        console.error('UI Controls failed:', uiError);
                    }
                }, 500);

                // Listen for Quarto theme changes and update graph accordingly
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.attributeName === 'class' && mutation.target === document.documentElement) {
                            applyQuartoTheme();
                            if (graph && graph.updateConfig) {
                                graph.updateConfig({ theme: config.theme });
                            }
                        }
                    });
                });
                observer.observe(document.documentElement, {
                    attributes: true,
                    attributeFilter: ['class']
                });

                // Setup title overlay interaction detection if present
                const titleOverlay = document.getElementById('kg_c86fdab8_title_overlay');
                if (titleOverlay) {
                    let titleHidden = false;

                    function hideTitleOverlay() {
                        if (!titleHidden) {
                            titleHidden = true;
                            titleOverlay.style.transition = 'opacity 0.8s ease-out';
                            titleOverlay.style.opacity = '0';
                            setTimeout(() => {
                                titleOverlay.style.display = 'none';
                            }, 800);
                        }
                    }

                    // Only hide title on meaningful graph interactions
                    container.addEventListener('click', hideTitleOverlay);
                    container.addEventListener('touchstart', hideTitleOverlay);
                    container.addEventListener('wheel', hideTitleOverlay); // For zoom

                    // Hide on graph interaction events (not passive events like mousemove)
                    graph.on('zoom', hideTitleOverlay);
                    graph.on('nodeClick', hideTitleOverlay);
                    graph.on('audienceChange', hideTitleOverlay);

                    // Hide on drag start (meaningful interaction)
                    let isDragging = false;
                    container.addEventListener('mousedown', () => {
                        isDragging = false;
                    });
                    container.addEventListener('mousemove', (e) => {
                        if (e.buttons > 0) { // Mouse button is pressed during move
                            if (!isDragging) {
                                isDragging = true;
                                hideTitleOverlay();
                            }
                        }
                    });
                }
                
                console.log('Graph initialized successfully');
            } catch (error) {
                console.error('Graph initialization failed:', error);
                document.getElementById('kg_c86fdab8').innerHTML = 
                    '<div style="padding: 20px; color: red;">Graph failed to load: ' + error.message + '</div>';
            }
        }

        // Wait for D3 and DOM
        if (typeof d3 !== 'undefined' && document.readyState === 'complete') {
            initGraph();
        } else {
            window.addEventListener('load', function() {
                setTimeout(initGraph, 200);
            });
        }
        </script>
        

<script>
// Manually add title overlay after graph loads
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
        const wrapper = document.querySelector('.kg-hero-wrapper');
        if (wrapper && !document.querySelector('.kg-hero-intro')) {
            // Create enhanced overlay with photo, name, and description
            const overlay = document.createElement('div');
            overlay.className = 'kg-hero-intro';
            overlay.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); z-index: 100; text-align: center; pointer-events: none; opacity: 0; transition: opacity 0.8s ease-out, transform 0.8s ease-out;';

            // Profile picture
            const profileImg = document.createElement('img');
            profileImg.src = 'profile.jpg';
            profileImg.alt = 'Arun Ravishankar';
            profileImg.style.cssText = 'width: 300px; height: 300px; border-radius: 50%; object-fit: cover; margin-bottom: 1.5rem; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15); border: 3px solid rgba(255, 255, 255, 0.9);';

            // Name
            const name = document.createElement('h1');
            name.textContent = "Arun Ravishankar";
            name.style.cssText = 'font-size: 3rem; font-weight: 300; color: #495057; margin: 0 0 1rem 0; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); letter-spacing: 0.5px;';

            // Description/invitation
            const description = document.createElement('p');
            description.textContent = "Explore this interactive knowledge graph to discover my journey across physics, data science, and AI";
            description.style.cssText = 'font-size: 1.2rem; font-weight: 400; color: #666; margin: 0; max-width: 500px; line-height: 1.5; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);';

            overlay.appendChild(profileImg);
            overlay.appendChild(name);
            overlay.appendChild(description);
            wrapper.appendChild(overlay);

            // Fade in the title with scale effect after a delay
            setTimeout(() => {
                overlay.style.opacity = '1';
                overlay.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 500);

            // Setup interaction detection to hide title
            let titleHidden = false;
            const container = wrapper.querySelector('[id^="kg_"]');

            function hideTitleOverlay() {
                if (!titleHidden && overlay) {
                    titleHidden = true;
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        if (overlay.parentNode) {
                            overlay.parentNode.removeChild(overlay);
                        }
                    }, 800);
                }
            }

            if (container) {
                // Hide on meaningful interactions
                container.addEventListener('click', hideTitleOverlay);
                container.addEventListener('touchstart', hideTitleOverlay);
                container.addEventListener('wheel', hideTitleOverlay);

                // Hide on drag
                let isDragging = false;
                container.addEventListener('mousedown', () => {
                    isDragging = false;
                });
                container.addEventListener('mousemove', (e) => {
                    if (e.buttons > 0) {
                        if (!isDragging) {
                            isDragging = true;
                            hideTitleOverlay();
                        }
                    }
                });
            }

            // Also try to hook into the graph instance if available
            setTimeout(() => {
                const graphInstance = window[wrapper.id.replace('_wrapper', '')];
                if (graphInstance && graphInstance.on) {
                    graphInstance.on('nodeClick', hideTitleOverlay);
                    graphInstance.on('zoom', hideTitleOverlay);
                    graphInstance.on('audienceChange', hideTitleOverlay);
                }
            }, 2000);
        }
    }, 1000);
});
</script>

</div>
<div class="about-content-section">
<section id="about-me" class="level2">
<h2 class="anchored" data-anchor-id="about-me">About Me</h2>
<p>I get excited about figuring things out, which has taken me on a rather wandering path across continents and disciplines.</p>
<p>If weâ€™re going by standard buckets, Iâ€™d call myself a theoretical physicist-turned-data scientist, but my interests are all over the place, so Iâ€™d rather not be stuck with that label.</p>
<div class="social-links">
<p>Connect with me: <a href="https://bsky.app/profile/arunravishankar.bsky.social">Bluesky</a> â€¢ <a href="https://www.linkedin.com/in/arunravishankar/">LinkedIn</a> â€¢ <a href="https://github.com/arunravishankar">GitHub</a> â€¢ <a href="mailto:arunravishankar@gmail.com">Email</a></p>
</div>
</section>
<section id="the-journey" class="level2">
<h2 class="anchored" data-anchor-id="the-journey">The Journey</h2>
<p>Curiosity about the quantum foundations took me from India to Munich, where I worked with the late <a href="https://www.mathematik.uni-muenchen.de/~duerr/">Detlef DÃ¼rr</a> on Bohmian mechanics. His research group was full of people who were inquisitive, and deeply cared about the work they did. This was where I started looking at systems with the bottom-up approach â€” figuring out how to formulate a theory that ontologically describes how nature works at a fundamental level, with the constraints of having to describe known phenomena.</p>
<p>I went to Tucson planning to work with <a href="https://sgralla.arizona.edu/">Sam Gralla</a> on the self-force problem, but ended up getting sucked into <a href="https://inspirehep.net/authors/1798223">black hole physics</a> instead. The PhD years in Arizona were intense in ways I didnâ€™t expect. I got really good at sitting with hard problems for months without making progress, then suddenly seeing the path forward. Somewhere along the way, I also started caring about the math itself, not just what it could tell me about black holes.</p>
<p>Then Schnucki showed up with those brown eyes and infinite capacity for love, and suddenly being with her in a place where she could run around freely became a priority. Seattle called â€” Iâ€™m a sucker for gloomy, drizzly weather and the beautiful outdoors. I was fortunate to find my first position outside academia at Rover, working with genuinely amazing people, and everything clicked differently. Instead of â€œWhat fundamental dynamics make this happen?â€ I started asking â€œWhat can we actually figure out from messy, real-world data?â€. I went from exact solutions and clean equations to thinking in distributions and probabilities. Turns out that adding programming to your toolkit allows you to ask questions that youâ€™d never even think of asking if you didnâ€™t have those techniques under your belt.</p>
<p>Long-term immigration stability brought me to Vancouver in 2024. Now Iâ€™m doing Stanfordâ€™s AI program while consulting for Turno (another 2-sided marketplace, because apparently I have a type). These days Iâ€™m obsessed with where game theory, reinforcement learning, and economics overlap â€” itâ€™s this sweet spot where bottom-up and top-down thinking actually play nice together. And yeah, like everyone else, Iâ€™m trying to figure out what to do with large language models.</p>
</section>
<section id="education" class="level2">
<h2 class="anchored" data-anchor-id="education">Education</h2>
<p><strong>Stanford University</strong> | Remote<br>
AI Graduate Certificate | Sep 2024 - present</p>
<p><strong>The Data Incubator</strong> | Remote<br>
Data Science Fellowship | Feb 2021 - May 2021</p>
<p><strong>University of Arizona</strong> | Tucson, AZ<br>
PhD in Physics | Aug 2015 - Jul 2021</p>
<p><strong>Ludwig Maximilians University</strong> | Munich, DE<br>
Visiting student for Masterâ€™s thesis | Aug 2013 - Jul 2014</p>
<p><strong>Birla Institute of Technology and Sciences</strong> | Hyderabad, India<br>
MSc in Physics &amp; Bachelors in Pharmacy | Aug 2009 - Jul 2014</p>
</section>
<section id="experience" class="level2">
<h2 class="anchored" data-anchor-id="experience">Experience</h2>
<p><strong>Turno</strong> | Vancouver, BC<br>
Data Scientist | Sep 2024 - present</p>
<p><strong>Rover</strong> | Seattle, WA<br>
Data Scientist II &amp; III | Sep 2021 - Sep 2024</p>
<p>If youâ€™re interested in more specifics of what Iâ€™ve done professionally, you can find more details on my <a href="https://arunravishankar.github.io/cv/">Resume</a> and on <a href="https://www.linkedin.com/in/arunravishankar/">LinkedIn</a>.</p>
</section>
<section id="interactive-exploration" class="level2">
<h2 class="anchored" data-anchor-id="interactive-exploration">Interactive Exploration</h2>
<p>The graph above shows the interconnected nature of my journey - you can:</p>
<ul>
<li><strong>Hover over nodes</strong> to see the 3D distance-based effects</li>
<li><strong>Click nodes</strong> for detailed descriptions</li>
<li><strong>Use the layer controls</strong> to focus on specific aspects (Education, Research, Industry, Current Focus, Geographic)</li>
<li><strong>Navigate the timeline</strong> to see how things evolved over time</li>
<li><strong>Use the minimap</strong> to quickly jump to different areas</li>
</ul>
<p>Each connection represents how one experience led to or influenced another. The stronger the connection, the more direct the influence. Youâ€™ll notice that geographic moves often coincided with major career transitions, and that the bottom-up thinking approach from quantum foundations continues to influence my current work in AI and game theory.</p>
<p>The questions keep changing, but Iâ€™m still just as curious about complex systems â€” whether theyâ€™re quantum foundations, black holes, markets, or whateverâ€™s next.</p>
</section>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/www\.inmylightcone\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>