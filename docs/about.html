<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>About – In My Lightcone</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">In My Lightcone</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./about.html" aria-current="page"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./ramblings.html"> 
<span class="menu-text">Ramblings</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/arunravishankar"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/arunravishankar"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://bsky.app/profile/arunravishankar.bsky.social"> <i class="bi bi-bluesky" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<div class="quarto-about-jolla">
  <img src="profile.jpg" class="about-image
  round " style="height: 15em; width: 15em;">
 <header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">About</h1>
</div>
<div class="quarto-title-meta">
  </div>
</header><main class="content" id="quarto-document-content">
<p>I get excited about figuring things out, which has taken me on a rather wandering path across continents and disciplines.</p>
<p>If we’re going by standard buckets, I’d call myself a theoretical physicist-turned-data scientist, but my interests are all over the place, so I’d rather not be stuck with that label.</p>
        <div id="kg_0f705368_wrapper" style="position: relative; width: 900px; height: 600px; margin: 0 auto;">
            <div id="kg_0f705368" style="width: 100%; height: 100%; border: 1px solid #ccc; background-color: #f9f9f9;">
                <div style="padding: 20px; text-align: center; color: #666;">Loading graph...</div>
            </div>
        </div>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script>
        // utils/CoordinateTransform.js
/**
 * Coordinate Transformation Utilities for Knowledge Graph Explorer
 * Handles coordinate transformations between screen space and graph space
 * Provides clean abstraction for zoom/pan coordinate calculations
 */
class CoordinateTransform {
  constructor() {
    this.currentTransform = d3.zoomIdentity;
    this.viewportWidth = 800;
    this.viewportHeight = 600;
  }
  /**
   * Update the current transform (called during zoom events)
   * @param {Object} transform - D3 zoom transform object
   */
  updateTransform(transform) {
    this.currentTransform = transform;
  }
  /**
   * Update viewport dimensions
   * @param {number} width - Viewport width
   * @param {number} height - Viewport height
   */
  updateViewport(width, height) {
    this.viewportWidth = width;
    this.viewportHeight = height;
  }
  /**
   * Convert screen coordinates to graph coordinates
   * @param {Array|Object} screenPosition - [x, y] array or {x, y} object in screen space
   * @param {Object} transform - Optional transform override
   * @returns {Object} - {x, y} in graph space
   */
  screenToGraph(screenPosition, transform = null) {
    const t = transform || this.currentTransform;
    // Handle both array and object input
    const screenX = Array.isArray(screenPosition) ? screenPosition[0] : screenPosition.x;
    const screenY = Array.isArray(screenPosition) ? screenPosition[1] : screenPosition.y;
    return {
      x: (screenX - t.x) / t.k,
      y: (screenY - t.y) / t.k
    };
  }
  /**
   * Convert graph coordinates to screen coordinates
   * @param {Object|Array} graphPosition - {x, y} object or [x, y] array in graph space
   * @param {Object} transform - Optional transform override
   * @returns {Array} - [x, y] in screen space
   */
  graphToScreen(graphPosition, transform = null) {
    const t = transform || this.currentTransform;
    // Handle both object and array input
    const graphX = Array.isArray(graphPosition) ? graphPosition[0] : graphPosition.x;
    const graphY = Array.isArray(graphPosition) ? graphPosition[1] : graphPosition.y;
    return [
      graphX * t.k + t.x,
      graphY * t.k + t.y
    ];
  }
  /**
   * Convert screen coordinates relative to SVG element to graph coordinates
   * Useful for mouse event handling
   * @param {Event} event - Mouse event
   * @param {Element} svgElement - SVG DOM element
   * @param {Object} transform - Optional transform override
   * @returns {Object} - {x, y} in graph space
   */
  eventToGraph(event, svgElement, transform = null) {
    const [svgX, svgY] = d3.pointer(event, svgElement);
    return this.screenToGraph([svgX, svgY], transform);
  }
  /**
   * Calculate Euclidean distance between two points
   * @param {Object} point1 - {x, y} coordinates
   * @param {Object} point2 - {x, y} coordinates
   * @returns {number} - Distance between points
   */
  calculateDistance(point1, point2) {
    const dx = point1.x - point2.x;
    const dy = point1.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   * Calculate distance between a point and multiple targets, return closest
   * @param {Object} point - {x, y} source point
   * @param {Array} targets - Array of {x, y} target points with id property
   * @param {number} maxDistance - Maximum distance to consider
   * @returns {Object|null} - Closest target with distance, or null if none within maxDistance
   */
  findClosestPoint(point, targets, maxDistance = Infinity) {
    let closest = null;
    let minDistance = maxDistance;
    targets.forEach(target => {
      const distance = this.calculateDistance(point, target);
      if (distance < minDistance) {
        minDistance = distance;
        closest = { target, distance };
      }
    });
    return closest;
  }
  /**
   * Get the current zoom scale
   * @returns {number} - Current zoom scale factor
   */
  getScale() {
    return this.currentTransform.k;
  }
  /**
   * Get the current translation
   * @returns {Object} - {x, y} translation offset
   */
  getTranslation() {
    return {
      x: this.currentTransform.x,
      y: this.currentTransform.y
    };
  }
  /**
   * Get complete transform information
   * @returns {Object} - Full transform state
   */
  getTransform() {
    return {
      x: this.currentTransform.x,
      y: this.currentTransform.y,
      k: this.currentTransform.k,
      scale: this.currentTransform.k,
      translation: this.getTranslation()
    };
  }
  /**
   * Check if a point in graph space is visible in the current viewport
   * @param {Object} graphPosition - {x, y} in graph space
   * @param {number} margin - Optional margin for visibility check (in screen pixels)
   * @returns {boolean} - True if visible in viewport
   */
  isVisible(graphPosition, margin = 0) {
    const [screenX, screenY] = this.graphToScreen(graphPosition);
    return screenX >= -margin && 
           screenX <= this.viewportWidth + margin && 
           screenY >= -margin && 
           screenY <= this.viewportHeight + margin;
  }
  /**
   * Get the visible bounds of the current viewport in graph coordinates
   * @param {number} margin - Optional margin to expand bounds (in screen pixels)
   * @returns {Object} - {minX, maxX, minY, maxY, width, height} in graph space
   */
  getVisibleBounds(margin = 0) {
    const topLeft = this.screenToGraph([-margin, -margin]);
    const bottomRight = this.screenToGraph([
      this.viewportWidth + margin, 
      this.viewportHeight + margin
    ]);
    return {
      minX: topLeft.x,
      maxX: bottomRight.x,
      minY: topLeft.y,
      maxY: bottomRight.y,
      width: bottomRight.x - topLeft.x,
      height: bottomRight.y - topLeft.y
    };
  }
  /**
   * Apply zoom-aware scaling to a value
   * @param {number} value - Original value
   * @param {boolean} inverse - If true, scale inversely with zoom (useful for maintaining visual size)
   * @returns {number} - Scaled value
   */
  scaleValue(value, inverse = false) {
    return inverse ? value / this.currentTransform.k : value * this.currentTransform.k;
  }
  /**
   * Scale a radius or size value to maintain consistent visual appearance across zoom levels
   * @param {number} baseValue - Base size value
   * @param {number} minScale - Minimum scale factor (prevents elements from becoming too small)
   * @param {number} maxScale - Maximum scale factor (prevents elements from becoming too large)
   * @returns {number} - Zoom-adjusted value
   */
  scaleVisualSize(baseValue, minScale = 0.5, maxScale = 2.0) {
    const scale = Math.max(minScale, Math.min(maxScale, 1 / this.currentTransform.k));
    return baseValue * scale;
  }
  /**
   * Calculate appropriate font size for current zoom level
   * @param {number} baseFontSize - Base font size in pixels
   * @param {number} minSize - Minimum readable size
   * @param {number} maxSize - Maximum size to prevent overflow
   * @returns {number} - Zoom-appropriate font size
   */
  scaleFontSize(baseFontSize, minSize = 8, maxSize = 24) {
    const scale = 1 / this.currentTransform.k;
    const scaledSize = baseFontSize * scale;
    return Math.max(minSize, Math.min(maxSize, scaledSize));
  }
  /**
   * Check if a circular area is visible in the viewport
   * @param {Object} center - {x, y} center point in graph space
   * @param {number} radius - Radius in graph space
   * @returns {boolean} - True if any part of the circle is visible
   */
  isCircleVisible(center, radius) {
    const bounds = this.getVisibleBounds();
    // Check if circle overlaps with viewport rectangle
    const closestX = Math.max(bounds.minX, Math.min(center.x, bounds.maxX));
    const closestY = Math.max(bounds.minY, Math.min(center.y, bounds.maxY));
    const distance = this.calculateDistance(center, { x: closestX, y: closestY });
    return distance <= radius;
  }
  /**
   * Create a transform that centers a specific point in the viewport
   * @param {Object} graphPoint - {x, y} point to center in graph space
   * @param {number} scale - Desired zoom scale (optional, defaults to current scale)
   * @returns {Object} - D3 transform object that centers the point
   */
  createCenteringTransform(graphPoint, scale = null) {
    const targetScale = scale !== null ? scale : this.currentTransform.k;
    const centerX = this.viewportWidth / 2;
    const centerY = this.viewportHeight / 2;
    return d3.zoomIdentity
      .translate(centerX - graphPoint.x * targetScale, centerY - graphPoint.y * targetScale)
      .scale(targetScale);
  }
  /**
   * Create a transform that fits a bounding box within the viewport
   * @param {Object} bounds - {minX, maxX, minY, maxY} in graph space
   * @param {number} padding - Padding as percentage of viewport (0.0 to 1.0)
   * @returns {Object} - D3 transform object that fits the bounds
   */
  createFittingTransform(bounds, padding = 0.1) {
    const contentWidth = bounds.maxX - bounds.minX;
    const contentHeight = bounds.maxY - bounds.minY;
    const availableWidth = this.viewportWidth * (1 - padding);
    const availableHeight = this.viewportHeight * (1 - padding);
    const scaleX = availableWidth / contentWidth;
    const scaleY = availableHeight / contentHeight;
    const scale = Math.min(scaleX, scaleY);
    const centerX = (bounds.minX + bounds.maxX) / 2;
    const centerY = (bounds.minY + bounds.maxY) / 2;
    return this.createCenteringTransform({ x: centerX, y: centerY }, scale);
  }
  /**
   * Reset transform to identity (no zoom, no pan)
   * @returns {Object} - Identity transform
   */
  resetTransform() {
    this.currentTransform = d3.zoomIdentity;
    return d3.zoomIdentity;
  }
  /**
   * Interpolate between two transforms for smooth animations
   * @param {Object} fromTransform - Starting transform
   * @param {Object} toTransform - Ending transform
   * @param {number} t - Interpolation factor (0.0 to 1.0)
   * @returns {Object} - Interpolated transform
   */
  interpolateTransform(fromTransform, toTransform, t) {
    return d3.zoomIdentity
      .translate(
        fromTransform.x + (toTransform.x - fromTransform.x) * t,
        fromTransform.y + (toTransform.y - fromTransform.y) * t
      )
      .scale(fromTransform.k + (toTransform.k - fromTransform.k) * t);
  }
}
// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = CoordinateTransform;
} else if (typeof window !== 'undefined') {
  window.CoordinateTransform = CoordinateTransform;
}
// utils/DataValidator.js
/**
 * Data Validation Utilities for Knowledge Graph Explorer
 * Validates node and link data structures, ensures data integrity
 */
class DataValidator {
  constructor() {
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Validate complete graph data structure
   * @param {Object} data - Graph data with nodes and links
   * @returns {Object} - Validation result with isValid, errors, warnings
   */
  validateGraphData(data) {
    this.errors = [];
    this.warnings = [];
    if (!data) {
      this.errors.push('Graph data is null or undefined');
      return this.getValidationResult();
    }
    if (!data.nodes || !Array.isArray(data.nodes)) {
      this.errors.push('Graph data must contain a nodes array');
      return this.getValidationResult();
    }
    if (!data.links || !Array.isArray(data.links)) {
      this.errors.push('Graph data must contain a links array');
      return this.getValidationResult();
    }
    // Validate nodes
    const nodeIds = new Set();
    data.nodes.forEach((node, index) => {
      this.validateNode(node, index, nodeIds);
    });
    // Validate links
    data.links.forEach((link, index) => {
      this.validateLink(link, index, nodeIds);
    });
    return this.getValidationResult();
  }
  /**
   * Validate individual node structure
   * @param {Object} node - Node data
   * @param {number} index - Node index in array
   * @param {Set} nodeIds - Set of existing node IDs
   */
  validateNode(node, index, nodeIds) {
    const nodeRef = `Node ${index}`;
    // Required fields
    if (!node.id) {
      this.errors.push(`${nodeRef}: Missing required field 'id'`);
      return;
    }
    if (typeof node.id !== 'string') {
      this.errors.push(`${nodeRef}: 'id' must be a string`);
    }
    if (nodeIds.has(node.id)) {
      this.errors.push(`${nodeRef}: Duplicate node ID '${node.id}'`);
    } else {
      nodeIds.add(node.id);
    }
    if (!node.label) {
      this.errors.push(`${nodeRef} (${node.id}): Missing required field 'label'`);
    }
    if (!node.type) {
      this.warnings.push(`${nodeRef} (${node.id}): Missing 'type' field, will use default`);
    }
    if (!node.layer) {
      this.warnings.push(`${nodeRef} (${node.id}): Missing 'layer' field, may affect layer functionality`);
    }
    // Optional field validation
    if (node.size !== undefined && (typeof node.size !== 'number' || node.size <= 0)) {
      this.errors.push(`${nodeRef} (${node.id}): 'size' must be a positive number`);
    }
    if (node.timespan) {
      this.validateTimespan(node.timespan, `${nodeRef} (${node.id})`);
    }
    if (node.links && !Array.isArray(node.links)) {
      this.errors.push(`${nodeRef} (${node.id}): 'links' must be an array`);
    }
    if (node.position && (!node.position.x || !node.position.y)) {
      this.warnings.push(`${nodeRef} (${node.id}): 'position' should have both x and y coordinates`);
    }
  }
  /**
   * Validate individual link structure
   * @param {Object} link - Link data
   * @param {number} index - Link index in array
   * @param {Set} nodeIds - Set of valid node IDs
   */
  validateLink(link, index, nodeIds) {
    const linkRef = `Link ${index}`;
    // Required fields
    if (!link.source) {
      this.errors.push(`${linkRef}: Missing required field 'source'`);
      return;
    }
    if (!link.target) {
      this.errors.push(`${linkRef}: Missing required field 'target'`);
      return;
    }
    // Check if source and target nodes exist
    if (!nodeIds.has(link.source)) {
      this.errors.push(`${linkRef}: Source node '${link.source}' does not exist`);
    }
    if (!nodeIds.has(link.target)) {
      this.errors.push(`${linkRef}: Target node '${link.target}' does not exist`);
    }
    // Self-loops warning
    if (link.source === link.target) {
      this.warnings.push(`${linkRef}: Self-loop detected (${link.source} -> ${link.target})`);
    }
    // Optional field validation
    if (link.strength !== undefined) {
      if (typeof link.strength !== 'number' || link.strength < 0 || link.strength > 1) {
        this.errors.push(`${linkRef}: 'strength' must be a number between 0 and 1`);
      }
    }
  }
  /**
   * Validate timespan structure
   * @param {Object} timespan - Timespan data
   * @param {string} context - Context for error messages
   */
  validateTimespan(timespan, context) {
    if (typeof timespan !== 'object') {
      this.errors.push(`${context}: 'timespan' must be an object`);
      return;
    }
    if (timespan.start !== undefined) {
      if (!Number.isInteger(timespan.start) || timespan.start < 1900 || timespan.start > 2100) {
        this.errors.push(`${context}: 'timespan.start' must be a valid year (1900-2100)`);
      }
    }
    if (timespan.end !== undefined && timespan.end !== null) {
      if (!Number.isInteger(timespan.end) || timespan.end < 1900 || timespan.end > 2100) {
        this.errors.push(`${context}: 'timespan.end' must be a valid year (1900-2100) or null`);
      }
      if (timespan.start && timespan.end && timespan.end < timespan.start) {
        this.errors.push(`${context}: 'timespan.end' cannot be before 'timespan.start'`);
      }
    }
  }
  /**
   * Validate configuration object
   * @param {Object} config - Configuration object
   * @returns {Object} - Validation result
   */
  validateConfig(config) {
    this.errors = [];
    this.warnings = [];
    if (!config) {
      this.errors.push('Configuration is null or undefined');
      return this.getValidationResult();
    }
    // Validate dimensions
    if (config.width !== undefined && (typeof config.width !== 'number' || config.width <= 0)) {
      this.errors.push('width must be a positive number');
    }
    if (config.height !== undefined && (typeof config.height !== 'number' || config.height <= 0)) {
      this.errors.push('height must be a positive number');
    }
    // Validate colors
    const colorFields = ['background', 'textColor', 'linkColor'];
    colorFields.forEach(field => {
      if (config[field] !== undefined && !this.isValidColor(config[field])) {
        this.warnings.push(`${field} may not be a valid CSS color`);
      }
    });
    // Validate layers
    if (config.layers) {
      if (!Array.isArray(config.layers)) {
        this.errors.push('layers must be an array');
      } else {
        config.layers.forEach((layer, index) => {
          this.validateLayer(layer, index);
        });
      }
    }
    // Validate timeline
    if (config.timeline) {
      this.validateTimelineConfig(config.timeline);
    }
    return this.getValidationResult();
  }
  /**
   * Validate layer configuration
   * @param {Object} layer - Layer configuration
   * @param {number} index - Layer index
   */
  validateLayer(layer, index) {
    const layerRef = `Layer ${index}`;
    if (!layer.id) {
      this.errors.push(`${layerRef}: Missing required field 'id'`);
    }
    if (!layer.name) {
      this.errors.push(`${layerRef}: Missing required field 'name'`);
    }
    if (!layer.color) {
      this.warnings.push(`${layerRef}: Missing 'color' field`);
    } else if (!this.isValidColor(layer.color)) {
      this.warnings.push(`${layerRef}: 'color' may not be a valid CSS color`);
    }
  }
  /**
   * Validate timeline configuration
   * @param {Object} timeline - Timeline configuration
   */
  validateTimelineConfig(timeline) {
    if (typeof timeline !== 'object') {
      this.errors.push('timeline must be an object');
      return;
    }
    if (timeline.start !== undefined) {
      if (!Number.isInteger(timeline.start)) {
        this.errors.push('timeline.start must be an integer year');
      }
    }
    if (timeline.end !== undefined) {
      if (!Number.isInteger(timeline.end)) {
        this.errors.push('timeline.end must be an integer year');
      }
    }
    if (timeline.start && timeline.end && timeline.end < timeline.start) {
      this.errors.push('timeline.end cannot be before timeline.start');
    }
  }
  /**
   * Basic CSS color validation
   * @param {string} color - Color string to validate
   * @returns {boolean} - Whether color appears valid
   */
  isValidColor(color) {
    if (typeof color !== 'string') return false;
    // Check for common CSS color formats
    const hexRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    const rgbRegex = /^rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/;
    const rgbaRegex = /^rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*[01]?\.?\d*\s*\)$/;
    const namedColors = ['red', 'blue', 'green', 'black', 'white', 'yellow', 'purple', 'orange', 'pink', 'brown', 'gray', 'grey'];
    return hexRegex.test(color) || 
           rgbRegex.test(color) || 
           rgbaRegex.test(color) || 
           namedColors.includes(color.toLowerCase());
  }
  /**
   * Get validation result summary
   * @returns {Object} - Validation result with isValid, errors, warnings
   */
  getValidationResult() {
    return {
      isValid: this.errors.length === 0,
      errors: [...this.errors],
      warnings: [...this.warnings],
      hasWarnings: this.warnings.length > 0
    };
  }
  /**
   * Static method for quick validation
   * @param {Object} data - Data to validate
   * @returns {Object} - Validation result
   */
  static validate(data) {
    const validator = new DataValidator();
    return validator.validateGraphData(data);
  }
  /**
   * Static method for quick config validation
   * @param {Object} config - Config to validate
   * @returns {Object} - Validation result
   */
  static validateConfiguration(config) {
    const validator = new DataValidator();
    return validator.validateConfig(config);
  }
}
// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = DataValidator;
} else if (typeof window !== 'undefined') {
  window.DataValidator = DataValidator;
}
// core/ForceSimulation.js
/**
 * Force Simulation Manager for Knowledge Graph Explorer
 * Handles D3 force simulation setup, configuration, and lifecycle management
 */
class ForceSimulation {
  constructor(config = {}) {
    this.config = {
      width: 800,
      height: 600,
      // Force strengths
      linkDistance: 80,
      linkStrength: 0.7,
      chargeStrength: -400,
      chargeDistanceMax: 500,
      collisionRadius: 25,
      centerStrength: 1,
      // Simulation parameters
      alphaMin: 0.001,
      alphaDecay: 0.0228,
      velocityDecay: 0.4,
      ...config
    };
    this.simulation = null;
    this.nodes = [];
    this.links = [];
    this.isRunning = false;
    // Event callbacks
    this.onTick = null;
    this.onEnd = null;
    this.setupSimulation();
  }
  /**
   * Initialize the D3 force simulation with default forces
   */
  setupSimulation() {
    const centerX = this.config.width / 2;
    const centerY = this.config.height / 2;
    this.simulation = d3.forceSimulation()
      .alphaMin(this.config.alphaMin)
      .alphaDecay(this.config.alphaDecay)
      .velocityDecay(this.config.velocityDecay)
      .on('tick', () => {
        if (this.onTick) {
          this.onTick(this.simulation);
        }
      })
      .on('end', () => {
        this.isRunning = false;
        if (this.onEnd) {
          this.onEnd(this.simulation);
        }
      });
    // Setup default forces
    this.setupForces(centerX, centerY);
  }
  /**
   * Configure all simulation forces
   * @param {number} centerX - Center X coordinate
   * @param {number} centerY - Center Y coordinate
   */
  setupForces(centerX, centerY) {
    // Link force - attracts connected nodes
    this.simulation.force('link', d3.forceLink()
      .id(d => d.id)
      .distance(d => this.getLinkDistance(d))
      .strength(d => this.getLinkStrength(d))
    );
    // Charge force - repels nodes from each other
    this.simulation.force('charge', d3.forceManyBody()
      .strength(d => this.getChargeStrength(d))
      .distanceMax(this.config.chargeDistanceMax)
    );
    // Center force - attracts nodes toward center
    this.simulation.force('center', d3.forceCenter(centerX, centerY)
      .strength(this.config.centerStrength)
    );
    // Collision force - prevents node overlap
    this.simulation.force('collision', d3.forceCollide()
      .radius(d => this.getCollisionRadius(d))
      .strength(0.8)
      .iterations(2)
    );
  }
  /**
   * Calculate link distance for a specific link
   * @param {Object} link - Link data
   * @returns {number} - Distance value
   */
  getLinkDistance(link) {
    if (link.distance !== undefined) {
      return link.distance;
    }
    // Adjust distance based on link strength
    const baseDistance = this.config.linkDistance;
    const strength = link.strength || 0.5;
    // Stronger connections should be closer
    return baseDistance * (1.5 - strength);
  }
  /**
   * Calculate link strength for a specific link
   * @param {Object} link - Link data
   * @returns {number} - Strength value (0-1)
   */
  getLinkStrength(link) {
    if (link.strength !== undefined) {
      return link.strength * this.config.linkStrength;
    }
    return this.config.linkStrength;
  }
  /**
   * Calculate charge (repulsion) strength for a specific node
   * @param {Object} node - Node data
   * @returns {number} - Negative charge strength
   */
  getChargeStrength(node) {
    const baseStrength = this.config.chargeStrength;
    const size = node.size || 10;
    // Larger nodes should have stronger repulsion
    const sizeMultiplier = Math.sqrt(size / 10);
    return baseStrength * sizeMultiplier;
  }
  /**
   * Calculate collision radius for a specific node
   * @param {Object} node - Node data
   * @returns {number} - Collision radius
   */
  getCollisionRadius(node) {
    const nodeRadius = node.size || 10;
    return nodeRadius + this.config.collisionRadius;
  }
  /**
   * Update simulation data and restart if needed
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   * @param {boolean} restart - Whether to restart the simulation
   */
  updateData(nodes, links, restart = true) {
    this.nodes = nodes || [];
    this.links = links || [];
    // Update simulation nodes and links
    this.simulation.nodes(this.nodes);
    const linkForce = this.simulation.force('link');
    if (linkForce) {
      linkForce.links(this.links);
    }
    if (restart) {
      this.restart();
    }
  }
  /**
   * Start or restart the simulation
   * @param {number} alpha - Initial alpha value (energy level)
   */
  restart(alpha = 1) {
    if (this.simulation) {
      this.isRunning = true;
      this.simulation.alpha(alpha).restart();
    }
  }
  /**
   * Stop the simulation
   */
  stop() {
    if (this.simulation) {
      this.isRunning = false;
      this.simulation.stop();
    }
  }
  /**
   * Pause/resume the simulation
   */
  toggle() {
    if (this.isRunning) {
      this.stop();
    } else {
      this.restart();
    }
  }
  /**
   * Update the center point of the simulation
   * @param {number} x - New center X coordinate
   * @param {number} y - New center Y coordinate
   */
  updateCenter(x, y) {
    const centerForce = this.simulation.force('center');
    if (centerForce) {
      centerForce.x(x).y(y);
    }
  }
  /**
   * Update simulation dimensions and recalculate center
   * @param {number} width - New width
   * @param {number} height - New height
   */
  updateDimensions(width, height) {
    this.config.width = width;
    this.config.height = height;
    this.updateCenter(width / 2, height / 2);
  }
  /**
   * Apply custom positioning to specific nodes
   * @param {Array} nodePositions - Array of {id, x, y} objects
   * @param {boolean} fix - Whether to fix these positions
   */
  setNodePositions(nodePositions, fix = false) {
    const positionMap = new Map();
    nodePositions.forEach(pos => {
      positionMap.set(pos.id, pos);
    });
    this.nodes.forEach(node => {
      const position = positionMap.get(node.id);
      if (position) {
        node.x = position.x;
        node.y = position.y;
        if (fix) {
          node.fx = position.x;
          node.fy = position.y;
        }
      }
    });
  }
  /**
   * Release fixed positions for specified nodes
   * @param {Array} nodeIds - Array of node IDs to unfix
   */
  unfixNodes(nodeIds = null) {
    const toUnfix = nodeIds ? new Set(nodeIds) : null;
    this.nodes.forEach(node => {
      if (!toUnfix || toUnfix.has(node.id)) {
        node.fx = null;
        node.fy = null;
      }
    });
  }
  /**
   * Fix a node at its current position
   * @param {string} nodeId - ID of node to fix
   */
  fixNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node.x !== undefined && node.y !== undefined) {
      node.fx = node.x;
      node.fy = node.y;
    }
  }
  /**
   * Temporarily increase simulation energy for layout adjustments
   * @param {number} alpha - Energy level (0-1)
   */
  reheat(alpha = 0.3) {
    if (this.simulation) {
      this.simulation.alpha(alpha).restart();
    }
  }
  /**
   * Configure force strengths dynamically
   * @param {Object} forceConfig - Object with force configuration
   */
  updateForceStrengths(forceConfig) {
    Object.assign(this.config, forceConfig);
    // Update existing forces
    const linkForce = this.simulation.force('link');
    if (linkForce && forceConfig.linkDistance !== undefined) {
      linkForce.distance(d => this.getLinkDistance(d));
    }
    if (linkForce && forceConfig.linkStrength !== undefined) {
      linkForce.strength(d => this.getLinkStrength(d));
    }
    const chargeForce = this.simulation.force('charge');
    if (chargeForce && forceConfig.chargeStrength !== undefined) {
      chargeForce.strength(d => this.getChargeStrength(d));
    }
    const collisionForce = this.simulation.force('collision');
    if (collisionForce && forceConfig.collisionRadius !== undefined) {
      collisionForce.radius(d => this.getCollisionRadius(d));
    }
    // Reheat to apply changes
    if (this.isRunning) {
      this.reheat();
    }
  }
  /**
   * Add custom force to the simulation
   * @param {string} name - Force name
   * @param {Function} force - D3 force function
   */
  addCustomForce(name, force) {
    if (this.simulation) {
      this.simulation.force(name, force);
    }
  }
  /**
   * Remove a force from the simulation
   * @param {string} name - Force name to remove
   */
  removeForce(name) {
    if (this.simulation) {
      this.simulation.force(name, null);
    }
  }
  /**
   * Get current simulation statistics
   * @returns {Object} - Simulation state information
   */
  getStats() {
    if (!this.simulation) {
      return null;
    }
    // Get forces by checking what forces are actually set
    const forces = [];
    const forceNames = ['link', 'charge', 'center', 'collision'];
    forceNames.forEach(name => {
      if (this.simulation.force(name)) {
        forces.push(name);
      }
    });
    // Check for any additional forces by trying common custom force names
    // This is a workaround since D3's internal _forces is not reliable
    const customForceNames = ['customX', 'customY', 'radial', 'x', 'y'];
    customForceNames.forEach(name => {
      if (this.simulation.force(name)) {
        forces.push(name);
      }
    });
    return {
      alpha: this.simulation.alpha(),
      alphaMin: this.simulation.alphaMin(),
      alphaTarget: this.simulation.alphaTarget(),
      isRunning: this.isRunning,
      nodeCount: this.nodes.length,
      linkCount: this.links.length,
      forces: forces,
      velocityDecay: this.simulation.velocityDecay()
    };
  }
  /**
   * Set tick callback function
   * @param {Function} callback - Function to call on each tick
   */
  onTickCallback(callback) {
    this.onTick = callback;
  }
  /**
   * Set end callback function
   * @param {Function} callback - Function to call when simulation ends
   */
  onEndCallback(callback) {
    this.onEnd = callback;
  }
  /**
   * Calculate the bounds of all nodes
   * @param {number} padding - Padding around the bounds
   * @returns {Object} - Bounds object {minX, maxX, minY, maxY, width, height}
   */
  getNodeBounds(padding = 0) {
    if (this.nodes.length === 0) {
      return null;
    }
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        const radius = (node.size || 10) + padding;
        minX = Math.min(minX, node.x - radius);
        maxX = Math.max(maxX, node.x + radius);
        minY = Math.min(minY, node.y - radius);
        maxY = Math.max(maxY, node.y + radius);
      }
    });
    if (minX === Infinity) {
      return null;
    }
    return {
      minX, maxX, minY, maxY,
      width: maxX - minX,
      height: maxY - minY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }
  /**
   * Apply a layout preset
   * @param {string} layoutType - Type of layout ('circle', 'grid', 'random')
   * @param {Object} options - Layout-specific options
   */
  applyLayout(layoutType, options = {}) {
    const { width = this.config.width, height = this.config.height } = options;
    const centerX = width / 2;
    const centerY = height / 2;
    switch (layoutType) {
      case 'circle':
        this.applyCircleLayout(centerX, centerY, options);
        break;
      case 'grid':
        this.applyGridLayout(width, height, options);
        break;
      case 'random':
        this.applyRandomLayout(width, height, options);
        break;
      default:
        console.warn(`Unknown layout type: ${layoutType}`);
    }
    this.reheat();
  }
  /**
   * Apply circular layout
   * @param {number} centerX - Center X coordinate
   * @param {number} centerY - Center Y coordinate
   * @param {Object} options - Layout options
   */
  applyCircleLayout(centerX, centerY, options = {}) {
    const { radius = Math.min(this.config.width, this.config.height) / 3 } = options;
    const angleStep = (2 * Math.PI) / this.nodes.length;
    this.nodes.forEach((node, index) => {
      const angle = index * angleStep;
      node.x = centerX + radius * Math.cos(angle);
      node.y = centerY + radius * Math.sin(angle);
    });
  }
  /**
   * Apply grid layout
   * @param {number} width - Layout width
   * @param {number} height - Layout height
   * @param {Object} options - Layout options
   */
  applyGridLayout(width, height, options = {}) {
    const { padding = 50 } = options;
    const cols = Math.ceil(Math.sqrt(this.nodes.length));
    const rows = Math.ceil(this.nodes.length / cols);
    const cellWidth = (width - 2 * padding) / cols;
    const cellHeight = (height - 2 * padding) / rows;
    this.nodes.forEach((node, index) => {
      const col = index % cols;
      const row = Math.floor(index / cols);
      node.x = padding + col * cellWidth + cellWidth / 2;
      node.y = padding + row * cellHeight + cellHeight / 2;
    });
  }
  /**
   * Apply random layout
   * @param {number} width - Layout width
   * @param {number} height - Layout height
   * @param {Object} options - Layout options
   */
  applyRandomLayout(width, height, options = {}) {
    const { padding = 50 } = options;
    this.nodes.forEach(node => {
      node.x = padding + Math.random() * (width - 2 * padding);
      node.y = padding + Math.random() * (height - 2 * padding);
    });
  }
  /**
   * Cleanup and destroy the simulation
   */
  destroy() {
    if (this.simulation) {
      this.simulation.stop();
      this.simulation = null;
    }
    this.nodes = [];
    this.links = [];
    this.onTick = null;
    this.onEnd = null;
  }
}
// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ForceSimulation;
} else if (typeof window !== 'undefined') {
  window.ForceSimulation = ForceSimulation;
}
// core/InteractionManager.js
/**
 * Interaction Manager for Knowledge Graph Explorer
 * Handles mouse/touch interactions, hover effects, and event dispatching
 */
class InteractionManager {
  constructor(config = {}) {
    this.config = {
      hoverRadius: 50,
      maxHoverScale: 1.3,
      hoverTransitionDuration: 100,
      clickRadius: 20,
      doubleClickDelay: 300,
      dragThreshold: 5,
      ...config
    };
    // State
    this.nodes = [];
    this.links = [];
    this.coordinateTransform = null;
    this.isInLayerMode = false;
    this.hoveredNode = null;
    this.draggedNode = null;
    this.isDragging = false;
    this.lastClickTime = 0;
    this.lastClickNode = null;
    // DOM elements
    this.svgElement = null;
    this.nodeElements = null;
    this.linkElements = null;
    this.labelElements = null;
    // Event handlers
    this.eventHandlers = {};
    this.boundHandlers = {};
    this.setupBoundHandlers();
  }
  /**
   * Initialize interaction manager with DOM elements and coordinate transform
   * @param {Object} elements - Object containing SVG and D3 selections
   * @param {CoordinateTransform} coordinateTransform - Coordinate transformation utility
   */
  initialize(elements, coordinateTransform) {
    this.svgElement = elements.svg;
    this.nodeElements = elements.nodes;
    this.linkElements = elements.links;
    this.labelElements = elements.labels;
    this.coordinateTransform = coordinateTransform;
    this.setupEventListeners();
  }
  /**
   * Create bound handler functions to avoid memory leaks
   */
  setupBoundHandlers() {
    this.boundHandlers = {
      mousemove: this.handleMouseMove.bind(this),
      mouseleave: this.handleMouseLeave.bind(this),
      click: this.handleClick.bind(this),
      mousedown: this.handleMouseDown.bind(this),
      mouseup: this.handleMouseUp.bind(this),
      contextmenu: this.handleContextMenu.bind(this)
    };
  }
  /**
   * Setup event listeners on the SVG element
   */
  setupEventListeners() {
    if (!this.svgElement) return;
    // Mouse/touch events
    this.svgElement.on('mousemove', this.boundHandlers.mousemove);
    this.svgElement.on('mouseleave', this.boundHandlers.mouseleave);
    this.svgElement.on('click', this.boundHandlers.click);
    this.svgElement.on('mousedown', this.boundHandlers.mousedown);
    this.svgElement.on('mouseup', this.boundHandlers.mouseup);
    this.svgElement.on('contextmenu', this.boundHandlers.contextmenu);
    // Setup node-specific interactions
    this.setupNodeInteractions();
    this.setupLinkInteractions();
  }
  /**
   * Setup interactions specific to nodes
   */
  setupNodeInteractions() {
    if (!this.nodeElements) return;
    this.nodeElements
      .style('cursor', 'pointer')
      .on('click', (event, d) => {
        event.stopPropagation();
        this.handleNodeClick(event, d);
      })
      .on('mousedown', (event, d) => {
        event.stopPropagation();
        this.handleNodeMouseDown(event, d);
      })
      .on('mouseenter', (event, d) => {
        this.handleNodeMouseEnter(event, d);
      })
      .on('mouseleave', (event, d) => {
        this.handleNodeMouseLeave(event, d);
      });
  }
  /**
   * Setup interactions specific to links
   */
  setupLinkInteractions() {
    if (!this.linkElements) return;
    this.linkElements
      .style('cursor', 'pointer')
      .on('click', (event, d) => {
        event.stopPropagation();
        this.handleLinkClick(event, d);
      })
      .on('mouseenter', (event, d) => {
        this.handleLinkMouseEnter(event, d);
      })
      .on('mouseleave', (event, d) => {
        this.handleLinkMouseLeave(event, d);
      });
  }
  /**
   * Update data references
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   */
  updateData(nodes, links) {
    this.nodes = nodes || [];
    this.links = links || [];
  }
  /**
   * Update layer mode state
   * @param {boolean} isInLayerMode - Whether layer mode is active
   */
  updateLayerMode(isInLayerMode) {
    this.isInLayerMode = isInLayerMode;
  }
  /**
   * Handle mouse movement over the SVG
   * @param {Event} event - Mouse event
   */
  handleMouseMove(event) {
    if (this.isDragging) {
      this.handleDragMove(event);
      return;
    }
    if (this.isInLayerMode) return;
    // Get mouse position in graph coordinates
    const mousePos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    this.updateContinuousHoverEffects(mousePos);
  }
  /**
   * Handle mouse leaving the SVG area
   * @param {Event} event - Mouse event
   */
  handleMouseLeave(event) {
    this.resetHoverEffects();
    if (this.isDragging) {
      this.endDrag();
    }
  }
  /**
   * Handle click events on the SVG background
   * @param {Event} event - Mouse event
   */
  handleClick(event) {
    // Only handle background clicks (not propagated from nodes/links)
    this.emit('backgroundClick', { event });
  }
  /**
   * Handle mouse down events for drag initiation
   * @param {Event} event - Mouse event
   */
  handleMouseDown(event) {
    if (event.button !== 0) return; // Only left mouse button
    const mousePos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    const clickedNode = this.findNodeAtPosition(mousePos);
    if (clickedNode) {
      this.startDrag(event, clickedNode);
    }
  }
  /**
   * Handle mouse up events
   * @param {Event} event - Mouse event
   */
  handleMouseUp(event) {
    if (this.isDragging) {
      this.endDrag();
    }
  }
  /**
   * Handle context menu (right-click) events
   * @param {Event} event - Mouse event
   */
  handleContextMenu(event) {
    event.preventDefault();
    const mousePos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    const clickedNode = this.findNodeAtPosition(mousePos);
    if (clickedNode) {
      this.emit('nodeContextMenu', { node: clickedNode, event });
    } else {
      this.emit('backgroundContextMenu', { event });
    }
  }
  /**
   * Handle node click events
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeClick(event, node) {
    const currentTime = Date.now();
    const isDoubleClick = (currentTime - this.lastClickTime < this.config.doubleClickDelay) && 
                         (this.lastClickNode === node);
    if (isDoubleClick) {
      this.emit('nodeDoubleClick', { node, event });
    } else {
      this.emit('nodeClick', { node, event });
    }
    this.lastClickTime = currentTime;
    this.lastClickNode = node;
  }
  /**
   * Handle node mouse down for drag initiation
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeMouseDown(event, node) {
    this.startDrag(event, node);
  }
  /**
   * Handle node mouse enter
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeMouseEnter(event, node) {
    this.emit('nodeMouseEnter', { node, event });
  }
  /**
   * Handle node mouse leave
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeMouseLeave(event, node) {
    this.emit('nodeMouseLeave', { node, event });
  }
  /**
   * Handle link click events
   * @param {Event} event - Mouse event
   * @param {Object} link - Link data
   */
  handleLinkClick(event, link) {
    this.emit('linkClick', { link, event });
  }
  /**
   * Handle link mouse enter
   * @param {Event} event - Mouse event
   * @param {Object} link - Link data
   */
  handleLinkMouseEnter(event, link) {
    this.emit('linkMouseEnter', { link, event });
  }
  /**
   * Handle link mouse leave
   * @param {Event} event - Mouse event
   * @param {Object} link - Link data
   */
  handleLinkMouseLeave(event, link) {
    this.emit('linkMouseLeave', { link, event });
  }
  /**
   * Start drag operation
   * @param {Event} event - Mouse event
   * @param {Object} node - Node being dragged
   */
  startDrag(event, node) {
    this.draggedNode = node;
    this.isDragging = false; // Will become true if mouse moves beyond threshold
    this.dragStartPos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    // Prevent default to avoid text selection
    event.preventDefault();
  }
  /**
   * Handle drag movement
   * @param {Event} event - Mouse event
   */
  handleDragMove(event) {
    if (!this.draggedNode) return;
    const currentPos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    if (!this.isDragging) {
      // Check if we've moved beyond the drag threshold
      const distance = this.coordinateTransform.calculateDistance(this.dragStartPos, currentPos);
      if (distance > this.config.dragThreshold) {
        this.isDragging = true;
        this.emit('dragStart', { node: this.draggedNode, event });
      }
    }
    if (this.isDragging) {
      // Update node position
      this.draggedNode.fx = currentPos.x;
      this.draggedNode.fy = currentPos.y;
      this.emit('dragMove', { 
        node: this.draggedNode, 
        position: currentPos, 
        event 
      });
    }
  }
  /**
   * End drag operation
   */
  endDrag() {
    if (this.draggedNode) {
      if (this.isDragging) {
        this.emit('dragEnd', { node: this.draggedNode });
      }
      // Optionally release the node's fixed position
      // this.draggedNode.fx = null;
      // this.draggedNode.fy = null;
    }
    this.draggedNode = null;
    this.isDragging = false;
    this.dragStartPos = null;
  }
  /**
   * Find node at a specific position
   * @param {Object} position - {x, y} position in graph coordinates
   * @returns {Object|null} - Node at position or null
   */
  findNodeAtPosition(position) {
    const clickRadius = this.config.clickRadius;
    for (const node of this.nodes) {
      if (node.x !== undefined && node.y !== undefined) {
        const distance = this.coordinateTransform.calculateDistance(position, node);
        const nodeRadius = (node.size || 10) + clickRadius;
        if (distance <= nodeRadius) {
          return node;
        }
      }
    }
    return null;
  }
  /**
   * Update continuous hover effects based on mouse position
   * @param {Object} mousePosition - {x, y} mouse position in graph coordinates
   */
  updateContinuousHoverEffects(mousePosition) {
    // Find the closest node within hover radius
    let closestNode = null;
    let closestDistance = Infinity;
    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        const distance = this.coordinateTransform.calculateDistance(node, mousePosition);
        const nodeRadius = (node.size || 10);
        // Prioritize nodes that the mouse is directly over
        const isDirectlyOver = distance <= nodeRadius;
        if (isDirectlyOver && distance < closestDistance) {
          closestNode = node;
          closestDistance = distance;
        } else if (!closestNode && distance <= this.config.hoverRadius) {
          closestNode = node;
          closestDistance = distance;
        }
      }
    });
    if (closestNode !== this.hoveredNode) {
      if (this.hoveredNode) {
        this.emit('nodeHoverEnd', { node: this.hoveredNode });
      }
      this.hoveredNode = closestNode;
      if (this.hoveredNode) {
        this.emit('nodeHoverStart', { node: this.hoveredNode, distance: closestDistance });
      }
    }
    if (closestNode) {
      this.emit('nodeHover', { 
        node: closestNode, 
        distance: closestDistance, 
        mousePosition 
      });
    } else {
      this.emit('noHover', { mousePosition });
    }
  }
  /**
   * Reset all hover effects
   */
  resetHoverEffects() {
    if (this.hoveredNode) {
      this.emit('nodeHoverEnd', { node: this.hoveredNode });
      this.hoveredNode = null;
    }
    this.emit('hoverReset');
  }
  /**
   * Enable or disable node dragging
   * @param {boolean} enabled - Whether dragging should be enabled
   */
  setDragEnabled(enabled) {
    this.config.dragEnabled = enabled;
  }
  /**
   * Enable or disable hover effects
   * @param {boolean} enabled - Whether hover effects should be enabled
   */
  setHoverEnabled(enabled) {
    this.config.hoverEnabled = enabled;
    if (!enabled) {
      this.resetHoverEffects();
    }
  }
  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);
  }
  /**
   * Get interaction statistics
   * @returns {Object} - Interaction state information
   */
  getStats() {
    return {
      hoveredNode: this.hoveredNode ? this.hoveredNode.id : null,
      isDragging: this.isDragging,
      draggedNode: this.draggedNode ? this.draggedNode.id : null,
      isInLayerMode: this.isInLayerMode,
      config: { ...this.config }
    };
  }
  /**
   * Programmatically trigger hover on a specific node
   * @param {string} nodeId - ID of node to hover
   */
  hoverNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node !== this.hoveredNode) {
      if (this.hoveredNode) {
        this.emit('nodeHoverEnd', { node: this.hoveredNode });
      }
      this.hoveredNode = node;
      this.emit('nodeHoverStart', { node, distance: 0 });
      this.emit('nodeHover', { node, distance: 0, mousePosition: node });
    }
  }
  /**
   * Clear programmatic hover
   */
  clearHover() {
    this.resetHoverEffects();
  }
  /**
   * Add event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }
  /**
   * Remove event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function to remove
   */
  off(eventType, callback) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = this.eventHandlers[eventType].filter(cb => cb !== callback);
    }
    return this;
  }
  /**
   * Emit event to all listeners
   * @param {string} eventType - Type of event
   * @param {Object} data - Event data
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event handler for ${eventType}:`, error);
        }
      });
    }
  }
  /**
   * Remove all event listeners and cleanup
   */
  destroy() {
    // Remove DOM event listeners
    if (this.svgElement) {
      Object.values(this.boundHandlers).forEach(handler => {
        this.svgElement.on(handler.name, null);
      });
    }
    // Clear node and link interactions
    if (this.nodeElements) {
      this.nodeElements.on('.interaction', null);
    }
    if (this.linkElements) {
      this.linkElements.on('.interaction', null);
    }
    // Clear state
    this.eventHandlers = {};
    this.hoveredNode = null;
    this.draggedNode = null;
    this.isDragging = false;
    this.nodes = [];
    this.links = [];
  }
}
// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = InteractionManager;
} else if (typeof window !== 'undefined') {
  window.InteractionManager = InteractionManager;
}
// core/VisualEffectsManager.js
/**
 * Visual Effects Manager for Knowledge Graph Explorer
 * Handles 3D-style hover effects, layer transitions, and visual state management
 */
class VisualEffectsManager {
  constructor(config = {}) {
    this.config = {
      // Hover effect settings
      hoverRadius: 50,
      maxHoverScale: 1.3,
      hoverTransitionDuration: 100,
      // Layer effect settings
      layerTransitionDuration: 400,
      // Distance-based scaling
      distanceScaling: {
        distance1: 0.9,
        distance2: 0.7,
        distance3: 0.5,
        distanceOther: 0.3
      },
      // Layer mode scaling
      layerScaling: {
        activeLayer: 1.0,
        connectedNodes: {
          distance1: 0.7,
          distance2: 0.5,
          distanceOther: 0.3
        },
        disconnectedNodes: 0.2
      },
      // Theme settings
      theme: {
        fontSizeBase: 12,
        fontSizeSmall: 10,
        fontSizeLarge: 14,
        defaultOpacity: 1.0,
        dimmedOpacity: 0.6,
        baseStrokeWidth: 2
      },
      ...config
    };
    // State
    this.nodes = [];
    this.links = [];
    this.nodeDistances = new Map();
    this.isInLayerMode = false;
    this.currentLayer = null;
    this.hoveredNode = null;
    // DOM element references
    this.nodeElements = null;
    this.linkElements = null;
    this.labelElements = null;
  }
  /**
   * Initialize with DOM elements
   * @param {Object} elements - Object containing D3 selections
   */
  initialize(elements) {
    this.nodeElements = elements.nodes;
    this.linkElements = elements.links;
    this.labelElements = elements.labels;
  }
  /**
   * Update data references
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   */
  updateData(nodes, links) {
    this.nodes = nodes || [];
    this.links = links || [];
    this.nodeDistances.clear();
  }
  /**
   * Calculate graph distance between two nodes using BFS
   * @param {string} sourceId - Source node ID
   * @param {string} targetId - Target node ID
   * @returns {number} - Graph distance (hops between nodes)
   */
  calculateGraphDistance(sourceId, targetId) {
    if (sourceId === targetId) return 0;
    const cacheKey = `${sourceId}-${targetId}`;
    if (this.nodeDistances.has(cacheKey)) {
      return this.nodeDistances.get(cacheKey);
    }
    // Build adjacency list
    const adjacencyList = new Map();
    this.nodes.forEach(node => adjacencyList.set(node.id, []));
    this.links.forEach(link => {
      const sourceNodeId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetNodeId = typeof link.target === 'object' ? link.target.id : link.target;
      if (adjacencyList.has(sourceNodeId) && adjacencyList.has(targetNodeId)) {
        adjacencyList.get(sourceNodeId).push(targetNodeId);
        adjacencyList.get(targetNodeId).push(sourceNodeId);
      }
    });
    // BFS to find shortest path
    const queue = [{ nodeId: sourceId, distance: 0 }];
    const visited = new Set([sourceId]);
    while (queue.length > 0) {
      const { nodeId, distance } = queue.shift();
      if (nodeId === targetId) {
        this.nodeDistances.set(cacheKey, distance);
        this.nodeDistances.set(`${targetId}-${sourceId}`, distance);
        return distance;
      }
      const neighbors = adjacencyList.get(nodeId) || [];
      for (const neighborId of neighbors) {
        if (!visited.has(neighborId)) {
          visited.add(neighborId);
          queue.push({ nodeId: neighborId, distance: distance + 1 });
        }
      }
    }
    // No path found
    const maxDistance = 999;
    this.nodeDistances.set(cacheKey, maxDistance);
    this.nodeDistances.set(`${targetId}-${sourceId}`, maxDistance);
    return maxDistance;
  }
  /**
   * Apply continuous hover effects (Mac dock style)
   * @param {Object} centerNode - Node being hovered
   * @param {number} centerDistance - Distance from mouse to center node
   * @param {Object} mousePosition - Mouse position in graph coordinates
   */
  applyContinuousHoverEffects(centerNode, centerDistance, mousePosition) {
    if (this.isInLayerMode) return;
    const nodeEffects = this.nodes.map(node => {
      let scaleFactor, opacityFactor;
      if (node.id === centerNode.id) {
        // Center node scales based on mouse proximity
        const proximityFactor = Math.max(0, 1 - centerDistance / this.config.hoverRadius);
        scaleFactor = 1 + (this.config.maxHoverScale - 1) * proximityFactor;
        opacityFactor = 1.0;
      } else {
        // Other nodes scale based on graph distance from center node
        const graphDistance = this.calculateGraphDistance(centerNode.id, node.id);
        const proximityFactor = Math.max(0, 1 - centerDistance / this.config.hoverRadius);
        let baseScale = this.getDistanceBasedScale(graphDistance);
        // Apply proximity-based scaling
        scaleFactor = baseScale + (1 - baseScale) * (1 - proximityFactor);
        opacityFactor = baseScale + (1 - baseScale) * (1 - proximityFactor);
      }
      return {
        nodeId: node.id,
        scaleFactor,
        opacityFactor
      };
    });
    this.applyNodeTransitions(nodeEffects, this.config.hoverTransitionDuration);
  }
  /**
   * Get scale factor based on graph distance
   * @param {number} distance - Graph distance
   * @returns {number} - Scale factor
   */
  getDistanceBasedScale(distance) {
    const scaling = this.config.distanceScaling;
    if (distance === 1) return scaling.distance1;
    if (distance === 2) return scaling.distance2;
    if (distance === 3) return scaling.distance3;
    return scaling.distanceOther;
  }
  /**
   * Reset all hover effects to normal state
   */
  resetHoverEffects() {
    if (this.isInLayerMode) {
      // Don't reset if in layer mode - layer effects take precedence
      return;
    }
    this.resetToNormalState();
  }
  /**
   * Reset all visual effects to normal state
   */
  resetToNormalState() {
    if (this.nodeElements) {
      this.nodeElements
        .transition()
        .duration(200)
        .ease(d3.easeQuadOut)
        .attr('r', d => d.size || 10)
        .attr('opacity', this.config.theme.defaultOpacity);
    }
    if (this.labelElements) {
      this.labelElements
        .transition()
        .duration(200)
        .ease(d3.easeQuadOut)
        .style('font-size', this.config.theme.fontSizeBase + 'px')
        .attr('opacity', this.config.theme.defaultOpacity);
    }
    if (this.linkElements) {
      this.linkElements
        .transition()
        .duration(200)
        .ease(d3.easeQuadOut)
        .attr('opacity', this.config.theme.dimmedOpacity)
        .attr('stroke-width', d => Math.sqrt(d.strength || 0.5) * this.config.theme.baseStrokeWidth);
    }
  }
  /**
   * Apply layer-based visual effects
   * @param {string} activeLayer - ID of the active layer
   */
  applyLayerEffects(activeLayer) {
    this.currentLayer = activeLayer;
    this.isInLayerMode = activeLayer !== null;
    if (!this.isInLayerMode) {
      this.resetToNormalState();
      return;
    }
    const nodeLayerEffects = this.nodes.map(node => {
      const isActiveLayer = node.layer === activeLayer;
      const hasActiveConnection = this.hasConnectionToActiveLayer(node, activeLayer);
      let scaleFactor, opacityFactor;
      if (isActiveLayer) {
        scaleFactor = this.config.layerScaling.activeLayer;
        opacityFactor = this.config.layerScaling.activeLayer;
      } else if (hasActiveConnection) {
        const distance = this.getMinDistanceToActiveLayer(node, activeLayer);
        const connectedScaling = this.config.layerScaling.connectedNodes;
        if (distance === 1) {
          scaleFactor = connectedScaling.distance1;
          opacityFactor = connectedScaling.distance1;
        } else if (distance === 2) {
          scaleFactor = connectedScaling.distance2;
          opacityFactor = connectedScaling.distance2;
        } else {
          scaleFactor = connectedScaling.distanceOther;
          opacityFactor = connectedScaling.distanceOther;
        }
      } else {
        scaleFactor = this.config.layerScaling.disconnectedNodes;
        opacityFactor = this.config.layerScaling.disconnectedNodes;
      }
      return {
        nodeId: node.id,
        scaleFactor,
        opacityFactor,
        isActiveLayer
      };
    });
    this.applyLayerTransitions(nodeLayerEffects);
  }
  /**
   * Check if node has connection to active layer
   * @param {Object} node - Node to check
   * @param {string} activeLayer - Active layer ID
   * @returns {boolean} - Whether node connects to active layer
   */
  hasConnectionToActiveLayer(node, activeLayer) {
    return this.links.some(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      if (node.id === sourceId) {
        const targetNode = this.nodes.find(n => n.id === targetId);
        return targetNode && targetNode.layer === activeLayer;
      } else if (node.id === targetId) {
        const sourceNode = this.nodes.find(n => n.id === sourceId);
        return sourceNode && sourceNode.layer === activeLayer;
      }
      return false;
    });
  }
  /**
   * Get minimum distance to any node in active layer
   * @param {Object} node - Node to check
   * @param {string} activeLayer - Active layer ID
   * @returns {number} - Minimum distance to active layer
   */
  getMinDistanceToActiveLayer(node, activeLayer) {
    const activeLayerNodes = this.nodes.filter(n => n.layer === activeLayer);
    let minDistance = 999;
    for (const activeNode of activeLayerNodes) {
      const distance = this.calculateGraphDistance(node.id, activeNode.id);
      minDistance = Math.min(minDistance, distance);
    }
    return minDistance;
  }
  /**
   * Apply node transitions for hover effects
   * @param {Array} nodeEffects - Array of effect objects
   * @param {number} duration - Transition duration in ms
   */
  applyNodeTransitions(nodeEffects, duration = 250) {
    const effectsMap = new Map();
    nodeEffects.forEach(effect => {
      effectsMap.set(effect.nodeId, effect);
    });
    if (this.nodeElements) {
      this.nodeElements
        .transition()
        .duration(duration)
        .ease(d3.easeQuadOut)
        .attr('r', d => {
          const effect = effectsMap.get(d.id);
          return (d.size || 10) * (effect ? effect.scaleFactor : 1);
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    if (this.labelElements) {
      this.labelElements
        .transition()
        .duration(duration)
        .ease(d3.easeQuadOut)
        .style('font-size', d => {
          const effect = effectsMap.get(d.id);
          const baseFontSize = this.config.theme.fontSizeBase;
          return `${baseFontSize * (effect ? effect.scaleFactor : 1)}px`;
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    if (this.linkElements) {
      this.linkElements
        .transition()
        .duration(duration)
        .ease(d3.easeQuadOut)
        .attr('opacity', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          const sourceEffect = effectsMap.get(sourceId);
          const targetEffect = effectsMap.get(targetId);
          const sourceOpacity = sourceEffect ? sourceEffect.opacityFactor : this.config.theme.defaultOpacity;
          const targetOpacity = targetEffect ? targetEffect.opacityFactor : this.config.theme.defaultOpacity;
          return Math.min(sourceOpacity, targetOpacity) * this.config.theme.dimmedOpacity;
        });
    }
  }
  /**
   * Apply layer transitions with longer duration and different easing
   * @param {Array} nodeLayerEffects - Array of layer effect objects
   */
  applyLayerTransitions(nodeLayerEffects) {
    const effectsMap = new Map();
    nodeLayerEffects.forEach(effect => {
      effectsMap.set(effect.nodeId, effect);
    });
    if (this.nodeElements) {
      this.nodeElements
        .transition()
        .duration(this.config.layerTransitionDuration)
        .ease(d3.easeQuadInOut)
        .attr('r', d => {
          const effect = effectsMap.get(d.id);
          return (d.size || 10) * (effect ? effect.scaleFactor : 1);
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    if (this.labelElements) {
      this.labelElements
        .transition()
        .duration(this.config.layerTransitionDuration)
        .ease(d3.easeQuadInOut)
        .style('font-size', d => {
          const effect = effectsMap.get(d.id);
          const baseFontSize = this.config.theme.fontSizeBase;
          return `${baseFontSize * (effect ? effect.scaleFactor : 1)}px`;
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    if (this.linkElements) {
      this.linkElements
        .transition()
        .duration(this.config.layerTransitionDuration)
        .ease(d3.easeQuadInOut)
        .attr('opacity', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          const sourceEffect = effectsMap.get(sourceId);
          const targetEffect = effectsMap.get(targetId);
          const sourceOpacity = sourceEffect ? sourceEffect.opacityFactor : this.config.theme.defaultOpacity;
          const targetOpacity = targetEffect ? targetEffect.opacityFactor : this.config.theme.defaultOpacity;
          return Math.min(sourceOpacity, targetOpacity) * this.config.theme.dimmedOpacity;
        })
        .attr('stroke-width', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          const sourceEffect = effectsMap.get(sourceId);
          const targetEffect = effectsMap.get(targetId);
          const baseWidth = Math.sqrt(d.strength || 0.5) * this.config.theme.baseStrokeWidth;
          const sourceScale = sourceEffect ? sourceEffect.scaleFactor : 1;
          const targetScale = targetEffect ? targetEffect.scaleFactor : 1;
          return baseWidth * Math.max(sourceScale, targetScale);
        });
    }
  }
  /**
   * Highlight specific nodes with special effects
   * @param {Array} nodeIds - Array of node IDs to highlight
   * @param {Object} highlightConfig - Highlight configuration
   */
  highlightNodes(nodeIds, highlightConfig = {}) {
    const config = {
      scaleFactor: 1.2,
      opacityFactor: 1.0,
      duration: 300,
      ...highlightConfig
    };
    const highlightSet = new Set(nodeIds);
    const nodeEffects = this.nodes.map(node => ({
      nodeId: node.id,
      scaleFactor: highlightSet.has(node.id) ? config.scaleFactor : 0.5,
      opacityFactor: highlightSet.has(node.id) ? config.opacityFactor : 0.3
    }));
    this.applyNodeTransitions(nodeEffects, config.duration);
  }
  /**
   * Create pulsing animation effect
   * @param {string} nodeId - Node ID to animate
   * @param {Object} pulseConfig - Pulse configuration
   */
  pulseNode(nodeId, pulseConfig = {}) {
    const config = {
      scaleFactor: 1.5,
      duration: 600,
      iterations: 3,
      ...pulseConfig
    };
    const node = this.nodes.find(n => n.id === nodeId);
    if (!node) return;
    const nodeElement = this.nodeElements ? this.nodeElements.filter(d => d.id === nodeId) : null;
    const labelElement = this.labelElements ? this.labelElements.filter(d => d.id === nodeId) : null;
    if (nodeElement && nodeElement.size() > 0) {
      const baseSize = node.size || 10;
      const baseFontSize = this.config.theme.fontSizeBase;
      // Create pulsing animation
      for (let i = 0; i < config.iterations; i++) {
        nodeElement
          .transition()
          .delay(i * config.duration)
          .duration(config.duration / 2)
          .ease(d3.easeQuadInOut)
          .attr('r', baseSize * config.scaleFactor)
          .transition()
          .duration(config.duration / 2)
          .ease(d3.easeQuadInOut)
          .attr('r', baseSize);
        if (labelElement && labelElement.size() > 0) {
          labelElement
            .transition()
            .delay(i * config.duration)
            .duration(config.duration / 2)
            .ease(d3.easeQuadInOut)
            .style('font-size', `${baseFontSize * config.scaleFactor}px`)
            .transition()
            .duration(config.duration / 2)
            .ease(d3.easeQuadInOut)
            .style('font-size', `${baseFontSize}px`);
        }
      }
    }
  }
  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);
  }
  /**
   * Get current visual state
   * @returns {Object} - Visual state information
   */
  getState() {
    return {
      isInLayerMode: this.isInLayerMode,
      currentLayer: this.currentLayer,
      hoveredNode: this.hoveredNode ? this.hoveredNode.id : null,
      nodeCount: this.nodes.length,
      linkCount: this.links.length,
      config: { ...this.config }
    };
  }
  /**
   * Clear distance cache (call when graph structure changes)
   */
  clearDistanceCache() {
    this.nodeDistances.clear();
  }
  /**
   * Cleanup and reset all effects
   */
  destroy() {
    this.resetToNormalState();
    this.nodeDistances.clear();
    this.nodes = [];
    this.links = [];
    this.hoveredNode = null;
    this.currentLayer = null;
    this.isInLayerMode = false;
  }
}
// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = VisualEffectsManager;
} else if (typeof window !== 'undefined') {
  window.VisualEffectsManager = VisualEffectsManager;
}
// core/MiniMapManager.js
/**
 * MiniMap Manager for Knowledge Graph Explorer
 * Handles the miniature overview map with viewport indicator and navigation
 */
class MiniMapManager {
  constructor(config = {}) {
    this.config = {
      width: 150,
      height: 120,
      padding: 10,
      position: 'bottom-left', // 'bottom-left', 'bottom-right', 'top-left', 'top-right'
      // Visual settings
      backgroundColor: '#f8f9faE6', // 90% opacity
      borderColor: '#2780e3',
      borderWidth: 1,
      borderRadius: 6,
      // Viewport indicator
      viewportColor: '#2780e3',
      viewportOpacity: 0.7,
      viewportStrokeWidth: 2,
      // Node/link styling in minimap
      nodeOpacity: 0.8,
      linkOpacity: 0.4,
      nodeMinSize: 1,
      nodeMaxSize: 3,
      linkStrokeWidth: 0.5,
      // Interaction
      clickToNavigate: true,
      showOnHover: false,
      ...config
    };
    // State
    this.nodes = [];
    this.links = [];
    this.isVisible = true;
    this.coordinateTransform = null;
    // Rendering state
    this.scale = 1;
    this.offsetX = 0;
    this.offsetY = 0;
    this.bounds = null;
    // DOM elements
    this.container = null;
    this.containerElement = null;
    this.svg = null;
    this.mainGroup = null;
    this.linkGroup = null;
    this.nodeGroup = null;
    this.viewportIndicator = null;
    // Event handlers
    this.eventHandlers = {};
  }
  /**
   * Initialize minimap with parent container and coordinate transform
   * @param {Element} parentContainer - Parent DOM element
   * @param {CoordinateTransform} coordinateTransform - Coordinate transformation utility
   */
  initialize(parentContainer, coordinateTransform) {
    this.container = parentContainer;
    this.coordinateTransform = coordinateTransform;
    this.createMiniMapContainer();
    this.setupSVG();
    this.setupEventListeners();
  }
  /**
   * Create the minimap container element
   */
  createMiniMapContainer() {
    this.containerElement = document.createElement('div');
    this.containerElement.className = 'mini-map';
    this.containerElement.style.cssText = this.getContainerStyles();
    this.container.appendChild(this.containerElement);
  }
  /**
   * Get CSS styles for the container
   * @returns {string} - CSS style string
   */
  getContainerStyles() {
    const position = this.getPositionStyles();
    return `
      position: absolute;
      width: ${this.config.width}px;
      height: ${this.config.height}px;
      background-color: ${this.config.backgroundColor};
      border: ${this.config.borderWidth}px solid ${this.config.borderColor};
      border-radius: ${this.config.borderRadius}px;
      overflow: hidden;
      cursor: pointer;
      backdrop-filter: blur(5px);
      z-index: 10;
      ${position}
    `.replace(/\s+/g, ' ').trim();
  }
  /**
   * Get position styles based on configuration
   * @returns {string} - Position CSS
   */
  getPositionStyles() {
    const margin = 10;
    switch (this.config.position) {
      case 'top-left':
        return `top: ${margin}px; left: ${margin}px;`;
      case 'top-right':
        return `top: ${margin}px; right: ${margin}px;`;
      case 'bottom-right':
        return `bottom: ${margin}px; right: ${margin}px;`;
      case 'bottom-left':
      default:
        return `bottom: ${margin}px; left: ${margin}px;`;
    }
  }
  /**
   * Setup SVG and its groups
   */
  setupSVG() {
    this.svg = d3.select(this.containerElement)
      .append('svg')
      .attr('width', this.config.width)
      .attr('height', this.config.height);
    // Create groups for different elements
    this.mainGroup = this.svg.append('g').attr('class', 'mini-map-main');
    this.linkGroup = this.mainGroup.append('g').attr('class', 'mini-map-links');
    this.nodeGroup = this.mainGroup.append('g').attr('class', 'mini-map-nodes');
    // Create viewport indicator
    this.viewportIndicator = this.svg.append('rect')
      .attr('class', 'viewport-indicator')
      .attr('fill', 'none')
      .attr('stroke', this.config.viewportColor)
      .attr('stroke-width', this.config.viewportStrokeWidth)
      .attr('opacity', this.config.viewportOpacity);
  }
  /**
   * Setup event listeners
   */
  setupEventListeners() {
    if (this.config.clickToNavigate) {
      this.svg.on('click', (event) => {
        const [x, y] = d3.pointer(event);
        this.navigateToPosition(x, y);
      });
    }
    if (this.config.showOnHover) {
      this.containerElement.addEventListener('mouseenter', () => {
        this.show();
      });
      this.containerElement.addEventListener('mouseleave', () => {
        this.hide();
      });
    }
  }
  /**
   * Update data and refresh the minimap
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   */
  updateData(nodes, links) {
    this.nodes = nodes || [];
    this.links = links || [];
    this.render();
  }
  /**
   * Calculate bounds of all nodes
   * @returns {Object|null} - Bounds object or null if no nodes
   */
  calculateBounds() {
    if (this.nodes.length === 0) return null;
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        minX = Math.min(minX, node.x);
        maxX = Math.max(maxX, node.x);
        minY = Math.min(minY, node.y);
        maxY = Math.max(maxY, node.y);
      }
    });
    if (minX === Infinity) return null;
    return {
      minX, maxX, minY, maxY,
      width: maxX - minX,
      height: maxY - minY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }
  /**
   * Calculate scale and offset for fitting content
   */
  calculateTransform() {
    this.bounds = this.calculateBounds();
    if (!this.bounds) {
      this.scale = 1;
      this.offsetX = 0;
      this.offsetY = 0;
      return;
    }
    const availableWidth = this.config.width - 2 * this.config.padding;
    const availableHeight = this.config.height - 2 * this.config.padding;
    const scaleX = availableWidth / this.bounds.width;
    const scaleY = availableHeight / this.bounds.height;
    this.scale = Math.min(scaleX, scaleY, 0.3); // Max scale to prevent too much zoom
    this.offsetX = (this.config.width - this.bounds.width * this.scale) / 2 - this.bounds.minX * this.scale;
    this.offsetY = (this.config.height - this.bounds.height * this.scale) / 2 - this.bounds.minY * this.scale;
  }
  /**
   * Render the minimap
   */
  render() {
    this.calculateTransform();
    this.renderLinks();
    this.renderNodes();
    this.updateViewportIndicator();
  }
  /**
   * Render links in the minimap
   */
  renderLinks() {
    if (!this.bounds) return;
    const linkSelection = this.linkGroup
      .selectAll('line')
      .data(this.links, d => `${this.getLinkSourceId(d)}-${this.getLinkTargetId(d)}`);
    linkSelection.exit().remove();
    linkSelection.enter()
      .append('line')
      .attr('stroke', this.config.borderColor)
      .attr('stroke-width', this.config.linkStrokeWidth)
      .attr('stroke-opacity', this.config.linkOpacity)
      .merge(linkSelection)
      .attr('x1', d => this.offsetX + this.getLinkSourceNode(d).x * this.scale)
      .attr('y1', d => this.offsetY + this.getLinkSourceNode(d).y * this.scale)
      .attr('x2', d => this.offsetX + this.getLinkTargetNode(d).x * this.scale)
      .attr('y2', d => this.offsetY + this.getLinkTargetNode(d).y * this.scale);
  }
  /**
   * Render nodes in the minimap
   */
  renderNodes() {
    if (!this.bounds) return;
    const nodeSelection = this.nodeGroup
      .selectAll('circle')
      .data(this.nodes, d => d.id);
    nodeSelection.exit().remove();
    nodeSelection.enter()
      .append('circle')
      .attr('stroke', 'none')
      .attr('opacity', this.config.nodeOpacity)
      .merge(nodeSelection)
      .attr('cx', d => this.offsetX + d.x * this.scale)
      .attr('cy', d => this.offsetY + d.y * this.scale)
      .attr('r', d => this.getNodeRadius(d))
      .attr('fill', d => this.getNodeColor(d));
  }
  /**
   * Get node radius for minimap
   * @param {Object} node - Node object
   * @returns {number} - Radius value
   */
  getNodeRadius(node) {
    const baseRadius = (node.size || 10) / 10; // Normalize
    return Math.max(
      this.config.nodeMinSize,
      Math.min(this.config.nodeMaxSize, baseRadius)
    );
  }
  /**
   * Get node color (can be overridden for custom coloring)
   * @param {Object} node - Node object
   * @returns {string} - Color value
   */
  getNodeColor(node) {
    // Default color scheme - can be customized
    const colorMap = {
      'education': '#2780e3',
      'research': '#3fb618',
      'industry': '#ffdd3c',
      'current': '#ff0039',
      'geographic': '#613d7c'
    };
    return colorMap[node.type] || colorMap[node.layer] || this.config.borderColor;
  }
  /**
   * Helper to get link source ID
   * @param {Object} link - Link object
   * @returns {string} - Source node ID
   */
  getLinkSourceId(link) {
    return typeof link.source === 'object' ? link.source.id : link.source;
  }
  /**
   * Helper to get link target ID
   * @param {Object} link - Link object
   * @returns {string} - Target node ID
   */
  getLinkTargetId(link) {
    return typeof link.target === 'object' ? link.target.id : link.target;
  }
  /**
   * Helper to get link source node
   * @param {Object} link - Link object
   * @returns {Object} - Source node object
   */
  getLinkSourceNode(link) {
    const sourceId = this.getLinkSourceId(link);
    return this.nodes.find(n => n.id === sourceId) || { x: 0, y: 0 };
  }
  /**
   * Helper to get link target node
   * @param {Object} link - Link object
   * @returns {Object} - Target node object
   */
  getLinkTargetNode(link) {
    const targetId = this.getLinkTargetId(link);
    return this.nodes.find(n => n.id === targetId) || { x: 0, y: 0 };
  }
  /**
   * Update viewport indicator based on current zoom/pan
   */
  updateViewportIndicator() {
    if (!this.coordinateTransform || !this.bounds) return;
    const transform = this.coordinateTransform.getTransform();
    const viewport = this.coordinateTransform.getVisibleBounds();
    // Calculate viewport rectangle in minimap coordinates
    const viewportWidth = viewport.width * this.scale;
    const viewportHeight = viewport.height * this.scale;
    const viewportX = this.offsetX + (viewport.minX - this.bounds.minX) * this.scale;
    const viewportY = this.offsetY + (viewport.minY - this.bounds.minY) * this.scale;
    // Clamp to minimap boundaries
    const clampedX = Math.max(0, Math.min(this.config.width - viewportWidth, viewportX));
    const clampedY = Math.max(0, Math.min(this.config.height - viewportHeight, viewportY));
    const clampedWidth = Math.min(viewportWidth, this.config.width - clampedX);
    const clampedHeight = Math.min(viewportHeight, this.config.height - clampedY);
    this.viewportIndicator
      .attr('x', clampedX)
      .attr('y', clampedY)
      .attr('width', Math.max(1, clampedWidth))
      .attr('height', Math.max(1, clampedHeight));
  }
  /**
   * Navigate to a position clicked in the minimap
   * @param {number} miniX - X coordinate in minimap
   * @param {number} miniY - Y coordinate in minimap
   */
  navigateToPosition(miniX, miniY) {
    if (!this.coordinateTransform || !this.bounds) return;
    // Convert minimap coordinates to graph coordinates
    const graphX = (miniX - this.offsetX) / this.scale + this.bounds.minX;
    const graphY = (miniY - this.offsetY) / this.scale + this.bounds.minY;
    this.emit('navigate', { 
      graphPosition: { x: graphX, y: graphY },
      miniMapPosition: { x: miniX, y: miniY }
    });
  }
  /**
   * Set minimap position
   * @param {string} position - Position string
   */
  setPosition(position) {
    this.config.position = position;
    if (this.containerElement) {
      const positionStyles = this.getPositionStyles();
      this.containerElement.style.cssText = this.getContainerStyles();
    }
  }
  /**
   * Show the minimap
   */
  show() {
    this.isVisible = true;
    if (this.containerElement) {
      this.containerElement.style.display = 'block';
    }
  }
  /**
   * Hide the minimap
   */
  hide() {
    this.isVisible = false;
    if (this.containerElement) {
      this.containerElement.style.display = 'none';
    }
  }
  /**
   * Toggle minimap visibility
   */
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }
  /**
   * Update minimap size
   * @param {number} width - New width
   * @param {number} height - New height
   */
  resize(width, height) {
    this.config.width = width;
    this.config.height = height;
    if (this.containerElement) {
      this.containerElement.style.width = width + 'px';
      this.containerElement.style.height = height + 'px';
    }
    if (this.svg) {
      this.svg.attr('width', width).attr('height', height);
    }
    this.render();
  }
  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);
    if (this.containerElement) {
      this.containerElement.style.cssText = this.getContainerStyles();
    }
    this.render();
  }
  /**
   * Get minimap statistics
   * @returns {Object} - Minimap state information
   */
  getStats() {
    return {
      isVisible: this.isVisible,
      position: this.config.position,
      dimensions: {
        width: this.config.width,
        height: this.config.height
      },
      bounds: this.bounds,
      transform: {
        scale: this.scale,
        offsetX: this.offsetX,
        offsetY: this.offsetY
      },
      nodeCount: this.nodes.length,
      linkCount: this.links.length
    };
  }
  /**
   * Focus on a specific node in the minimap
   * @param {string} nodeId - Node ID to focus on
   */
  focusNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node.x !== undefined && node.y !== undefined) {
      this.navigateToPosition(
        this.offsetX + node.x * this.scale,
        this.offsetY + node.y * this.scale
      );
    }
  }
  /**
   * Highlight specific nodes in the minimap
   * @param {Array} nodeIds - Array of node IDs to highlight
   * @param {Object} highlightConfig - Highlight configuration
   */
  highlightNodes(nodeIds, highlightConfig = {}) {
    const config = {
      color: '#ff0039',
      strokeWidth: 2,
      ...highlightConfig
    };
    const highlightSet = new Set(nodeIds);
    this.nodeGroup.selectAll('circle')
      .attr('stroke', d => highlightSet.has(d.id) ? config.color : 'none')
      .attr('stroke-width', d => highlightSet.has(d.id) ? config.strokeWidth : 0);
  }
  /**
   * Clear all highlights
   */
  clearHighlights() {
    this.nodeGroup.selectAll('circle')
      .attr('stroke', 'none')
      .attr('stroke-width', 0);
  }
  /**
   * Add event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }
  /**
   * Remove event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function to remove
   */
  off(eventType, callback) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = this.eventHandlers[eventType].filter(cb => cb !== callback);
    }
    return this;
  }
  /**
   * Emit event to all listeners
   * @param {string} eventType - Type of event
   * @param {Object} data - Event data
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in minimap event handler for ${eventType}:`, error);
        }
      });
    }
  }
  /**
   * Cleanup and destroy the minimap
   */
  destroy() {
    // Remove DOM elements
    if (this.containerElement && this.container) {
      this.container.removeChild(this.containerElement);
    }
    // Clear references
    this.eventHandlers = {};
    this.nodes = [];
    this.links = [];
    this.containerElement = null;
    this.svg = null;
    this.coordinateTransform = null;
  }
}
// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = MiniMapManager;
} else if (typeof window !== 'undefined') {
  window.MiniMapManager = MiniMapManager;
}
// core/UIControlsManager.js
/**
 * UI Controls Manager for Knowledge Graph Explorer
 * Handles timeline controls, layer buttons, info panels, and other UI elements
 */
class UIControlsManager {
  constructor(config = {}) {
    this.config = {
      showTimeline: true,
      showLayerControls: true,
      showNodeInfo: true,
      showMiniMap: true,
      timelineHeight: 60,
      controlPanelWidth: 200,
      ...config
    };
    // State
    this.graph = null;
    this.container = null;
    this.layers = [];
    this.timeline = { start: 2000, end: 2025 };
    this.currentTimelinePosition = null;
    this.activeLayer = null;
    this.selectedNode = null;
    // DOM elements
    this.uiContainer = null;
    this.timelineContainer = null;
    this.layerContainer = null;
    this.infoPanel = null;
    this.timelineSlider = null;
    // Event handlers
    this.eventHandlers = {};
  }
  /**
   * Initialize UI controls
   * @param {Element} container - Main container element
   * @param {Object} graph - KnowledgeGraphExplorer instance
   * @param {Object} data - Graph data with layers and timeline info
   */
  initialize(container, graph, data) {
    this.container = container;
    this.graph = graph;
    this.layers = data.layers || [];
    // Extract timeline range from config or data
    if (data.timeline) {
      this.timeline = data.timeline;
    }
    this.createUIStructure();
    this.setupEventListeners();
  }
  /**
   * Create the overall UI structure
   */
  createUIStructure() {
    // Don't restructure DOM - just add overlay controls to existing container
    this.container.style.position = 'relative';
    this.container.style.fontFamily = 'system-ui, -apple-system, sans-serif';
    console.log('createUIStructure called');
    console.log('showLayerControls:', this.config.showLayerControls);
    console.log('layers.length:', this.layers.length);
    console.log('layers:', this.layers);
    // Create control panels as overlays
    if (this.config.showLayerControls && this.layers.length > 0) {
      this.createLayerControls();
    }
    if (this.config.showTimeline && this.timeline.start && this.timeline.end) {
      this.createTimelineControls();
    }
    if (this.config.showNodeInfo) {
      this.createInfoPanel();
    }
  }
  /**
   * Create layer control buttons
   */
  createLayerControls() {
    console.log('Creating layer controls with layers:', this.layers);
    console.log('Config showLayerControls:', this.config.showLayerControls);
    this.layerContainer = document.createElement('div');
    this.layerContainer.className = 'kg-layer-controls';
    this.layerContainer.style.cssText = `
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      max-width: 180px;
    `;
    // Title
    const title = document.createElement('div');
    title.textContent = 'Layers';
    title.style.cssText = `
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 12px;
      color: #333;
    `;
    this.layerContainer.appendChild(title);
    // "All Layers" button
    const allButton = this.createLayerButton('all', 'All Layers', '#666');
    allButton.classList.add('active');
    this.layerContainer.appendChild(allButton);
    // Individual layer buttons
    this.layers.forEach(layer => {
      const button = this.createLayerButton(layer.id, layer.name, layer.color);
      this.layerContainer.appendChild(button);
    });
    this.container.appendChild(this.layerContainer);
  }
  /**
   * Create refresh button for resetting node positions
   */
  createRefreshButton() {
    this.refreshButton = document.createElement('button');
    this.refreshButton.className = 'kg-refresh-btn';
    this.refreshButton.innerHTML = '🔄'; // Refresh icon
    this.refreshButton.title = 'Reset node positions';
    this.refreshButton.style.cssText = `
      position: absolute;
      top: 10px;
      left: ${this.layerContainer ? '200px' : '10px'}; /* Adjust based on layer controls */
      width: 36px;
      height: 36px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      transition: all 0.2s ease;
    `;
    // Hover effects
    this.refreshButton.addEventListener('mouseenter', () => {
      this.refreshButton.style.background = '#f0f0f0';
      this.refreshButton.style.transform = 'scale(1.05)';
    });
    this.refreshButton.addEventListener('mouseleave', () => {
      this.refreshButton.style.background = 'rgba(255, 255, 255, 0.95)';
      this.refreshButton.style.transform = 'scale(1)';
    });
    // Click handler
    this.refreshButton.addEventListener('click', () => {
      this.refreshNodePositions();
    });
    this.container.appendChild(this.refreshButton);
  }
  /**
   * Refresh/reset node positions
   */
  refreshNodePositions() {
    if (!this.graph) return;
    // Add visual feedback
    this.refreshButton.style.transform = 'rotate(360deg)';
    this.refreshButton.style.transition = 'transform 0.5s ease';
    // Reset the transform after animation
    setTimeout(() => {
      this.refreshButton.style.transform = 'scale(1)';
      this.refreshButton.style.transition = 'all 0.2s ease';
    }, 500);
    // Restart the simulation with higher energy
    if (this.graph.components && this.graph.components.forceSimulation) {
      // Clear any fixed positions
      this.graph.nodes.forEach(node => {
        node.fx = null;
        node.fy = null;
      });
      // Restart with high energy
      this.graph.components.forceSimulation.restart(1.0);
    }
    this.emit('refresh', { timestamp: Date.now() });
  }
  // Modify the createUIStructure() method to include the refresh button:
  createUIStructure() {
    // Don't restructure DOM - just add overlay controls to existing container
    this.container.style.position = 'relative';
    this.container.style.fontFamily = 'system-ui, -apple-system, sans-serif';
    console.log('createUIStructure called');
    console.log('showLayerControls:', this.config.showLayerControls);
    console.log('layers.length:', this.layers.length);
    console.log('layers:', this.layers);
    // Create control panels as overlays
    if (this.config.showLayerControls && this.layers.length > 0) {
      this.createLayerControls();
    }
    // Add refresh button
    this.createRefreshButton();
    if (this.config.showTimeline && this.timeline.start && this.timeline.end) {
      this.createTimelineControls();
    }
    if (this.config.showNodeInfo) {
      this.createInfoPanel();
    }
  }
  /**
   * Create a single layer button
   */
  createLayerButton(layerId, layerName, color) {
    const button = document.createElement('button');
    button.className = 'kg-layer-btn';
    button.setAttribute('data-layer', layerId);
    button.style.cssText = `
      display: block;
      width: 100%;
      margin: 2px 0;
      padding: 6px 8px;
      border: 1px solid ${color};
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      text-align: left;
      transition: all 0.2s ease;
    `;
    // Color indicator
    const colorDot = document.createElement('span');
    colorDot.style.cssText = `
      display: inline-block;
      width: 8px;
      height: 8px;
      background: ${color};
      border-radius: 50%;
      margin-right: 6px;
    `;
    button.appendChild(colorDot);
    button.appendChild(document.createTextNode(layerName));
    // Hover and active states
    button.addEventListener('mouseenter', () => {
      if (!button.classList.contains('active')) {
        button.style.background = color + '20';
      }
    });
    button.addEventListener('mouseleave', () => {
      if (!button.classList.contains('active')) {
        button.style.background = 'white';
      }
    });
    button.addEventListener('click', () => {
      this.setActiveLayer(layerId);
    });
    return button;
  }
  /**
   * Create timeline controls
   */
  createTimelineControls() {
    this.timelineContainer = document.createElement('div');
    this.timelineContainer.className = 'kg-timeline-controls';
    this.timelineContainer.style.cssText = `
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 12px 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      min-width: 300px;
    `;
    // Title and current year display
    const header = document.createElement('div');
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-size: 12px;
      color: #333;
    `;
    const title = document.createElement('span');
    title.textContent = 'Timeline';
    title.style.fontWeight = 'bold';
    this.currentYearDisplay = document.createElement('span');
    this.currentYearDisplay.textContent = 'All Years';
    this.currentYearDisplay.style.color = '#666';
    header.appendChild(title);
    header.appendChild(this.currentYearDisplay);
    this.timelineContainer.appendChild(header);
    // Timeline slider
    this.timelineSlider = document.createElement('input');
    this.timelineSlider.type = 'range';
    this.timelineSlider.min = this.timeline.start;
    this.timelineSlider.max = this.timeline.end;
    this.timelineSlider.value = this.timeline.end;
    this.timelineSlider.style.cssText = `
      width: 100%;
      margin: 5px 0;
    `;
    // Timeline labels
    const labels = document.createElement('div');
    labels.style.cssText = `
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #666;
      margin-top: 4px;
    `;
    const startLabel = document.createElement('span');
    startLabel.textContent = this.timeline.start;
    const endLabel = document.createElement('span');
    endLabel.textContent = this.timeline.end;
    labels.appendChild(startLabel);
    labels.appendChild(endLabel);
    // "All Years" toggle button
    const allYearsBtn = document.createElement('button');
    allYearsBtn.textContent = 'Show All Years';
    allYearsBtn.style.cssText = `
      margin-top: 8px;
      padding: 4px 8px;
      border: 1px solid #ddd;
      background: white;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      width: 100%;
    `;
    this.timelineContainer.appendChild(this.timelineSlider);
    this.timelineContainer.appendChild(labels);
    this.timelineContainer.appendChild(allYearsBtn);
    // Event listeners
    this.timelineSlider.addEventListener('input', (e) => {
      this.setTimelinePosition(parseInt(e.target.value));
    });
    allYearsBtn.addEventListener('click', () => {
      this.showAllYears();
    });
    this.container.appendChild(this.timelineContainer);
  }
  /**
   * Create info panel for displaying node/link details
   */
  createInfoPanel() {
    this.infoPanel = document.createElement('div');
    this.infoPanel.className = 'kg-info-panel';
    this.infoPanel.style.cssText = `
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 15px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      max-width: 250px;
      display: none;
      pointer-events: auto;
    `;
    this.container.appendChild(this.infoPanel);
  }
  /**
   * Setup event listeners with the graph
   */
  setupEventListeners() {
    if (!this.graph) return;
    // Listen for node clicks
    this.graph.on('nodeClick', (data) => {
      this.showNodeInfo(data.node);
    });
    // Listen for background clicks to hide info
    this.graph.on('backgroundClick', () => {
      this.hideInfo();
    });
    // Listen for layer changes
    this.graph.on('layerChange', (data) => {
      this.updateLayerButtons(data.layer);
    });
  }
  /**
   * Set active layer
   */
  setActiveLayer(layerId) {
    this.activeLayer = layerId === 'all' ? null : layerId;
    // Update graph
    if (this.graph) {
      if (layerId === 'all') {
        this.graph.showAllLayers();
      } else {
        this.graph.setActiveLayer(layerId);
      }
    }
    // Update button states
    this.updateLayerButtons(this.activeLayer);
    this.emit('layerChange', { layer: this.activeLayer });
  }
  /**
   * Update layer button visual states
   */
  updateLayerButtons(activeLayerId) {
    if (!this.layerContainer) return;
    const buttons = this.layerContainer.querySelectorAll('.kg-layer-btn');
    buttons.forEach(btn => {
      const layerId = btn.getAttribute('data-layer');
      const isActive = (activeLayerId === null && layerId === 'all') || 
                      (activeLayerId === layerId);
      btn.classList.toggle('active', isActive);
      if (isActive) {
        const color = layerId === 'all' ? '#666' : 
                     this.layers.find(l => l.id === layerId)?.color || '#666';
        btn.style.background = color + '30';
        btn.style.fontWeight = 'bold';
      } else {
        btn.style.background = 'white';
        btn.style.fontWeight = 'normal';
      }
    });
  }
  /**
   * Set timeline position
   */
  setTimelinePosition(year) {
    this.currentTimelinePosition = year;
    this.currentYearDisplay.textContent = year.toString();
    // TODO: Filter nodes/links by timeline position
    // This would require integration with the graph's data filtering
    this.emit('timelineChange', { year: year });
  }
  /**
   * Show all years (reset timeline)
   */
  showAllYears() {
    this.currentTimelinePosition = null;
    this.currentYearDisplay.textContent = 'All Years';
    this.timelineSlider.value = this.timeline.end;
    // TODO: Reset timeline filtering
    this.emit('timelineChange', { year: null });
  }
  /**
   * Show node information in the info panel
   */
  showNodeInfo(node) {
    console.log('showNodeInfo called with:', node);
    if (!this.infoPanel) {
      console.error('Info panel not found!');
      return;
    }
    this.selectedNode = node;
    const title = document.createElement('div');
    title.style.cssText = `
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 8px;
      color: #333;
    `;
    title.textContent = node.label;
    const description = document.createElement('div');
    description.style.cssText = `
      font-size: 12px;
      line-height: 1.4;
      color: #555;
      margin-bottom: 10px;
    `;
    description.textContent = node.description || 'No description available.';
    // Additional details
    const details = document.createElement('div');
    details.style.cssText = `
      font-size: 11px;
      color: #777;
      border-top: 1px solid #eee;
      padding-top: 8px;
      margin-bottom: 10px;
    `;
    if (node.timespan) {
      const timespan = document.createElement('div');
      timespan.textContent = `${node.timespan.start} - ${node.timespan.end || 'present'}`;
      details.appendChild(timespan);
    }
    // Layer tag (colored box instead of text)
    if (node.layer) {
      const layerInfo = this.layers.find(l => l.id === node.layer);
      const layerTag = document.createElement('div');
      layerTag.style.cssText = `
        display: inline-block;
        background: ${layerInfo?.color || '#666'};
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 10px;
        font-weight: bold;
        margin-top: 4px;
      `;
      layerTag.textContent = layerInfo?.name || node.layer;
      details.appendChild(layerTag);
    }
    // Related nodes section
    const relatedSection = this.createRelatedNodesSection(node);
    // Close button
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '×';
    closeBtn.style.cssText = `
      position: absolute;
      top: 5px;
      right: 5px;
      border: none;
      background: none;
      font-size: 16px;
      cursor: pointer;
      color: #999;
    `;
    closeBtn.addEventListener('click', () => this.hideInfo());
    // Clear and populate
    this.infoPanel.innerHTML = '';
    this.infoPanel.appendChild(closeBtn);
    this.infoPanel.appendChild(title);
    this.infoPanel.appendChild(description);
    this.infoPanel.appendChild(details);
    this.infoPanel.appendChild(relatedSection);
    this.infoPanel.style.display = 'block';
    console.log('Info panel should now be visible');
  }
  /**
   * Create the "Related To" section showing connected nodes
   */
  createRelatedNodesSection(node) {
    // Find all links connected to this node
    const connectedLinks = this.graph.links.filter(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      return sourceId === node.id || targetId === node.id;
    });
    if (connectedLinks.length === 0) {
      return document.createElement('div'); // Return empty div if no connections
    }
    const section = document.createElement('div');
    section.style.cssText = `
      border-top: 1px solid #eee;
      padding-top: 8px;
      margin-top: 8px;
    `;
    const title = document.createElement('div');
    title.textContent = 'Related To';
    title.style.cssText = `
      font-weight: bold;
      font-size: 11px;
      color: #333;
      margin-bottom: 6px;
    `;
    section.appendChild(title);
    // Create clickable links for each connected node
    connectedLinks.forEach(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      // Get the connected node (not the current node)
      const connectedNodeId = sourceId === node.id ? targetId : sourceId;
      const connectedNode = this.graph.nodes.find(n => n.id === connectedNodeId);
      if (connectedNode) {
        const nodeLink = document.createElement('div');
        nodeLink.style.cssText = `
          display: inline-block;
          margin: 2px 4px 2px 0;
          padding: 3px 8px;
          background: #f0f0f0;
          border: 1px solid #ddd;
          border-radius: 12px;
          font-size: 10px;
          cursor: pointer;
          transition: background-color 0.2s ease;
        `;
        nodeLink.textContent = connectedNode.label;
        // Hover effects
        nodeLink.addEventListener('mouseenter', () => {
          nodeLink.style.backgroundColor = '#e0e0e0';
        });
        nodeLink.addEventListener('mouseleave', () => {
          nodeLink.style.backgroundColor = '#f0f0f0';
        });
        // Click to navigate to the connected node
        nodeLink.addEventListener('click', () => {
          this.panToNode(connectedNode);
          this.hideInfo(); // Hide current info panel
          // Show info for the new node after a short delay
          setTimeout(() => {
            this.showNodeInfo(connectedNode);
          }, 300);
        });
        section.appendChild(nodeLink);
      }
    });
    return section;
  }
  /**
   * Pan the graph to focus on a specific node
   */
  panToNode(node) {
    if (!this.graph || !node.x || !node.y) return;
    // Use the graph's focusOnNode method if available
    if (typeof this.graph.focusOnNode === 'function') {
      this.graph.focusOnNode(node.id);
    } else {
      // Fallback: trigger a navigation event
      console.log('Panning to node:', node.label);
      // You could implement custom panning logic here if needed
    }
  }
  /**
   * Hide the info panel
   */
  hideInfo() {
    if (this.infoPanel) {
      this.infoPanel.style.display = 'none';
    }
    this.selectedNode = null;
  }
  /**
   * Get current UI state
   */
  getState() {
    return {
      activeLayer: this.activeLayer,
      currentTimelinePosition: this.currentTimelinePosition,
      selectedNode: this.selectedNode ? this.selectedNode.id : null,
      layerCount: this.layers.length
    };
  }
  /**
   * Add event listener
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }
  /**
   * Emit event
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in UI event handler for ${eventType}:`, error);
        }
      });
    }
  }
  /**
   * Cleanup and destroy UI controls
   */
  destroy() {
    if (this.uiContainer && this.uiContainer.parentNode) {
      this.uiContainer.parentNode.removeChild(this.uiContainer);
    }
    this.eventHandlers = {};
  }
}
// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = UIControlsManager;
} else if (typeof window !== 'undefined') {
  window.UIControlsManager = UIControlsManager;
}
// core/KnowledgeGraphExplorer.js
/**
 * Knowledge Graph Explorer - Main Orchestrating Class
 * Coordinates all modular components to create an interactive knowledge graph
 */
class KnowledgeGraphExplorer {
  constructor(container, data, config = {}) {
    this.container = typeof container === 'string' 
      ? document.querySelector(container) 
      : container;
    if (!this.container) {
      throw new Error('Container element not found');
    }
    // Validate data before proceeding
    this.validateAndProcessData(data);
    // Configuration with sensible defaults
    this.config = this.mergeConfigurations(config);
    // Initialize modular components
    this.components = {
      dataValidator: null,
      coordinateTransform: null,
      forceSimulation: null,
      interactionManager: null,
      visualEffectsManager: null,
      miniMapManager: null
    };
    // State management
    this.state = {
      currentLayer: null,
      isTimelineActive: false,
      currentTimelinePosition: null,
      isInitialized: false
    };
    // Event handlers for external API
    this.eventHandlers = {};
    // Initialize the graph
    this.init();
  }
  /**
   * Validate and process input data
   * @param {Object} data - Input data with nodes and links
   */
  validateAndProcessData(data) {
    // Use DataValidator if available, otherwise basic validation
    if (typeof DataValidator !== 'undefined') {
      // Create a copy of data with string IDs for validation
      const dataForValidation = {
        nodes: [...data.nodes],
        links: data.links.map(link => ({
          ...link,
          source: typeof link.source === 'object' ? link.source.id : link.source,
          target: typeof link.target === 'object' ? link.target.id : link.target
        }))
      };
      const validation = DataValidator.validate(dataForValidation);      if (!validation.isValid) {
        console.warn('Data validation warnings:', validation.errors);
        if (validation.errors.length > 0) {
          throw new Error(`Data validation failed: ${validation.errors[0]}`);
        }
      }
    } else {
      // Basic validation fallback
      if (!data || !data.nodes || !data.links) {
        throw new Error('Data must contain nodes and links arrays');
      }
    }
    this.originalData = data;
    this.allNodes = [...data.nodes];
    this.allLinks = [...data.links];
    this.nodes = [...data.nodes];
    this.links = [...data.links];
  }
  /**
   * Merge user configuration with defaults
   * @param {Object} userConfig - User-provided configuration
   * @returns {Object} - Merged configuration
   */
  mergeConfigurations(userConfig) {
    const defaultConfig = {
      // Container dimensions
      width: 900,
      height: 600,
      // Visual theme
      theme: {
        primaryColor: '#2780e3',
        secondaryColor: '#3fb618',
        accentColor: '#ffdd3c',
        dangerColor: '#ff0039',
        mutedColor: '#868e96',
        backgroundColor: '#ffffff',
        surfaceColor: '#f8f9fa',
        textPrimary: '#212529',
        textSecondary: '#495057',
        textMuted: '#868e96',
        borderColor: '#dee2e6',
        fontFamily: 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
        fontSizeBase: 14,
        fontSizeSmall: 12,
        fontSizeLarge: 16,
        borderRadius: 6,
        shadowColor: 'rgba(0, 0, 0, 0.15)'
      },
      // Node colors - completely configurable, no hardcoded categories
      nodeColors: {},
      // Layer configuration - user-defined
      layers: [],
      // Timeline configuration
      timeline: {
        enabled: true,
        start: null, // Auto-calculated if not provided
        end: null    // Auto-calculated if not provided
      },
      // Feature toggles
      features: {
        showMiniMap: true,
        showTimeline: true,
        showLegend: true,
        enableHover: true,
        enableDrag: true,
        enableLayerMode: true,
        clickToNavigate: true
      },
      // Interaction settings
      interaction: {
        hoverRadius: 50,
        maxHoverScale: 1.3,
        clickRadius: 20,
        dragThreshold: 5
      },
      // Force simulation settings
      simulation: {
        linkDistance: 120,
        linkStrength: 0.3,
        chargeStrength: -400,
        chargeDistanceMax: 500,
        collisionRadius: 25
      },
      // Visual effects settings
      effects: {
        hoverTransitionDuration: 100,
        layerTransitionDuration: 400,
        distanceScaling: {
          distance1: 0.9,
          distance2: 0.7,
          distance3: 0.5,
          distanceOther: 0.3
        }
      },
      // MiniMap settings
      miniMap: {
        width: 150,
        height: 120,
        position: 'bottom-left',
        padding: 10
      }
    };
    return this.deepMerge(defaultConfig, userConfig);
  }
  /**
   * Deep merge two objects
   * @param {Object} target - Target object
   * @param {Object} source - Source object
   * @returns {Object} - Merged object
   */
  deepMerge(target, source) {
    const result = { ...target };
    for (const key in source) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        result[key] = this.deepMerge(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
    return result;
  }
  /**
   * Initialize all components and setup the graph
   */
  init() {
    this.setupContainer();
    this.setupSVG();
    this.initializeComponents();
    this.setupEventBindings();
    this.render();
    this.startSimulation();
    this.state.isInitialized = true;
    this.emit('initialized', { config: this.config, state: this.state });
  }
  /**
   * Setup the container element
   */
  setupContainer() {
    this.container.innerHTML = '';
    this.container.style.position = 'relative';
    this.container.style.width = this.config.width + 'px';
    this.container.style.height = this.config.height + 'px';
    this.container.style.backgroundColor = this.config.theme.backgroundColor;
    this.container.style.overflow = 'hidden';
    this.container.style.borderRadius = this.config.theme.borderRadius + 'px';
    this.container.style.fontFamily = this.config.theme.fontFamily;
  }
  /**
   * Setup SVG and its groups
   */
  setupSVG() {
    this.svg = d3.select(this.container)
      .append('svg')
      .attr('width', this.config.width)
      .attr('height', this.config.height);
    this.mainGroup = this.svg.append('g').attr('class', 'main-group');
    this.linkGroup = this.mainGroup.append('g').attr('class', 'links');
    this.nodeGroup = this.mainGroup.append('g').attr('class', 'nodes');
    this.labelGroup = this.mainGroup.append('g').attr('class', 'labels');
    // Setup zoom behavior
    this.zoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        this.handleZoom(event);
      });
    this.svg.call(this.zoom);
  }
  /**
   * Initialize all modular components
   */
  initializeComponents() {
    // Initialize coordinate transform
    this.components.coordinateTransform = new CoordinateTransform();
    this.components.coordinateTransform.updateViewport(this.config.width, this.config.height);
    // Initialize force simulation
    this.components.forceSimulation = new ForceSimulation(this.config.simulation);
    this.components.forceSimulation.updateDimensions(this.config.width, this.config.height);
    this.components.forceSimulation.onTickCallback(() => this.updatePositions());
    // Initialize visual effects manager
    this.components.visualEffectsManager = new VisualEffectsManager({
      ...this.config.effects,
      theme: this.config.theme
    });
    // Initialize interaction manager
    this.components.interactionManager = new InteractionManager({
      ...this.config.interaction,
      hoverEnabled: this.config.features.enableHover,
      dragEnabled: this.config.features.enableDrag
    });
    // Initialize minimap if enabled
    if (this.config.features.showMiniMap) {
      this.components.miniMapManager = new MiniMapManager({
        ...this.config.miniMap,
        backgroundColor: this.config.theme.surfaceColor + 'E6',
        borderColor: this.config.theme.primaryColor
      });
    }
  }
  /**
   * Setup event bindings between components
   */
  setupEventBindings() {
    // Interaction events
    if (this.components.interactionManager) {
      const elements = {
        svg: this.svg,
        nodes: this.nodeGroup.selectAll('.node'),
        links: this.linkGroup.selectAll('.link'),
        labels: this.labelGroup.selectAll('.label')
      };
      this.components.interactionManager.initialize(elements, this.components.coordinateTransform);
      this.components.interactionManager.updateData(this.nodes, this.links);
      // Bind interaction events
      this.components.interactionManager.on('nodeClick', (data) => {
        this.emit('nodeClick', data);
      });
      this.components.interactionManager.on('linkClick', (data) => {
        this.emit('linkClick', data);
      });
      this.components.interactionManager.on('nodeHover', (data) => {
        if (this.config.features.enableHover && this.components.visualEffectsManager) {
          this.components.visualEffectsManager.applyContinuousHoverEffects(
            data.node, data.distance, data.mousePosition
          );
        }
      });
      this.components.interactionManager.on('hoverReset', () => {
        if (this.components.visualEffectsManager) {
          this.components.visualEffectsManager.resetHoverEffects();
        }
      });
      this.components.interactionManager.on('dragStart', (data) => {
        this.emit('dragStart', data);
      });
      this.components.interactionManager.on('dragEnd', (data) => {
        this.emit('dragEnd', data);
      });
    }
    // Visual effects initialization
    if (this.components.visualEffectsManager) {
      const elements = {
        nodes: this.nodeGroup.selectAll('.node'),
        links: this.linkGroup.selectAll('.link'),
        labels: this.labelGroup.selectAll('.label')
      };
      this.components.visualEffectsManager.initialize(elements);
      this.components.visualEffectsManager.updateData(this.nodes, this.links);
    }
    // MiniMap initialization and events
    if (this.components.miniMapManager) {
      this.components.miniMapManager.initialize(this.container, this.components.coordinateTransform);
      this.components.miniMapManager.updateData(this.nodes, this.links);
      this.components.miniMapManager.on('navigate', (data) => {
        this.navigateToPosition(data.graphPosition);
      });
    }
  }
  /**
   * Handle zoom events
   * @param {Object} event - D3 zoom event
   */
  handleZoom(event) {
    this.components.coordinateTransform.updateTransform(event.transform);
    this.mainGroup.attr('transform', event.transform);
    if (this.components.miniMapManager) {
      this.components.miniMapManager.updateViewportIndicator();
    }
    this.emit('zoom', { transform: event.transform });
  }
  /**
   * Render all visual elements
   */
  render() {
    this.renderLinks();
    this.renderNodes();
    this.renderLabels();
    // Update component references
    this.updateComponentElements();
  }
  /**
   * Update component element references after rendering
   */
  updateComponentElements() {
    const elements = {
      nodes: this.nodeGroup.selectAll('.node'),
      links: this.linkGroup.selectAll('.link'),
      labels: this.labelGroup.selectAll('.label')
    };
    if (this.components.interactionManager) {
      this.components.interactionManager.nodeElements = elements.nodes;
      this.components.interactionManager.linkElements = elements.links;
      this.components.interactionManager.labelElements = elements.labels;
      this.components.interactionManager.setupNodeInteractions();
      this.components.interactionManager.setupLinkInteractions();
    }
    if (this.components.visualEffectsManager) {
      this.components.visualEffectsManager.nodeElements = elements.nodes;
      this.components.visualEffectsManager.linkElements = elements.links;
      this.components.visualEffectsManager.labelElements = elements.labels;
    }
  }
  /**
   * Render links
   */
  renderLinks() {
    const linkSelection = this.linkGroup
      .selectAll('.link')
      .data(this.links, d => `${this.getLinkSourceId(d)}-${this.getLinkTargetId(d)}`);
    linkSelection.exit().remove();
    linkSelection.enter()
      .append('line')
      .attr('class', 'link')
      .attr('stroke', this.config.theme.mutedColor)
      .attr('stroke-width', d => Math.sqrt(d.strength || 0.5) * 2)
      .attr('stroke-opacity', 0.6);
  }
  /**
   * Render nodes with experience-based styling
   */
  renderNodes() {
    const nodeSelection = this.nodeGroup
      .selectAll('.node')
      .data(this.nodes, d => d.id);
    nodeSelection.exit().remove();
    nodeSelection.enter()
      .append('circle')
      .attr('class', 'node')
      .attr('r', d => d.size || 10)
      .attr('fill', d => this.getNodeColor(d))
      .attr('stroke', d => this.getNodeStrokeColor(d))
      .attr('stroke-width', d => this.getNodeStrokeWidth(d))
      .style('cursor', 'pointer');
  }
  /**
   * Get stroke color for nodes based on experience level
   * @param {Object} node - Node object
   * @returns {string} - Stroke color
   */
  getNodeStrokeColor(node) {
    // Default to "experienced" if no experienceLevel specified
    const experienceLevel = node.experienceLevel || 'experienced';
    if (experienceLevel === 'interested') {
      // Lighter stroke for interested nodes
      return this.lightenColor(this.config.theme.textPrimary, 0.5);
    }
    // Full stroke for experienced nodes
    return this.config.theme.textPrimary;
  }
  /**
   * Get stroke width for nodes based on experience level
   * @param {Object} node - Node object
   * @returns {number} - Stroke width
   */
  getNodeStrokeWidth(node) {
    // Default to "experienced" if no experienceLevel specified
    const experienceLevel = node.experienceLevel || 'experienced';
    if (experienceLevel === 'interested') {
      return 1; // Thinner stroke for interested
    }
    return 2; // Standard stroke for experienced
  }
  /**
   * Render labels
   */
  renderLabels() {
    const labelSelection = this.labelGroup
      .selectAll('.label')
      .data(this.nodes, d => d.id);
    labelSelection.exit().remove();
    labelSelection.enter()
      .append('text')
      .attr('class', 'label')
      .attr('text-anchor', 'middle')
      .attr('dy', '0.35em')
      .attr('font-family', this.config.theme.fontFamily)
      .attr('font-size', this.config.theme.fontSizeSmall + 'px')
      .attr('fill', this.config.theme.textPrimary)
      .attr('pointer-events', 'none')
      .style('user-select', 'none')
      .text(d => d.label);
  }
  /**
   * Get node color based on configuration, with support for experience levels
   * @param {Object} node - Node object
   * @returns {string} - Color value
   */
  getNodeColor(node) {
    let baseColor;
    // Get base color from type, layer, or default
    if (node.type && this.config.nodeColors[node.type]) {
      baseColor = this.config.nodeColors[node.type];
    } else if (node.layer && this.config.nodeColors[node.layer]) {
      baseColor = this.config.nodeColors[node.layer];
    } else if (node.color) {
      baseColor = node.color;
    } else {
      baseColor = this.config.theme.primaryColor;
    }
    // Apply experience-based opacity/saturation
    if (node.experienceLevel) {
      return this.adjustColorForExperience(baseColor, node.experienceLevel);
    }
    return baseColor;
  }
  /**
   * Adjust color based on experience level
   * @param {string} baseColor - Base color (hex format)
   * @param {string} experienceLevel - 'experienced' or 'interested'
   * @returns {string} - Adjusted color
   */
  adjustColorForExperience(baseColor, experienceLevel) {
    if (experienceLevel === 'interested') {
      // Make color lighter/less saturated for interest-only
      return this.lightenColor(baseColor, 0.4); // 40% lighter
    }
    // For 'experienced' or any other value, return full saturation
    return baseColor;
  }
  /**
   * Lighten a hex color by a given factor
   * @param {string} color - Hex color (e.g., "#2780e3")
   * @param {number} factor - Lightening factor (0-1, where 1 is white)
   * @returns {string} - Lightened hex color
   */
  lightenColor(color, factor) {
    // Remove # if present
    const hex = color.replace('#', '');
    // Parse RGB values
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    // Lighten each component
    const newR = Math.round(r + (255 - r) * factor);
    const newG = Math.round(g + (255 - g) * factor);
    const newB = Math.round(b + (255 - b) * factor);
    // Convert back to hex
    const toHex = (n) => {
      const hex = n.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
  }
  /**
   * Helper to get link source ID
   */
  getLinkSourceId(link) {
    return typeof link.source === 'object' ? link.source.id : link.source;
  }
  /**
   * Helper to get link target ID
   */
  getLinkTargetId(link) {
    return typeof link.target === 'object' ? link.target.id : link.target;
  }
  /**
   * Update positions during simulation tick
   */
  updatePositions() {
    this.linkGroup.selectAll('.link')
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);
    this.nodeGroup.selectAll('.node')
      .attr('cx', d => d.x)
      .attr('cy', d => d.y);
    this.labelGroup.selectAll('.label')
      .attr('x', d => d.x)
      .attr('y', d => d.y + (d.size || 10) + 18);
    if (this.components.miniMapManager) {
      this.components.miniMapManager.render();
    }
  }
  /**
   * Start the force simulation
   */
  startSimulation() {
    if (this.components.forceSimulation) {
      this.components.forceSimulation.updateData(this.nodes, this.links);
    }
  }
  /**
   * Navigate to a specific position
   * @param {Object} position - {x, y} position in graph coordinates
   */
  navigateToPosition(position) {
    const scale = 1.5;
    const centerX = this.config.width / 2;
    const centerY = this.config.height / 2;
    const newTransform = d3.zoomIdentity
      .translate(centerX - position.x * scale, centerY - position.y * scale)
      .scale(scale);
    this.svg.transition()
      .duration(750)
      .call(this.zoom.transform, newTransform);
  }
  // ====== PUBLIC API METHODS ======
  /**
   * Set active layer
   * @param {string|null} layerId - Layer ID or null for all layers
   */
  setActiveLayer(layerId) {
    this.state.currentLayer = layerId;
    if (this.components.visualEffectsManager) {
      this.components.visualEffectsManager.applyLayerEffects(layerId);
    }
    if (this.components.interactionManager) {
      this.components.interactionManager.updateLayerMode(layerId !== null);
    }
    this.emit('layerChange', { layer: layerId });
  }
  /**
   * Show all layers
   */
  showAllLayers() {
    this.setActiveLayer(null);
  }
  /**
   * Update data and refresh the graph
   * @param {Object} newData - New data object
   */
  updateData(newData) {
    this.validateAndProcessData(newData);
    // Update all components with new data
    Object.values(this.components).forEach(component => {
      if (component && component.updateData) {
        component.updateData(this.nodes, this.links);
      }
    });
    this.render();
    this.startSimulation();
    this.emit('dataUpdate', { nodeCount: this.nodes.length, linkCount: this.links.length });
  }
  /**
   * Focus on a specific node
   * @param {string} nodeId - Node ID
   */
  focusOnNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node.x !== undefined && node.y !== undefined) {
      this.navigateToPosition({ x: node.x, y: node.y });
      this.emit('nodeFocus', { node });
    }
  }
  /**
   * Restart the simulation
   */
  restartSimulation() {
    if (this.components.forceSimulation) {
      this.components.forceSimulation.restart();
    }
  }
  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    this.config = this.deepMerge(this.config, newConfig);
    // Update components with new config
    Object.values(this.components).forEach(component => {
      if (component && component.updateConfig) {
        component.updateConfig(newConfig);
      }
    });
    this.emit('configUpdate', { config: this.config });
  }
  /**
   * Add event listener
   * @param {string} eventType - Event type
   * @param {Function} callback - Callback function
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }
  /**
   * Remove event listener
   * @param {string} eventType - Event type
   * @param {Function} callback - Callback function
   */
  off(eventType, callback) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = this.eventHandlers[eventType].filter(cb => cb !== callback);
    }
    return this;
  }
  /**
   * Emit event
   * @param {string} eventType - Event type
   * @param {Object} data - Event data
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event handler for ${eventType}:`, error);
        }
      });
    }
  }
  /**
   * Get current state and statistics
   * @returns {Object} - Current state information
   */
  getState() {
    return {
      ...this.state,
      nodeCount: this.nodes.length,
      linkCount: this.links.length,
      config: this.config,
      components: Object.keys(this.components).reduce((acc, key) => {
        acc[key] = this.components[key] ? 'initialized' : 'not available';
        return acc;
      }, {})
    };
  }
  /**
   * Cleanup and destroy the graph
   */
  destroy() {
    // Destroy all components
    Object.values(this.components).forEach(component => {
      if (component && component.destroy) {
        component.destroy();
      }
    });
    // Clear container
    this.container.innerHTML = '';
    // Clear references
    this.eventHandlers = {};
    this.components = {};
    this.nodes = [];
    this.links = [];
  }
}
// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = KnowledgeGraphExplorer;
} else if (typeof window !== 'undefined') {
  window.KnowledgeGraphExplorer = KnowledgeGraphExplorer;
}
        // Initialize when ready
        function initGraph() {
            try {
                console.log('Starting graph initialization...');
                // Decode base64 data
                const dataStr = atob('eyJub2RlcyI6IFt7ImlkIjogImJpdHNfdW5kZXJncmFkIiwgImxhYmVsIjogIkJJVFMgSHlkZXJhYmFkIiwgImxheWVyIjogImVkdWNhdGlvbiIsICJzaXplIjogMTUwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAwOSwgImVuZCI6IDIwMTR9LCAiZGVzY3JpcHRpb24iOiAiTVNjIGluIFBoeXNpY3MgJiBCYWNoZWxvcnMgaW4gUGhhcm1hY3kgYXQgQmlybGEgSW5zdGl0dXRlIG9mIFRlY2hub2xvZ3kgYW5kIFNjaWVuY2VzLCBIeWRlcmFiYWQuIFdoZXJlIHRoZSBwaHlzaWNzIGpvdXJuZXkgYmVnYW4uIn0sIHsiaWQiOiAibG11X3RoZXNpcyIsICJsYWJlbCI6ICJMTVUgTXVuaWNoIiwgInR5cGUiOiAiZWR1Y2F0aW9uIiwgImxheWVyIjogImVkdWNhdGlvbiIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDEzLCAiZW5kIjogMjAxNH0sICJkZXNjcmlwdGlvbiI6ICJWaXNpdGluZyBzdHVkZW50IGZvciBNYXN0ZXIncyB0aGVzaXMgYXQgTHVkd2lnIE1heGltaWxpYW5zIFVuaXZlcnNpdHkuIEZpcnN0IGRlZXAgZGl2ZSBpbnRvIHF1YW50dW0gZm91bmRhdGlvbnMgd2l0aCBEZXRsZWYgRFx1MDBmY3JyJ3MgZ3JvdXAuIn0sIHsiaWQiOiAiYXJpem9uYV9waGQiLCAibGFiZWwiOiAiVW5pdmVyc2l0eSBvZiBBcml6b25hIiwgInR5cGUiOiAiZWR1Y2F0aW9uIiwgImxheWVyIjogImVkdWNhdGlvbiIsICJzaXplIjogMTgsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE1LCAiZW5kIjogMjAyMX0sICJkZXNjcmlwdGlvbiI6ICJQaEQgaW4gUGh5c2ljcyBmb2N1c2luZyBvbiBibGFjayBob2xlIHBoeXNpY3MuIExlYXJuZWQgdG8gc2l0IHdpdGggaGFyZCBwcm9ibGVtcyBmb3IgbW9udGhzLCB0aGVuIHN1ZGRlbmx5IHNlZSB0aGUgcGF0aCBmb3J3YXJkLiJ9LCB7ImlkIjogImRhdGFfaW5jdWJhdG9yIiwgImxhYmVsIjogIkRhdGEgSW5jdWJhdG9yIiwgInR5cGUiOiAiZWR1Y2F0aW9uIiwgImxheWVyIjogImVkdWNhdGlvbiIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIxLCAiZW5kIjogMjAyMX0sICJkZXNjcmlwdGlvbiI6ICJEYXRhIFNjaWVuY2UgRmVsbG93c2hpcC4gQnJpZGdlIGJldHdlZW4gYWNhZGVtaWEgYW5kIGluZHVzdHJ5LCBsZWFybmluZyB0byB3b3JrIHdpdGggbWVzc3ksIHJlYWwtd29ybGQgZGF0YS4ifSwgeyJpZCI6ICJzdGFuZm9yZF9haSIsICJsYWJlbCI6ICJTdGFuZm9yZCBBSSBQcm9ncmFtIiwgInR5cGUiOiAiZWR1Y2F0aW9uIiwgImxheWVyIjogImN1cnJlbnQiLCAic2l6ZSI6IDE0LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyNCwgImVuZCI6IDIwMjV9LCAiZGVzY3JpcHRpb24iOiAiQUkgR3JhZHVhdGUgQ2VydGlmaWNhdGUuIEN1cnJlbnQgZXhwbG9yYXRpb24gaW50byBnYW1lIHRoZW9yeSwgcmVpbmZvcmNlbWVudCBsZWFybmluZywgYW5kIGVjb25vbWljcyBpbnRlcnNlY3Rpb24uIn0sIHsiaWQiOiAiYm9obWlhbl9tZWNoYW5pY3MiLCAibGFiZWwiOiAiQm9obWlhbiBNZWNoYW5pY3MiLCAidHlwZSI6ICJyZXNlYXJjaCIsICJsYXllciI6ICJyZXNlYXJjaCIsICJzaXplIjogMTQsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDEzLCAiZW5kIjogMjAxNX0sICJkZXNjcmlwdGlvbiI6ICJSZXNlYXJjaCB3aXRoIERldGxlZiBEXHUwMGZjcnIgb24gcXVhbnR1bSBmb3VuZGF0aW9ucy4gQm90dG9tLXVwIGFwcHJvYWNoIHRvIGZ1bmRhbWVudGFsIHRoZW9yeSB3aXRoIG9udG9sb2dpY2FsIGRlc2NyaXB0aW9ucyBvZiBuYXR1cmUuIn0sIHsiaWQiOiAiYmxhY2tfaG9sZV9waHlzaWNzIiwgImxhYmVsIjogIkJsYWNrIEhvbGUgUGh5c2ljcyIsICJ0eXBlIjogInJlc2VhcmNoIiwgImxheWVyIjogInJlc2VhcmNoIiwgInNpemUiOiAxNiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTUsICJlbmQiOiAyMDIxfSwgImRlc2NyaXB0aW9uIjogIlBoRCByZXNlYXJjaCBvbiBibGFjayBob2xlcy4gU3RhcnRlZCB3aXRoIHNlbGYtZm9yY2UgcHJvYmxlbXMsIGVuZGVkIHVwIGRlZXAgaW4gYmxhY2sgaG9sZSBwaHlzaWNzLiBQdWJsaXNoZWQgd29yayBvbiB0aGVvcmV0aWNhbCBhc3BlY3RzLiJ9LCB7ImlkIjogImRhdGFfc2NpZW5jZV9tZXRob2RzIiwgImxhYmVsIjogIkRhdGEgU2NpZW5jZSAmIE1MIiwgInR5cGUiOiAicmVzZWFyY2giLCAibGF5ZXIiOiAicmVzZWFyY2giLCAic2l6ZSI6IDE1LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMSwgImVuZCI6IDIwMjV9LCAiZGVzY3JpcHRpb24iOiAiVHJhbnNpdGlvbiBmcm9tIGV4YWN0IHNvbHV0aW9ucyB0byB0aGlua2luZyBpbiBkaXN0cmlidXRpb25zIGFuZCBwcm9iYWJpbGl0aWVzLiBQcm9ncmFtbWluZyBvcGVucyB1cCBuZXcgdHlwZXMgb2YgcXVlc3Rpb25zLiJ9LCB7ImlkIjogImFpX2dhbWVfdGhlb3J5IiwgImxhYmVsIjogIkFJICYgR2FtZSBUaGVvcnkiLCAidHlwZSI6ICJyZXNlYXJjaCIsICJsYXllciI6ICJjdXJyZW50IiwgInNpemUiOiAxMiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjQsICJlbmQiOiAyMDI1fSwgImRlc2NyaXB0aW9uIjogIkN1cnJlbnQgb2JzZXNzaW9uOiBpbnRlcnNlY3Rpb24gb2YgZ2FtZSB0aGVvcnksIHJlaW5mb3JjZW1lbnQgbGVhcm5pbmcsIGFuZCBlY29ub21pY3MuIFdoZXJlIGJvdHRvbS11cCBhbmQgdG9wLWRvd24gdGhpbmtpbmcgcGxheSBuaWNlLiJ9LCB7ImlkIjogInJvdmVyIiwgImxhYmVsIjogIlJvdmVyIiwgInR5cGUiOiAiaW5kdXN0cnkiLCAibGF5ZXIiOiAiaW5kdXN0cnkiLCAic2l6ZSI6IDE2LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMSwgImVuZCI6IDIwMjR9LCAiZGVzY3JpcHRpb24iOiAiRGF0YSBTY2llbnRpc3QgSUkgJiBJSUkgaW4gU2VhdHRsZS4gRmlyc3QgcG9zaXRpb24gb3V0c2lkZSBhY2FkZW1pYSB3b3JraW5nIHdpdGggYW1hemluZyBwZW9wbGUuIEV2ZXJ5dGhpbmcgY2xpY2tlZCBkaWZmZXJlbnRseSAtIGZyb20gZnVuZGFtZW50YWwgZHluYW1pY3MgdG8gcHJhY3RpY2FsIGluc2lnaHRzIGZyb20gbWVzc3kgZGF0YS4ifSwgeyJpZCI6ICJ0dXJubyIsICJsYWJlbCI6ICJUdXJubyIsICJ0eXBlIjogImluZHVzdHJ5IiwgImxheWVyIjogImN1cnJlbnQiLCAic2l6ZSI6IDEyLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyNCwgImVuZCI6IDIwMjV9LCAiZGVzY3JpcHRpb24iOiAiRGF0YSBTY2llbnRpc3QgY29uc3VsdGFudCBpbiBWYW5jb3V2ZXIuIEFub3RoZXIgMi1zaWRlZCBtYXJrZXRwbGFjZSAoYXBwYXJlbnRseSBJIGhhdmUgYSB0eXBlKS4gQXBwbHlpbmcgQUkgYW5kIGdhbWUgdGhlb3J5IHRvIHJlYWwtd29ybGQgcHJvYmxlbXMuIn0sIHsiaWQiOiAiaW5kaWEiLCAibGFiZWwiOiAiSW5kaWEiLCAidHlwZSI6ICJnZW9ncmFwaGljIiwgImxheWVyIjogImdlb2dyYXBoaWMiLCAic2l6ZSI6IDEyLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAwOSwgImVuZCI6IDIwMTN9LCAiZGVzY3JpcHRpb24iOiAiSG9tZSBiYXNlIGluIEh5ZGVyYWJhZC4gV2hlcmUgY3VyaW9zaXR5IGFib3V0IHF1YW50dW0gZm91bmRhdGlvbnMgZmlyc3Qgc3BhcmtlZC4ifSwgeyJpZCI6ICJtdW5pY2giLCAibGFiZWwiOiAiTXVuaWNoIiwgInR5cGUiOiAiZ2VvZ3JhcGhpYyIsICJsYXllciI6ICJnZW9ncmFwaGljIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTMsICJlbmQiOiAyMDE0fSwgImRlc2NyaXB0aW9uIjogIkZpcnN0IGludGVybmF0aW9uYWwgZXhwZXJpZW5jZS4gSW1tZXJzaW9uIGluIHJpZ29yb3VzIHF1YW50dW0gZm91bmRhdGlvbnMgcmVzZWFyY2ggd2l0aCBEXHUwMGZjcnIncyBncm91cC4ifSwgeyJpZCI6ICJ0dWNzb24iLCAibGFiZWwiOiAiVHVjc29uIiwgInR5cGUiOiAiZ2VvZ3JhcGhpYyIsICJsYXllciI6ICJnZW9ncmFwaGljIiwgInNpemUiOiAxNCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTUsICJlbmQiOiAyMDIxfSwgImRlc2NyaXB0aW9uIjogIlBoRCB5ZWFycyBpbiBBcml6b25hLiBJbnRlbnNlIGluIHVuZXhwZWN0ZWQgd2F5cy4gTGVhcm5lZCBwYXRpZW5jZSB3aXRoIGhhcmQgcHJvYmxlbXMgYW5kIGRldmVsb3BlZCBhcHByZWNpYXRpb24gZm9yIG1hdGhlbWF0aWNzIGl0c2VsZi4ifSwgeyJpZCI6ICJzZWF0dGxlIiwgImxhYmVsIjogIlNlYXR0bGUiLCAidHlwZSI6ICJnZW9ncmFwaGljIiwgImxheWVyIjogImdlb2dyYXBoaWMiLCAic2l6ZSI6IDEyLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMSwgImVuZCI6IDIwMjR9LCAiZGVzY3JpcHRpb24iOiAiTW92ZSBtb3RpdmF0ZWQgYnkgU2NobnVja2kgYW5kIGxvdmUgZm9yIGdsb29teSwgZHJpenpseSB3ZWF0aGVyIGFuZCBiZWF1dGlmdWwgb3V0ZG9vcnMuIEluZHVzdHJ5IHRyYW5zaXRpb24gYW5kIG5ldyBwZXJzcGVjdGl2ZXMuIn0sIHsiaWQiOiAidmFuY291dmVyIiwgImxhYmVsIjogIlZhbmNvdXZlciIsICJ0eXBlIjogImdlb2dyYXBoaWMiLCAibGF5ZXIiOiAiY3VycmVudCIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDI0LCAiZW5kIjogMjAyNX0sICJkZXNjcmlwdGlvbiI6ICJDdXJyZW50IGhvbWUgYmFzZS4gTG9uZy10ZXJtIGltbWlncmF0aW9uIHN0YWJpbGl0eS4gQ29udGludWluZyB0aGUgam91cm5leSBpbiBBSSBhbmQgZ2FtZSB0aGVvcnkuIn0sIHsiaWQiOiAiZGV0bGVmX2R1cnIiLCAibGFiZWwiOiAiRGV0bGVmIERcdTAwZmNyciIsICJ0eXBlIjogInJlc2VhcmNoIiwgImxheWVyIjogInJlc2VhcmNoIiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMywgImVuZCI6IDIwMTR9LCAiZGVzY3JpcHRpb24iOiAiTGF0ZSBtZW50b3IgYXQgTE1VIE11bmljaC4gSGlzIHJlc2VhcmNoIGdyb3VwIHdhcyBmdWxsIG9mIGlucXVpc2l0aXZlIHBlb3BsZSB3aG8gZGVlcGx5IGNhcmVkIGFib3V0IHRoZWlyIHdvcmsuIEZvdW5kYXRpb25hbCBpbmZsdWVuY2Ugb24gYXBwcm9hY2ggdG8gcGh5c2ljcy4ifSwgeyJpZCI6ICJzYW1fZ3JhbGxhIiwgImxhYmVsIjogIlNhbSBHcmFsbGEiLCAidHlwZSI6ICJyZXNlYXJjaCIsICJsYXllciI6ICJyZXNlYXJjaCIsICJzaXplIjogOCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTUsICJlbmQiOiAyMDIxfSwgImRlc2NyaXB0aW9uIjogIlBoRCBhZHZpc29yIGF0IFVuaXZlcnNpdHkgb2YgQXJpem9uYS4gSW5pdGlhbGx5IHBsYW5uZWQgdG8gd29yayBvbiBzZWxmLWZvcmNlIHByb2JsZW0sIGJ1dCByZXNlYXJjaCBldm9sdmVkIGludG8gYnJvYWRlciBibGFjayBob2xlIHBoeXNpY3MuIn0sIHsiaWQiOiAic2NobnVja2kiLCAibGFiZWwiOiAiU2NobnVja2kiLCAidHlwZSI6ICJnZW9ncmFwaGljIiwgImxheWVyIjogImdlb2dyYXBoaWMiLCAic2l6ZSI6IDYsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIwLCAiZW5kIjogMjAyNX0sICJkZXNjcmlwdGlvbiI6ICJCcm93bi1leWVkIGNvbXBhbmlvbiB3aXRoIGluZmluaXRlIGNhcGFjaXR5IGZvciBsb3ZlLiBIZXIgbmVlZCBmb3IgZnJlZWRvbSB0byBydW4gYXJvdW5kIGluZmx1ZW5jZWQgbWFqb3IgbGlmZSBkZWNpc2lvbnMgaW5jbHVkaW5nIG1vdmUgdG8gU2VhdHRsZS4ifV0sICJsaW5rcyI6IFt7InNvdXJjZSI6ICJiaXRzX3VuZGVyZ3JhZCIsICJ0YXJnZXQiOiAibG11X3RoZXNpcyIsICJzdHJlbmd0aCI6IDAuOSwgImRlc2NyaXB0aW9uIjogIlBoeXNpY3MgZGVncmVlIGxlZCB0byByZXNlYXJjaCBvcHBvcnR1bml0eSBpbiBNdW5pY2gifSwgeyJzb3VyY2UiOiAibG11X3RoZXNpcyIsICJ0YXJnZXQiOiAiYXJpem9uYV9waGQiLCAic3RyZW5ndGgiOiAwLjgsICJkZXNjcmlwdGlvbiI6ICJRdWFudHVtIGZvdW5kYXRpb25zIHdvcmsgb3BlbmVkIHBhdGggdG8gUGhEIHN0dWRpZXMifSwgeyJzb3VyY2UiOiAiYXJpem9uYV9waGQiLCAidGFyZ2V0IjogImRhdGFfaW5jdWJhdG9yIiwgInN0cmVuZ3RoIjogMC43LCAiZGVzY3JpcHRpb24iOiAiVHJhbnNpdGlvbiBmcm9tIGFjYWRlbWlhIHRvIGRhdGEgc2NpZW5jZSJ9LCB7InNvdXJjZSI6ICJkYXRhX2luY3ViYXRvciIsICJ0YXJnZXQiOiAicm92ZXIiLCAic3RyZW5ndGgiOiAwLjksICJkZXNjcmlwdGlvbiI6ICJGZWxsb3dzaGlwIGxlZCBkaXJlY3RseSB0byBmaXJzdCBpbmR1c3RyeSBwb3NpdGlvbiJ9LCB7InNvdXJjZSI6ICJyb3ZlciIsICJ0YXJnZXQiOiAic3RhbmZvcmRfYWkiLCAic3RyZW5ndGgiOiAwLjYsICJkZXNjcmlwdGlvbiI6ICJJbmR1c3RyeSBleHBlcmllbmNlIG1vdGl2YXRlZCBkZWVwZXIgQUkgZWR1Y2F0aW9uIn0sIHsic291cmNlIjogImJpdHNfdW5kZXJncmFkIiwgInRhcmdldCI6ICJib2htaWFuX21lY2hhbmljcyIsICJzdHJlbmd0aCI6IDAuNywgImRlc2NyaXB0aW9uIjogIlBoeXNpY3MgZm91bmRhdGlvbiBlbmFibGVkIHF1YW50dW0gZm91bmRhdGlvbnMgcmVzZWFyY2gifSwgeyJzb3VyY2UiOiAiYm9obWlhbl9tZWNoYW5pY3MiLCAidGFyZ2V0IjogImJsYWNrX2hvbGVfcGh5c2ljcyIsICJzdHJlbmd0aCI6IDAuNiwgImRlc2NyaXB0aW9uIjogIkJvdHRvbS11cCB0aGlua2luZyBhcHByb2FjaCBjYXJyaWVkIGZvcndhcmQifSwgeyJzb3VyY2UiOiAiYmxhY2tfaG9sZV9waHlzaWNzIiwgInRhcmdldCI6ICJkYXRhX3NjaWVuY2VfbWV0aG9kcyIsICJzdHJlbmd0aCI6IDAuNSwgImRlc2NyaXB0aW9uIjogIkZyb20gZXhhY3Qgc29sdXRpb25zIHRvIHByb2JhYmlsaXN0aWMgdGhpbmtpbmcifSwgeyJzb3VyY2UiOiAiZGF0YV9zY2llbmNlX21ldGhvZHMiLCAidGFyZ2V0IjogImFpX2dhbWVfdGhlb3J5IiwgInN0cmVuZ3RoIjogMC44LCAiZGVzY3JpcHRpb24iOiAiRXZvbHV0aW9uIGludG8gQUkgYW5kIGdhbWUgdGhlb3J5IGludGVyc2VjdGlvbiJ9LCB7InNvdXJjZSI6ICJpbmRpYSIsICJ0YXJnZXQiOiAibXVuaWNoIiwgInN0cmVuZ3RoIjogMC44LCAiZGVzY3JpcHRpb24iOiAiRmlyc3QgaW50ZXJuYXRpb25hbCBtb3ZlIGZvciByZXNlYXJjaCJ9LCB7InNvdXJjZSI6ICJtdW5pY2giLCAidGFyZ2V0IjogInR1Y3NvbiIsICJzdHJlbmd0aCI6IDAuNywgImRlc2NyaXB0aW9uIjogIlBoRCBvcHBvcnR1bml0eSBicm91Z2h0IG1vdmUgdG8gQXJpem9uYSJ9LCB7InNvdXJjZSI6ICJ0dWNzb24iLCAidGFyZ2V0IjogInNlYXR0bGUiLCAic3RyZW5ndGgiOiAwLjksICJkZXNjcmlwdGlvbiI6ICJTY2hudWNraSBhbmQgaW5kdXN0cnkgb3Bwb3J0dW5pdHkgbW90aXZhdGVkIFNlYXR0bGUgbW92ZSJ9LCB7InNvdXJjZSI6ICJzZWF0dGxlIiwgInRhcmdldCI6ICJ2YW5jb3V2ZXIiLCAic3RyZW5ndGgiOiAwLjgsICJkZXNjcmlwdGlvbiI6ICJJbW1pZ3JhdGlvbiBzdGFiaWxpdHkgYW5kIG5ldyBvcHBvcnR1bml0aWVzIn0sIHsic291cmNlIjogImRldGxlZl9kdXJyIiwgInRhcmdldCI6ICJib2htaWFuX21lY2hhbmljcyIsICJzdHJlbmd0aCI6IDAuOSwgImRlc2NyaXB0aW9uIjogIkRpcmVjdCByZXNlYXJjaCBzdXBlcnZpc2lvbiBhbmQgbWVudG9yc2hpcCJ9LCB7InNvdXJjZSI6ICJkZXRsZWZfZHVyciIsICJ0YXJnZXQiOiAibG11X3RoZXNpcyIsICJzdHJlbmd0aCI6IDAuOSwgImRlc2NyaXB0aW9uIjogIlRoZXNpcyBhZHZpc29yIHJlbGF0aW9uc2hpcCJ9LCB7InNvdXJjZSI6ICJzYW1fZ3JhbGxhIiwgInRhcmdldCI6ICJibGFja19ob2xlX3BoeXNpY3MiLCAic3RyZW5ndGgiOiAwLjksICJkZXNjcmlwdGlvbiI6ICJQaEQgc3VwZXJ2aXNpb24gYW5kIHJlc2VhcmNoIGd1aWRhbmNlIn0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogImFyaXpvbmFfcGhkIiwgInN0cmVuZ3RoIjogMC45LCAiZGVzY3JpcHRpb24iOiAiRG9jdG9yYWwgYWR2aXNvciByZWxhdGlvbnNoaXAifSwgeyJzb3VyY2UiOiAic2NobnVja2kiLCAidGFyZ2V0IjogInNlYXR0bGUiLCAic3RyZW5ndGgiOiAwLjgsICJkZXNjcmlwdGlvbiI6ICJIZXIgbmVlZHMgaW5mbHVlbmNlZCBtYWpvciBsaWZlIGRlY2lzaW9ucyJ9LCB7InNvdXJjZSI6ICJzY2hudWNraSIsICJ0YXJnZXQiOiAidmFuY291dmVyIiwgInN0cmVuZ3RoIjogMC42LCAiZGVzY3JpcHRpb24iOiAiQ29udGludWVkIGNvbnNpZGVyYXRpb24gaW4gbG9jYXRpb24gY2hvaWNlcyJ9LCB7InNvdXJjZSI6ICJyb3ZlciIsICJ0YXJnZXQiOiAidHVybm8iLCAic3RyZW5ndGgiOiAwLjcsICJkZXNjcmlwdGlvbiI6ICJFeHBlcmllbmNlIHdpdGggMi1zaWRlZCBtYXJrZXRwbGFjZXMgY2FycmllZCBmb3J3YXJkIn0sIHsic291cmNlIjogInJvdmVyIiwgInRhcmdldCI6ICJkYXRhX3NjaWVuY2VfbWV0aG9kcyIsICJzdHJlbmd0aCI6IDAuOCwgImRlc2NyaXB0aW9uIjogIlByYWN0aWNhbCBhcHBsaWNhdGlvbiBvZiBkYXRhIHNjaWVuY2UgdGVjaG5pcXVlcyJ9LCB7InNvdXJjZSI6ICJ0dXJubyIsICJ0YXJnZXQiOiAiYWlfZ2FtZV90aGVvcnkiLCAic3RyZW5ndGgiOiAwLjgsICJkZXNjcmlwdGlvbiI6ICJDdXJyZW50IGFwcGxpY2F0aW9uIG9mIEFJIGFuZCBnYW1lIHRoZW9yeSBjb25jZXB0cyJ9LCB7InNvdXJjZSI6ICJibGFja19ob2xlX3BoeXNpY3MiLCAidGFyZ2V0IjogInJvdmVyIiwgInN0cmVuZ3RoIjogMC40LCAiZGVzY3JpcHRpb24iOiAiUHJvYmxlbS1zb2x2aW5nIHNraWxscyB0cmFuc2ZlcnJlZCB0byBpbmR1c3RyeSJ9LCB7InNvdXJjZSI6ICJib2htaWFuX21lY2hhbmljcyIsICJ0YXJnZXQiOiAiYWlfZ2FtZV90aGVvcnkiLCAic3RyZW5ndGgiOiAwLjUsICJkZXNjcmlwdGlvbiI6ICJCb3R0b20tdXAgdGhpbmtpbmcgYXBwcm9hY2ggY29udGludWVzIGluIGN1cnJlbnQgd29yayJ9LCB7InNvdXJjZSI6ICJhcml6b25hX3BoZCIsICJ0YXJnZXQiOiAidmFuY291dmVyIiwgInN0cmVuZ3RoIjogMC4zLCAiZGVzY3JpcHRpb24iOiAiUGhEIGV4cGVyaWVuY2UgY29udHJpYnV0ZWQgdG8gaW1taWdyYXRpb24gcGF0aCJ9XX0=');
                const configStr = atob('eyJ3aWR0aCI6IDkwMCwgImhlaWdodCI6IDYwMCwgInRoZW1lIjogeyJwcmltYXJ5Q29sb3IiOiAiIzI3ODBlMyIsICJzZWNvbmRhcnlDb2xvciI6ICIjM2ZiNjE4IiwgImFjY2VudENvbG9yIjogIiNmZmRkM2MiLCAiZGFuZ2VyQ29sb3IiOiAiI2ZmMDAzOSIsICJtdXRlZENvbG9yIjogIiM4NjhlOTYiLCAiYmFja2dyb3VuZENvbG9yIjogIiNmZmZmZmYiLCAic3VyZmFjZUNvbG9yIjogIiNmOGY5ZmEiLCAidGV4dFByaW1hcnkiOiAiIzIxMjUyOSIsICJ0ZXh0U2Vjb25kYXJ5IjogIiM0OTUwNTciLCAiZm9udEZhbWlseSI6ICJzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sICdTZWdvZSBVSScsIFJvYm90bywgc2Fucy1zZXJpZiIsICJmb250U2l6ZUJhc2UiOiAxNH0sICJub2RlQ29sb3JzIjogeyJwZXJzb25hbCI6ICIjMjc4MGUzIiwgInBoeXNpY3NfdGhlb3J5IjogIiMzZmI2MTgiLCAiZGF0YV9haSI6ICIjZmZkZDNjIiwgImFwcGxpY2F0aW9ucyI6ICIjZmYwMDM5IiwgIm1hdGhfY29tcF9tZXRob2RzIjogIiM2MTNkN2MifSwgImxheWVycyI6IFt7ImlkIjogInBlcnNvbmFsIiwgIm5hbWUiOiAiUGVyc29uYWwiLCAiY29sb3IiOiAiIzI3ODBlMyJ9LCB7ImlkIjogInBoeXNpY3NfdGhlb3J5IiwgIm5hbWUiOiAiUGh5c2ljcyAmIFRoZW9yeSIsICJjb2xvciI6ICIjM2ZiNjE4In0sIHsiaWQiOiAiZGF0YV9haSIsICJuYW1lIjogIkRhdGEgU2NpZW5jZSAmIEFJIiwgImNvbG9yIjogIiNmZmRkM2MifSwgeyJpZCI6ICJhcHBsaWNhdGlvbnMiLCAibmFtZSI6ICJBcHBsaWNhdGlvbnMiLCAiY29sb3IiOiAiI2ZmMDAzOSJ9LCB7ImlkIjogIm1hdGhfY29tcF9tZXRob2RzIiwgIm5hbWUiOiAiTWF0aGVtYXRpY2FsICYgQ29tcHV0YXRpb25hbCBNZXRob2RzIiwgImNvbG9yIjogIiM2MTNkN2MifV0sICJ0aW1lbGluZSI6IHsiZW5hYmxlZCI6IHRydWUsICJzdGFydCI6IDIwMDksICJlbmQiOiAyMDI1fSwgImZlYXR1cmVzIjogeyJzaG93TWluaU1hcCI6IHRydWUsICJzaG93VGltZWxpbmUiOiB0cnVlLCAic2hvd0xlZ2VuZCI6IHRydWUsICJlbmFibGVIb3ZlciI6IHRydWUsICJlbmFibGVEcmFnIjogdHJ1ZX0sICJzaW11bGF0aW9uIjogeyJsaW5rRGlzdGFuY2UiOiAxMjAsICJsaW5rU3RyZW5ndGgiOiAwLjMsICJjaGFyZ2VTdHJlbmd0aCI6IC00MDB9fQ==');
                const data = JSON.parse(dataStr);
                const config = JSON.parse(configStr);
                const container = document.getElementById('kg_0f705368');
                const wrapper = document.getElementById('kg_0f705368_wrapper');
                container.innerHTML = ''; // Clear loading message
                console.log('Creating KnowledgeGraphExplorer...');
                const graph = new KnowledgeGraphExplorer(container, data, config);
                window.kg_0f705368 = graph;
                console.log('Graph created, adding UI controls to wrapper...');
                // Add UI controls to the wrapper, not the graph container
                setTimeout(() => {
                    try {
                        const uiControls = new UIControlsManager(config);
                        // Merge data and config for UI controls
                        const dataWithConfig = Object.assign({}, data, {
                            layers: config.layers,
                            timeline: config.timeline
                        });
                        uiControls.initialize(wrapper, graph, dataWithConfig);
                        window['kg_0f705368_ui'] = uiControls;
                        console.log('UI controls added to wrapper successfully');
                    } catch (uiError) {
                        console.error('UI Controls failed:', uiError);
                    }
                }, 500);
                console.log('Graph initialized successfully');
            } catch (error) {
                console.error('Graph initialization failed:', error);
                document.getElementById('kg_0f705368').innerHTML = 
                    '<div style="padding: 20px; color: red;">Graph failed to load: ' + error.message + '</div>';
            }
        }
        // Wait for D3 and DOM
        if (typeof d3 !== 'undefined' && document.readyState === 'complete') {
            initGraph();
        } else {
            window.addEventListener('load', function() {
                setTimeout(initGraph, 200);
            });
        }
        </script>
<section id="the-journey" class="level2">
<h2 data-anchor-id="the-journey">The Journey</h2>
<p>Curiosity about the quantum foundations took me from India to Munich, where I worked with the late <a href="https://www.mathematik.uni-muenchen.de/~duerr/">Detlef Dürr</a> on Bohmian mechanics. His research group was full of people who were inquisitive, and deeply cared about the work they did. This was where I started looking at systems with the bottom-up approach — figuring out how to formulate a theory that ontologically describes how nature works at a fundamental level, with the constraints of having to describe known phenomena.</p>
<p>I went to Tucson planning to work with <a href="https://sgralla.arizona.edu/">Sam Gralla</a> on the self-force problem, but ended up getting sucked into <a href="https://inspirehep.net/authors/1798223">black hole physics</a> instead. The PhD years in Arizona were intense in ways I didn’t expect. I got really good at sitting with hard problems for months without making progress, then suddenly seeing the path forward. Somewhere along the way, I also started caring about the math itself, not just what it could tell me about black holes.</p>
<p>Then Schnucki showed up with those brown eyes and infinite capacity for love, and suddenly being with her in a place where she could run around freely became a priority. Seattle called — I’m a sucker for gloomy, drizzly weather and the beautiful outdoors. I was fortunate to find my first position outside academia at Rover, working with genuinely amazing people, and everything clicked differently. Instead of “What fundamental dynamics make this happen?” I started asking “What can we actually figure out from messy, real-world data?”. I went from exact solutions and clean equations to thinking in distributions and probabilities. Turns out that adding programming to your toolkit allows you to ask questions that you’d never even think of asking if you didn’t have those techniques under your belt.</p>
<p>Long-term immigration stability brought me to Vancouver in 2024. Now I’m doing Stanford’s AI program while consulting for Turno (another 2-sided marketplace, because apparently I have a type). These days I’m obsessed with where game theory, reinforcement learning, and economics overlap — it’s this sweet spot where bottom-up and top-down thinking actually play nice together. And yeah, like everyone else, I’m trying to figure out what to do with large language models.</p>
</section>
<section id="education" class="level2">
<h2 data-anchor-id="education">Education</h2>
<p><strong>Stanford University</strong> | Remote<br>
AI Graduate Certificate | Sep 2024 - present</p>
<p><strong>The Data Incubator</strong> | Remote<br>
Data Science Fellowship | Feb 2021 - May 2021</p>
<p><strong>University of Arizona</strong> | Tucson, AZ<br>
PhD in Physics | Aug 2015 - Jul 2021</p>
<p><strong>Ludwig Maximilians University</strong> | Munich, DE<br>
Visiting student for Master’s thesis | Aug 2013 - Jul 2014</p>
<p><strong>Birla Institute of Technology and Sciences</strong> | Hyderabad, India<br>
MSc in Physics &amp; Bachelors in Pharmacy | Aug 2009 - Jul 2014</p>
</section>
<section id="experience" class="level2">
<h2 data-anchor-id="experience">Experience</h2>
<p><strong>Turno</strong> | Vancouver, BC<br>
Data Scientist | Sep 2024 - present</p>
<p><strong>Rover</strong> | Seattle, WA<br>
Data Scientist II &amp; III | Sep 2021 - Sep 2024</p>
<p>If you’re interested in more specifics of what I’ve done professionally, you can find more details on my <a href="https://arunravishankar.github.io/cv/">Resume</a> and on <a href="https://www.linkedin.com/in/arunravishankar/">LinkedIn</a>.</p>
</section>
<section id="interactive-exploration" class="level2">
<h2 data-anchor-id="interactive-exploration">Interactive Exploration</h2>
<p>The graph above shows the interconnected nature of my journey - you can:</p>
<ul>
<li><strong>Hover over nodes</strong> to see the 3D distance-based effects</li>
<li><strong>Click nodes</strong> for detailed descriptions</li>
<li><strong>Use the layer controls</strong> to focus on specific aspects (Education, Research, Industry, Current Focus, Geographic)</li>
<li><strong>Navigate the timeline</strong> to see how things evolved over time</li>
<li><strong>Use the minimap</strong> to quickly jump to different areas</li>
</ul>
<p>Each connection represents how one experience led to or influenced another. The stronger the connection, the more direct the influence. You’ll notice that geographic moves often coincided with major career transitions, and that the bottom-up thinking approach from quantum foundations continues to influence my current work in AI and game theory.</p>
<p>The questions keep changing, but I’m still just as curious about complex systems — whether they’re quantum foundations, black holes, markets, or whatever’s next.</p>


</section>
</main> 
  <hr class="about-sep">
   <div class="about-links">
  <a href="https://bsky.app/profile/arunravishankar.bsky.social" class="about-link" rel="" target="">
    <i class="bi bi-bluesky"></i>
     <span class="about-link-text">Bluesky</span>
  </a>
  <a href="https://www.linkedin.com/in/arunravishankar/" class="about-link" rel="" target="">
    <i class="bi bi-linkedin"></i>
     <span class="about-link-text">LinkedIn</span>
  </a>
  <a href="https://github.com/arunravishankar" class="about-link" rel="" target="">
    <i class="bi bi-github"></i>
     <span class="about-link-text">Github</span>
  </a>
  <a href="mailto:arunravishankar@gmail.com" class="about-link" rel="" target="">
    <i class="bi bi-gmail"></i>
     <span class="about-link-text">Gmail</span>
  </a>
</div>
</div>
 <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/www\.inmylightcone\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<input type="hidden" id="giscus-base-theme" value="light_protanopia">
<input type="hidden" id="giscus-alt-theme" value="light_protanopia">
<script>
  function loadGiscus() {
    // Function to get the theme based on body class
    const getTheme = () => {
      let baseTheme = document.getElementById('giscus-base-theme').value;
      let altTheme = document.getElementById('giscus-alt-theme').value;
      return document.body.classList.contains('quarto-dark') ? altTheme : baseTheme;
    };
    const script = document.createElement("script");
    script.src = "https://giscus.app/client.js";
    script.async = true;
    script.dataset.repo = "arunravishankar/in-my-lightcone";
    script.dataset.repoId = "";
    script.dataset.category = "Blog Comments";
    script.dataset.categoryId = "";
    script.dataset.mapping = "pathname";
    script.dataset.reactionsEnabled = "1";
    script.dataset.emitMetadata = "0";
    script.dataset.inputPosition = "bottom";
    script.dataset.theme = getTheme();
    script.dataset.lang = "en";
    script.crossOrigin = "anonymous";
    // Append the script to the desired div instead of at the end of the body
    document.getElementById("quarto-content").appendChild(script);
  }
  loadGiscus();
</script>
</div> <!-- /content -->




</body></html>