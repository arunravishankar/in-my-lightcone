<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.23">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>about – In My Lightcone</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./imlc_logo.jpg" rel="icon" type="image/jpeg">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-6f6599830d51be977da3b6af758f8eff.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-1fe81d0376b2c50856e68e651e390326.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-b14658aefa774ec5e37167111b7179fa.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-879af782b1d9f9e0b0c0f39f6193d39a.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-b14658aefa774ec5e37167111b7179fa.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">In My Lightcone</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./about.html" aria-current="page"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./ramblings.html"> 
<span class="menu-text">Ramblings</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/arunravishankar"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/arunravishankar"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://bsky.app/profile/arunravishankar.bsky.social"> <i class="bi bi-bluesky" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"><h1 class="title display-7">Arun's Knowledge Graph</h1></header>





<style>
#title-block-header {
    display: none !important;
}
</style>
<div class="hero-section">

        <div id="kg_c86fdab8_wrapper" class="kg-hero-wrapper" style="position: relative; width: 100%; height: 75vh; margin: 0;">
            <div id="kg_c86fdab8" style="width: 100%; height: 100%; border: none; background-color: #f9f9f9;">
                <div style="padding: 20px; text-align: center; color: #666;">Loading graph...</div>
            </div>
            
            <div class="kg-title-overlay" id="kg_c86fdab8_title_overlay">
                
            </div>
        </div>

        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script>
        // utils/CoordinateTransform.js
/**
 * Coordinate Transformation Utilities for Knowledge Graph Explorer
 * Handles coordinate transformations between screen space and graph space
 * Provides clean abstraction for zoom/pan coordinate calculations
 */
class CoordinateTransform {
  constructor() {
    this.currentTransform = d3.zoomIdentity;
    this.viewportWidth = 800;
    this.viewportHeight = 600;
  }

  /**
   * Update the current transform (called during zoom events)
   * @param {Object} transform - D3 zoom transform object
   */
  updateTransform(transform) {
    this.currentTransform = transform;
  }

  /**
   * Update viewport dimensions
   * @param {number} width - Viewport width
   * @param {number} height - Viewport height
   */
  updateViewport(width, height) {
    this.viewportWidth = width;
    this.viewportHeight = height;
  }

  /**
   * Convert screen coordinates to graph coordinates
   * @param {Array|Object} screenPosition - [x, y] array or {x, y} object in screen space
   * @param {Object} transform - Optional transform override
   * @returns {Object} - {x, y} in graph space
   */
  screenToGraph(screenPosition, transform = null) {
    const t = transform || this.currentTransform;
    
    // Handle both array and object input
    const screenX = Array.isArray(screenPosition) ? screenPosition[0] : screenPosition.x;
    const screenY = Array.isArray(screenPosition) ? screenPosition[1] : screenPosition.y;
    
    return {
      x: (screenX - t.x) / t.k,
      y: (screenY - t.y) / t.k
    };
  }

  /**
   * Convert graph coordinates to screen coordinates
   * @param {Object|Array} graphPosition - {x, y} object or [x, y] array in graph space
   * @param {Object} transform - Optional transform override
   * @returns {Array} - [x, y] in screen space
   */
  graphToScreen(graphPosition, transform = null) {
    const t = transform || this.currentTransform;
    
    // Handle both object and array input
    const graphX = Array.isArray(graphPosition) ? graphPosition[0] : graphPosition.x;
    const graphY = Array.isArray(graphPosition) ? graphPosition[1] : graphPosition.y;
    
    return [
      graphX * t.k + t.x,
      graphY * t.k + t.y
    ];
  }

  /**
   * Convert screen coordinates relative to SVG element to graph coordinates
   * Useful for mouse event handling
   * @param {Event} event - Mouse event
   * @param {Element} svgElement - SVG DOM element
   * @param {Object} transform - Optional transform override
   * @returns {Object} - {x, y} in graph space
   */
  eventToGraph(event, svgElement, transform = null) {
    const [svgX, svgY] = d3.pointer(event, svgElement);
    return this.screenToGraph([svgX, svgY], transform);
  }

  /**
   * Calculate Euclidean distance between two points
   * @param {Object} point1 - {x, y} coordinates
   * @param {Object} point2 - {x, y} coordinates
   * @returns {number} - Distance between points
   */
  calculateDistance(point1, point2) {
    const dx = point1.x - point2.x;
    const dy = point1.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  /**
   * Calculate distance between a point and multiple targets, return closest
   * @param {Object} point - {x, y} source point
   * @param {Array} targets - Array of {x, y} target points with id property
   * @param {number} maxDistance - Maximum distance to consider
   * @returns {Object|null} - Closest target with distance, or null if none within maxDistance
   */
  findClosestPoint(point, targets, maxDistance = Infinity) {
    let closest = null;
    let minDistance = maxDistance;

    targets.forEach(target => {
      const distance = this.calculateDistance(point, target);
      if (distance < minDistance) {
        minDistance = distance;
        closest = { target, distance };
      }
    });

    return closest;
  }

  /**
   * Get the current zoom scale
   * @returns {number} - Current zoom scale factor
   */
  getScale() {
    return this.currentTransform.k;
  }

  /**
   * Get the current translation
   * @returns {Object} - {x, y} translation offset
   */
  getTranslation() {
    return {
      x: this.currentTransform.x,
      y: this.currentTransform.y
    };
  }

  /**
   * Get complete transform information
   * @returns {Object} - Full transform state
   */
  getTransform() {
    return {
      x: this.currentTransform.x,
      y: this.currentTransform.y,
      k: this.currentTransform.k,
      scale: this.currentTransform.k,
      translation: this.getTranslation()
    };
  }

  /**
   * Check if a point in graph space is visible in the current viewport
   * @param {Object} graphPosition - {x, y} in graph space
   * @param {number} margin - Optional margin for visibility check (in screen pixels)
   * @returns {boolean} - True if visible in viewport
   */
  isVisible(graphPosition, margin = 0) {
    const [screenX, screenY] = this.graphToScreen(graphPosition);
    
    return screenX >= -margin && 
           screenX <= this.viewportWidth + margin && 
           screenY >= -margin && 
           screenY <= this.viewportHeight + margin;
  }

  /**
   * Get the visible bounds of the current viewport in graph coordinates
   * @param {number} margin - Optional margin to expand bounds (in screen pixels)
   * @returns {Object} - {minX, maxX, minY, maxY, width, height} in graph space
   */
  getVisibleBounds(margin = 0) {
    const topLeft = this.screenToGraph([-margin, -margin]);
    const bottomRight = this.screenToGraph([
      this.viewportWidth + margin, 
      this.viewportHeight + margin
    ]);

    return {
      minX: topLeft.x,
      maxX: bottomRight.x,
      minY: topLeft.y,
      maxY: bottomRight.y,
      width: bottomRight.x - topLeft.x,
      height: bottomRight.y - topLeft.y
    };
  }

  /**
   * Apply zoom-aware scaling to a value
   * @param {number} value - Original value
   * @param {boolean} inverse - If true, scale inversely with zoom (useful for maintaining visual size)
   * @returns {number} - Scaled value
   */
  scaleValue(value, inverse = false) {
    return inverse ? value / this.currentTransform.k : value * this.currentTransform.k;
  }

  /**
   * Scale a radius or size value to maintain consistent visual appearance across zoom levels
   * @param {number} baseValue - Base size value
   * @param {number} minScale - Minimum scale factor (prevents elements from becoming too small)
   * @param {number} maxScale - Maximum scale factor (prevents elements from becoming too large)
   * @returns {number} - Zoom-adjusted value
   */
  scaleVisualSize(baseValue, minScale = 0.5, maxScale = 2.0) {
    const scale = Math.max(minScale, Math.min(maxScale, 1 / this.currentTransform.k));
    return baseValue * scale;
  }

  /**
   * Calculate appropriate font size for current zoom level
   * @param {number} baseFontSize - Base font size in pixels
   * @param {number} minSize - Minimum readable size
   * @param {number} maxSize - Maximum size to prevent overflow
   * @returns {number} - Zoom-appropriate font size
   */
  scaleFontSize(baseFontSize, minSize = 8, maxSize = 24) {
    const scale = 1 / this.currentTransform.k;
    const scaledSize = baseFontSize * scale;
    return Math.max(minSize, Math.min(maxSize, scaledSize));
  }

  /**
   * Check if a circular area is visible in the viewport
   * @param {Object} center - {x, y} center point in graph space
   * @param {number} radius - Radius in graph space
   * @returns {boolean} - True if any part of the circle is visible
   */
  isCircleVisible(center, radius) {
    const bounds = this.getVisibleBounds();
    
    // Check if circle overlaps with viewport rectangle
    const closestX = Math.max(bounds.minX, Math.min(center.x, bounds.maxX));
    const closestY = Math.max(bounds.minY, Math.min(center.y, bounds.maxY));
    
    const distance = this.calculateDistance(center, { x: closestX, y: closestY });
    return distance <= radius;
  }

  /**
   * Create a transform that centers a specific point in the viewport
   * @param {Object} graphPoint - {x, y} point to center in graph space
   * @param {number} scale - Desired zoom scale (optional, defaults to current scale)
   * @returns {Object} - D3 transform object that centers the point
   */
  createCenteringTransform(graphPoint, scale = null) {
    const targetScale = scale !== null ? scale : this.currentTransform.k;
    const centerX = this.viewportWidth / 2;
    const centerY = this.viewportHeight / 2;
    
    return d3.zoomIdentity
      .translate(centerX - graphPoint.x * targetScale, centerY - graphPoint.y * targetScale)
      .scale(targetScale);
  }

  /**
   * Create a transform that fits a bounding box within the viewport
   * @param {Object} bounds - {minX, maxX, minY, maxY} in graph space
   * @param {number} padding - Padding as percentage of viewport (0.0 to 1.0)
   * @returns {Object} - D3 transform object that fits the bounds
   */
  createFittingTransform(bounds, padding = 0.1) {
    const contentWidth = bounds.maxX - bounds.minX;
    const contentHeight = bounds.maxY - bounds.minY;
    
    const availableWidth = this.viewportWidth * (1 - padding);
    const availableHeight = this.viewportHeight * (1 - padding);
    
    const scaleX = availableWidth / contentWidth;
    const scaleY = availableHeight / contentHeight;
    const scale = Math.min(scaleX, scaleY);
    
    const centerX = (bounds.minX + bounds.maxX) / 2;
    const centerY = (bounds.minY + bounds.maxY) / 2;
    
    return this.createCenteringTransform({ x: centerX, y: centerY }, scale);
  }

  /**
   * Reset transform to identity (no zoom, no pan)
   * @returns {Object} - Identity transform
   */
  resetTransform() {
    this.currentTransform = d3.zoomIdentity;
    return d3.zoomIdentity;
  }

  /**
   * Interpolate between two transforms for smooth animations
   * @param {Object} fromTransform - Starting transform
   * @param {Object} toTransform - Ending transform
   * @param {number} t - Interpolation factor (0.0 to 1.0)
   * @returns {Object} - Interpolated transform
   */
  interpolateTransform(fromTransform, toTransform, t) {
    return d3.zoomIdentity
      .translate(
        fromTransform.x + (toTransform.x - fromTransform.x) * t,
        fromTransform.y + (toTransform.y - fromTransform.y) * t
      )
      .scale(fromTransform.k + (toTransform.k - fromTransform.k) * t);
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = CoordinateTransform;
} else if (typeof window !== 'undefined') {
  window.CoordinateTransform = CoordinateTransform;
}

// utils/DataValidator.js
/**
 * Data Validation Utilities for Knowledge Graph Explorer
 * Validates node and link data structures, ensures data integrity
 */
class DataValidator {
  constructor() {
    this.errors = [];
    this.warnings = [];
  }

  /**
   * Validate complete graph data structure
   * @param {Object} data - Graph data with nodes and links
   * @returns {Object} - Validation result with isValid, errors, warnings
   */
  validateGraphData(data) {
    this.errors = [];
    this.warnings = [];

    if (!data) {
      this.errors.push('Graph data is null or undefined');
      return this.getValidationResult();
    }

    if (!data.nodes || !Array.isArray(data.nodes)) {
      this.errors.push('Graph data must contain a nodes array');
      return this.getValidationResult();
    }

    if (!data.links || !Array.isArray(data.links)) {
      this.errors.push('Graph data must contain a links array');
      return this.getValidationResult();
    }

    // Validate nodes
    const nodeIds = new Set();
    data.nodes.forEach((node, index) => {
      this.validateNode(node, index, nodeIds);
    });

    // Validate links
    data.links.forEach((link, index) => {
      this.validateLink(link, index, nodeIds);
    });

    // Validate parent_node references
    data.nodes.forEach((node, index) => {
      if (node.parent_node && node.parent_node !== null) {
        // Handle both string and array formats
        const parents = Array.isArray(node.parent_node) ? node.parent_node : [node.parent_node];
        parents.forEach(parentId => {
          if (!nodeIds.has(parentId)) {
            this.errors.push(`Node ${index} (${node.id}): parent_node '${parentId}' does not exist`);
          }
        });
      }
    });

    return this.getValidationResult();
  }

  /**
   * Validate individual node structure
   * @param {Object} node - Node data
   * @param {number} index - Node index in array
   * @param {Set} nodeIds - Set of existing node IDs
   */
  validateNode(node, index, nodeIds) {
    const nodeRef = `Node ${index}`;

    // Required fields
    if (!node.id) {
      this.errors.push(`${nodeRef}: Missing required field 'id'`);
      return;
    }

    if (typeof node.id !== 'string') {
      this.errors.push(`${nodeRef}: 'id' must be a string`);
    }

    if (nodeIds.has(node.id)) {
      this.errors.push(`${nodeRef}: Duplicate node ID '${node.id}'`);
    } else {
      nodeIds.add(node.id);
    }

    if (!node.label) {
      this.errors.push(`${nodeRef} (${node.id}): Missing required field 'label'`);
    }

    if (!node.type && !node.layer) {
      this.warnings.push(`${nodeRef} (${node.id}): Missing both 'type' and 'layer' fields, will use defaults`);
    }

    if (!node.layer) {
      this.warnings.push(`${nodeRef} (${node.id}): Missing 'layer' field, may affect layer functionality`);
    }

    // Optional field validation
    if (node.size !== undefined && (typeof node.size !== 'number' || node.size <= 0)) {
      this.errors.push(`${nodeRef} (${node.id}): 'size' must be a positive number`);
    }

    if (node.timespan) {
      this.validateTimespan(node.timespan, `${nodeRef} (${node.id})`);
    }

    if (node.links && !Array.isArray(node.links)) {
      this.errors.push(`${nodeRef} (${node.id}): 'links' must be an array`);
    }

    if (node.position && (!node.position.x || !node.position.y)) {
      this.warnings.push(`${nodeRef} (${node.id}): 'position' should have both x and y coordinates`);
    }

    // Validate experience level
    if (node.experienceLevel && !['experienced', 'interested'].includes(node.experienceLevel)) {
      this.warnings.push(`${nodeRef} (${node.id}): 'experienceLevel' should be 'experienced' or 'interested'`);
    }

    // Validate audience field
    if (node.audience) {
      const validAudiences = ['general', 'technical', 'current'];
      if (Array.isArray(node.audience)) {
        node.audience.forEach(aud => {
          if (!validAudiences.includes(aud)) {
            this.warnings.push(`${nodeRef} (${node.id}): Invalid audience '${aud}', should be one of: ${validAudiences.join(', ')}`);
          }
        });
      } else if (typeof node.audience === 'string') {
        if (!validAudiences.includes(node.audience)) {
          this.warnings.push(`${nodeRef} (${node.id}): Invalid audience '${node.audience}', should be one of: ${validAudiences.join(', ')}`);
        }
      } else {
        this.errors.push(`${nodeRef} (${node.id}): 'audience' must be a string or array of strings`);
      }
    }

    // Validate parent_node reference - can be string or array of strings
    if (node.parent_node) {
      if (typeof node.parent_node === 'string') {
        // Single parent - will be validated later
      } else if (Array.isArray(node.parent_node)) {
        // Multiple parents - validate each is a string
        node.parent_node.forEach((parent, idx) => {
          if (typeof parent !== 'string') {
            this.errors.push(`${nodeRef} (${node.id}): parent_node[${idx}] must be a string node ID`);
          }
        });
      } else {
        this.errors.push(`${nodeRef} (${node.id}): 'parent_node' must be a string or array of strings`);
      }
    }

    // Validate subnode field
    if (node.subnode && typeof node.subnode !== 'boolean') {
      this.errors.push(`${nodeRef} (${node.id}): 'subnode' must be a boolean value`);
    }
  }

  /**
   * Validate individual link structure
   * @param {Object} link - Link data
   * @param {number} index - Link index in array
   * @param {Set} nodeIds - Set of valid node IDs
   */
  validateLink(link, index, nodeIds) {
    const linkRef = `Link ${index}`;

    // Required fields
    if (!link.source) {
      this.errors.push(`${linkRef}: Missing required field 'source'`);
      return;
    }

    if (!link.target) {
      this.errors.push(`${linkRef}: Missing required field 'target'`);
      return;
    }

    // Check if source and target nodes exist
    if (!nodeIds.has(link.source)) {
      this.errors.push(`${linkRef}: Source node '${link.source}' does not exist`);
    }

    if (!nodeIds.has(link.target)) {
      this.errors.push(`${linkRef}: Target node '${link.target}' does not exist`);
    }

    // Self-loops warning
    if (link.source === link.target) {
      this.warnings.push(`${linkRef}: Self-loop detected (${link.source} -> ${link.target})`);
    }

    // Optional field validation
    if (link.strength !== undefined) {
      if (typeof link.strength !== 'number' || link.strength < 0 || link.strength > 1) {
        this.errors.push(`${linkRef}: 'strength' must be a number between 0 and 1`);
      }
    }
  }

  /**
   * Validate timespan structure
   * @param {Object} timespan - Timespan data
   * @param {string} context - Context for error messages
   */
  validateTimespan(timespan, context) {
    if (typeof timespan !== 'object') {
      this.errors.push(`${context}: 'timespan' must be an object`);
      return;
    }

    if (timespan.start !== undefined) {
      if (!Number.isInteger(timespan.start) || timespan.start < 1900 || timespan.start > 2100) {
        this.errors.push(`${context}: 'timespan.start' must be a valid year (1900-2100)`);
      }
    }

    if (timespan.end !== undefined && timespan.end !== null) {
      if (!Number.isInteger(timespan.end) || timespan.end < 1900 || timespan.end > 2100) {
        this.errors.push(`${context}: 'timespan.end' must be a valid year (1900-2100) or null`);
      }

      if (timespan.start && timespan.end && timespan.end < timespan.start) {
        this.errors.push(`${context}: 'timespan.end' cannot be before 'timespan.start'`);
      }
    }
  }

  /**
   * Validate configuration object
   * @param {Object} config - Configuration object
   * @returns {Object} - Validation result
   */
  validateConfig(config) {
    this.errors = [];
    this.warnings = [];

    if (!config) {
      this.errors.push('Configuration is null or undefined');
      return this.getValidationResult();
    }

    // Validate dimensions
    if (config.width !== undefined && (typeof config.width !== 'number' || config.width <= 0)) {
      this.errors.push('width must be a positive number');
    }

    if (config.height !== undefined && (typeof config.height !== 'number' || config.height <= 0)) {
      this.errors.push('height must be a positive number');
    }

    // Validate colors
    const colorFields = ['background', 'textColor', 'linkColor'];
    colorFields.forEach(field => {
      if (config[field] !== undefined && !this.isValidColor(config[field])) {
        this.warnings.push(`${field} may not be a valid CSS color`);
      }
    });

    // Validate layers
    if (config.layers) {
      if (!Array.isArray(config.layers)) {
        this.errors.push('layers must be an array');
      } else {
        config.layers.forEach((layer, index) => {
          this.validateLayer(layer, index);
        });
      }
    }

    // Validate timeline
    if (config.timeline) {
      this.validateTimelineConfig(config.timeline);
    }

    return this.getValidationResult();
  }

  /**
   * Validate layer configuration
   * @param {Object} layer - Layer configuration
   * @param {number} index - Layer index
   */
  validateLayer(layer, index) {
    const layerRef = `Layer ${index}`;

    if (!layer.id) {
      this.errors.push(`${layerRef}: Missing required field 'id'`);
    }

    if (!layer.name) {
      this.errors.push(`${layerRef}: Missing required field 'name'`);
    }

    if (!layer.color) {
      this.warnings.push(`${layerRef}: Missing 'color' field`);
    } else if (!this.isValidColor(layer.color)) {
      this.warnings.push(`${layerRef}: 'color' may not be a valid CSS color`);
    }
  }

  /**
   * Validate timeline configuration
   * @param {Object} timeline - Timeline configuration
   */
  validateTimelineConfig(timeline) {
    if (typeof timeline !== 'object') {
      this.errors.push('timeline must be an object');
      return;
    }

    if (timeline.start !== undefined) {
      if (!Number.isInteger(timeline.start)) {
        this.errors.push('timeline.start must be an integer year');
      }
    }

    if (timeline.end !== undefined) {
      if (!Number.isInteger(timeline.end)) {
        this.errors.push('timeline.end must be an integer year');
      }
    }

    if (timeline.start && timeline.end && timeline.end < timeline.start) {
      this.errors.push('timeline.end cannot be before timeline.start');
    }
  }

  /**
   * Basic CSS color validation
   * @param {string} color - Color string to validate
   * @returns {boolean} - Whether color appears valid
   */
  isValidColor(color) {
    if (typeof color !== 'string') return false;
    
    // Check for common CSS color formats
    const hexRegex = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;
    const rgbRegex = /^rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/;
    const rgbaRegex = /^rgba\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*,\s*[01]?\.?\d*\s*\)$/;
    const namedColors = ['red', 'blue', 'green', 'black', 'white', 'yellow', 'purple', 'orange', 'pink', 'brown', 'gray', 'grey'];

    return hexRegex.test(color) || 
           rgbRegex.test(color) || 
           rgbaRegex.test(color) || 
           namedColors.includes(color.toLowerCase());
  }

  /**
   * Get validation result summary
   * @returns {Object} - Validation result with isValid, errors, warnings
   */
  getValidationResult() {
    return {
      isValid: this.errors.length === 0,
      errors: [...this.errors],
      warnings: [...this.warnings],
      hasWarnings: this.warnings.length > 0
    };
  }

  /**
   * Static method for quick validation
   * @param {Object} data - Data to validate
   * @returns {Object} - Validation result
   */
  static validate(data) {
    const validator = new DataValidator();
    return validator.validateGraphData(data);
  }

  /**
   * Static method for quick config validation
   * @param {Object} config - Config to validate
   * @returns {Object} - Validation result
   */
  static validateConfiguration(config) {
    const validator = new DataValidator();
    return validator.validateConfig(config);
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = DataValidator;
} else if (typeof window !== 'undefined') {
  window.DataValidator = DataValidator;
}

// core/ForceSimulation.js
/**
 * Force Simulation Manager for Knowledge Graph Explorer
 * Handles D3 force simulation setup, configuration, and lifecycle management
 */
class ForceSimulation {
  constructor(config = {}) {
    // Require all force simulation settings to be provided via config
    const required = ['linkDistance', 'chargeStrength', 'collisionRadius', 'linkStrength', 'centerStrength', 'chargeDistanceMax'];
    const missing = required.filter(key => config[key] === undefined);
    if (missing.length > 0) {
      throw new Error(`ForceSimulation requires these settings in config: ${missing.join(', ')}`);
    }

    this.config = {
      width: 800,
      height: 600,

      // Simulation parameters (these have reasonable defaults)
      alphaMin: 0.001,
      alphaDecay: 0.0228,
      velocityDecay: 0.4,

      // Force settings - must be provided
      ...config
    };

    this.simulation = null;
    this.nodes = [];
    this.links = [];
    this.isRunning = false;
    
    // Event callbacks
    this.onTick = null;
    this.onEnd = null;
    
    this.setupSimulation();
  }

  /**
   * Initialize the D3 force simulation with default forces
   */
  setupSimulation() {
    const centerX = this.config.width / 2;
    const centerY = this.config.height / 2;

    this.simulation = d3.forceSimulation()
      .alphaMin(this.config.alphaMin)
      .alphaDecay(this.config.alphaDecay)
      .velocityDecay(this.config.velocityDecay)
      .on('tick', () => {
        if (this.onTick) {
          this.onTick(this.simulation);
        }
      })
      .on('end', () => {
        this.isRunning = false;
        if (this.onEnd) {
          this.onEnd(this.simulation);
        }
      });

    // Setup default forces
    this.setupForces(centerX, centerY);
  }

  /**
   * Configure all simulation forces
   * @param {number} centerX - Center X coordinate
   * @param {number} centerY - Center Y coordinate
   */
  setupForces(centerX, centerY) {
    // Link force - attracts connected nodes
    this.simulation.force('link', d3.forceLink()
      .id(d => d.id)
      .distance(d => this.getLinkDistance(d))
      .strength(d => this.getLinkStrength(d))
    );

    // Charge force - repels nodes from each other
    this.simulation.force('charge', d3.forceManyBody()
      .strength(d => this.getChargeStrength(d))
      .distanceMax(this.config.chargeDistanceMax)
    );

    // Center force - attracts nodes toward center
    this.simulation.force('center', d3.forceCenter(centerX, centerY)
      .strength(this.config.centerStrength)
    );

    // Collision force - prevents node overlap
    this.simulation.force('collision', d3.forceCollide()
      .radius(d => this.getCollisionRadius(d))
      .strength(0.8)
      .iterations(2)
    );
  }

  /**
   * Calculate link distance for a specific link
   * @param {Object} link - Link data
   * @returns {number} - Distance value
   */
  getLinkDistance(link) {
    if (link.distance !== undefined) {
      return link.distance;
    }
    
    // Adjust distance based on link strength
    const baseDistance = this.config.linkDistance;
    const strength = link.strength || 0.5;
    
    // Stronger connections should be closer
    return baseDistance * (1.5 - strength);
  }

  /**
   * Calculate link strength for a specific link
   * @param {Object} link - Link data
   * @returns {number} - Strength value (0-1)
   */
  getLinkStrength(link) {
    if (link.strength !== undefined) {
      return link.strength * this.config.linkStrength;
    }
    return this.config.linkStrength;
  }

  /**
   * Calculate charge (repulsion) strength for a specific node
   * @param {Object} node - Node data
   * @returns {number} - Negative charge strength
   */
  getChargeStrength(node) {
    const baseStrength = this.config.chargeStrength;
    const size = node.size || 10;
    
    // Larger nodes should have stronger repulsion
    const sizeMultiplier = Math.sqrt(size / 10);
    return baseStrength * sizeMultiplier;
  }

  /**
   * Calculate collision radius for a specific node
   * @param {Object} node - Node data
   * @returns {number} - Collision radius
   */
  getCollisionRadius(node) {
    const nodeRadius = node.size || 10;
    return nodeRadius + this.config.collisionRadius;
  }

  /**
   * Update simulation data and restart if needed
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   * @param {boolean} restart - Whether to restart the simulation
   */
  updateData(nodes, links, restart = true) {
    this.nodes = nodes || [];
    this.links = links || [];

    // Update simulation nodes and links
    this.simulation.nodes(this.nodes);
    
    const linkForce = this.simulation.force('link');
    if (linkForce) {
      linkForce.links(this.links);
    }

    if (restart) {
      this.restart();
    }
  }

  /**
   * Start or restart the simulation
   * @param {number} alpha - Initial alpha value (energy level)
   */
  restart(alpha = 1) {
    if (this.simulation) {
      this.isRunning = true;
      this.simulation.alpha(alpha).restart();
    }
  }

  /**
   * Stop the simulation
   */
  stop() {
    if (this.simulation) {
      this.isRunning = false;
      this.simulation.stop();
    }
  }

  /**
   * Pause/resume the simulation
   */
  toggle() {
    if (this.isRunning) {
      this.stop();
    } else {
      this.restart();
    }
  }

  /**
   * Update the center point of the simulation
   * @param {number} x - New center X coordinate
   * @param {number} y - New center Y coordinate
   */
  updateCenter(x, y) {
    const centerForce = this.simulation.force('center');
    if (centerForce) {
      centerForce.x(x).y(y);
    }
  }

  /**
   * Update simulation dimensions and recalculate center
   * @param {number} width - New width
   * @param {number} height - New height
   */
  updateDimensions(width, height) {
    this.config.width = width;
    this.config.height = height;
    this.updateCenter(width / 2, height / 2);
  }

  /**
   * Apply custom positioning to specific nodes
   * @param {Array} nodePositions - Array of {id, x, y} objects
   * @param {boolean} fix - Whether to fix these positions
   */
  setNodePositions(nodePositions, fix = false) {
    const positionMap = new Map();
    nodePositions.forEach(pos => {
      positionMap.set(pos.id, pos);
    });

    this.nodes.forEach(node => {
      const position = positionMap.get(node.id);
      if (position) {
        node.x = position.x;
        node.y = position.y;
        
        if (fix) {
          node.fx = position.x;
          node.fy = position.y;
        }
      }
    });
  }

  /**
   * Release fixed positions for specified nodes
   * @param {Array} nodeIds - Array of node IDs to unfix
   */
  unfixNodes(nodeIds = null) {
    const toUnfix = nodeIds ? new Set(nodeIds) : null;
    
    this.nodes.forEach(node => {
      if (!toUnfix || toUnfix.has(node.id)) {
        node.fx = null;
        node.fy = null;
      }
    });
  }

  /**
   * Fix a node at its current position
   * @param {string} nodeId - ID of node to fix
   */
  fixNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node.x !== undefined && node.y !== undefined) {
      node.fx = node.x;
      node.fy = node.y;
    }
  }

  /**
   * Temporarily increase simulation energy for layout adjustments
   * @param {number} alpha - Energy level (0-1)
   */
  reheat(alpha = 0.3) {
    if (this.simulation) {
      this.simulation.alpha(alpha).restart();
    }
  }

  /**
   * Configure force strengths dynamically
   * @param {Object} forceConfig - Object with force configuration
   */
  updateForceStrengths(forceConfig) {
    Object.assign(this.config, forceConfig);

    // Update existing forces
    const linkForce = this.simulation.force('link');
    if (linkForce && forceConfig.linkDistance !== undefined) {
      linkForce.distance(d => this.getLinkDistance(d));
    }
    if (linkForce && forceConfig.linkStrength !== undefined) {
      linkForce.strength(d => this.getLinkStrength(d));
    }

    const chargeForce = this.simulation.force('charge');
    if (chargeForce && forceConfig.chargeStrength !== undefined) {
      chargeForce.strength(d => this.getChargeStrength(d));
    }

    const collisionForce = this.simulation.force('collision');
    if (collisionForce && forceConfig.collisionRadius !== undefined) {
      collisionForce.radius(d => this.getCollisionRadius(d));
    }

    // Reheat to apply changes
    if (this.isRunning) {
      this.reheat();
    }
  }

  /**
   * Add custom force to the simulation
   * @param {string} name - Force name
   * @param {Function} force - D3 force function
   */
  addCustomForce(name, force) {
    if (this.simulation) {
      this.simulation.force(name, force);
    }
  }

  /**
   * Remove a force from the simulation
   * @param {string} name - Force name to remove
   */
  removeForce(name) {
    if (this.simulation) {
      this.simulation.force(name, null);
    }
  }

  /**
   * Get current simulation statistics
   * @returns {Object} - Simulation state information
   */
  getStats() {
    if (!this.simulation) {
      return null;
    }

    // Get forces by checking what forces are actually set
    const forces = [];
    const forceNames = ['link', 'charge', 'center', 'collision'];
    
    forceNames.forEach(name => {
      if (this.simulation.force(name)) {
        forces.push(name);
      }
    });

    // Check for any additional forces by trying common custom force names
    // This is a workaround since D3's internal _forces is not reliable
    const customForceNames = ['customX', 'customY', 'radial', 'x', 'y'];
    customForceNames.forEach(name => {
      if (this.simulation.force(name)) {
        forces.push(name);
      }
    });

    return {
      alpha: this.simulation.alpha(),
      alphaMin: this.simulation.alphaMin(),
      alphaTarget: this.simulation.alphaTarget(),
      isRunning: this.isRunning,
      nodeCount: this.nodes.length,
      linkCount: this.links.length,
      forces: forces,
      velocityDecay: this.simulation.velocityDecay()
    };
  }

  /**
   * Set tick callback function
   * @param {Function} callback - Function to call on each tick
   */
  onTickCallback(callback) {
    this.onTick = callback;
  }

  /**
   * Set end callback function
   * @param {Function} callback - Function to call when simulation ends
   */
  onEndCallback(callback) {
    this.onEnd = callback;
  }

  /**
   * Calculate the bounds of all nodes
   * @param {number} padding - Padding around the bounds
   * @returns {Object} - Bounds object {minX, maxX, minY, maxY, width, height}
   */
  getNodeBounds(padding = 0) {
    if (this.nodes.length === 0) {
      return null;
    }

    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        const radius = (node.size || 10) + padding;
        minX = Math.min(minX, node.x - radius);
        maxX = Math.max(maxX, node.x + radius);
        minY = Math.min(minY, node.y - radius);
        maxY = Math.max(maxY, node.y + radius);
      }
    });

    if (minX === Infinity) {
      return null;
    }

    return {
      minX, maxX, minY, maxY,
      width: maxX - minX,
      height: maxY - minY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }

  /**
   * Apply a layout preset
   * @param {string} layoutType - Type of layout ('circle', 'grid', 'random')
   * @param {Object} options - Layout-specific options
   */
  applyLayout(layoutType, options = {}) {
    const { width = this.config.width, height = this.config.height } = options;
    const centerX = width / 2;
    const centerY = height / 2;

    switch (layoutType) {
      case 'circle':
        this.applyCircleLayout(centerX, centerY, options);
        break;
      case 'grid':
        this.applyGridLayout(width, height, options);
        break;
      case 'random':
        this.applyRandomLayout(width, height, options);
        break;
      default:
        console.warn(`Unknown layout type: ${layoutType}`);
    }

    this.reheat();
  }

  /**
   * Apply circular layout
   * @param {number} centerX - Center X coordinate
   * @param {number} centerY - Center Y coordinate
   * @param {Object} options - Layout options
   */
  applyCircleLayout(centerX, centerY, options = {}) {
    const { radius = Math.min(this.config.width, this.config.height) / 3 } = options;
    const angleStep = (2 * Math.PI) / this.nodes.length;

    this.nodes.forEach((node, index) => {
      const angle = index * angleStep;
      node.x = centerX + radius * Math.cos(angle);
      node.y = centerY + radius * Math.sin(angle);
    });
  }

  /**
   * Apply grid layout
   * @param {number} width - Layout width
   * @param {number} height - Layout height
   * @param {Object} options - Layout options
   */
  applyGridLayout(width, height, options = {}) {
    const { padding = 50 } = options;
    const cols = Math.ceil(Math.sqrt(this.nodes.length));
    const rows = Math.ceil(this.nodes.length / cols);
    
    const cellWidth = (width - 2 * padding) / cols;
    const cellHeight = (height - 2 * padding) / rows;

    this.nodes.forEach((node, index) => {
      const col = index % cols;
      const row = Math.floor(index / cols);
      
      node.x = padding + col * cellWidth + cellWidth / 2;
      node.y = padding + row * cellHeight + cellHeight / 2;
    });
  }

  /**
   * Apply random layout
   * @param {number} width - Layout width
   * @param {number} height - Layout height
   * @param {Object} options - Layout options
   */
  applyRandomLayout(width, height, options = {}) {
    const { padding = 50 } = options;
    
    this.nodes.forEach(node => {
      node.x = padding + Math.random() * (width - 2 * padding);
      node.y = padding + Math.random() * (height - 2 * padding);
    });
  }

  /**
   * Cleanup and destroy the simulation
   */
  destroy() {
    if (this.simulation) {
      this.simulation.stop();
      this.simulation = null;
    }
    this.nodes = [];
    this.links = [];
    this.onTick = null;
    this.onEnd = null;
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ForceSimulation;
} else if (typeof window !== 'undefined') {
  window.ForceSimulation = ForceSimulation;
}

// core/InteractionManager.js
/**
 * Interaction Manager for Knowledge Graph Explorer
 * Handles mouse/touch interactions, hover effects, and event dispatching
 */
class InteractionManager {
  constructor(config = {}) {
    this.config = {
      hoverRadius: 50,
      maxHoverScale: 1.3,
      hoverTransitionDuration: 100,
      clickRadius: 20,
      doubleClickDelay: 300,
      dragThreshold: 5,
      ...config
    };

    // State
    this.nodes = [];
    this.links = [];
    this.coordinateTransform = null;
    this.isInLayerMode = false;
    this.hoveredNode = null;
    this.draggedNode = null;
    this.isDragging = false;
    this.lastClickTime = 0;
    this.lastClickNode = null;

    // DOM elements
    this.svgElement = null;
    this.nodeElements = null;
    this.linkElements = null;
    this.labelElements = null;

    // Event handlers
    this.eventHandlers = {};
    this.boundHandlers = {};

    this.setupBoundHandlers();
  }

  /**
   * Initialize interaction manager with DOM elements and coordinate transform
   * @param {Object} elements - Object containing SVG and D3 selections
   * @param {CoordinateTransform} coordinateTransform - Coordinate transformation utility
   */
  initialize(elements, coordinateTransform) {
    this.svgElement = elements.svg;
    this.nodeElements = elements.nodes;
    this.linkElements = elements.links;
    this.labelElements = elements.labels;
    this.coordinateTransform = coordinateTransform;

    this.setupEventListeners();
  }

  /**
   * Create bound handler functions to avoid memory leaks
   */
  setupBoundHandlers() {
    this.boundHandlers = {
      mousemove: this.handleMouseMove.bind(this),
      mouseleave: this.handleMouseLeave.bind(this),
      click: this.handleClick.bind(this),
      mousedown: this.handleMouseDown.bind(this),
      mouseup: this.handleMouseUp.bind(this),
      contextmenu: this.handleContextMenu.bind(this)
    };
  }

  /**
   * Setup event listeners on the SVG element
   */
  setupEventListeners() {
    if (!this.svgElement) return;

    // Mouse/touch events
    this.svgElement.on('mousemove', this.boundHandlers.mousemove);
    this.svgElement.on('mouseleave', this.boundHandlers.mouseleave);
    this.svgElement.on('click', this.boundHandlers.click);
    this.svgElement.on('mousedown', this.boundHandlers.mousedown);
    this.svgElement.on('mouseup', this.boundHandlers.mouseup);
    this.svgElement.on('contextmenu', this.boundHandlers.contextmenu);

    // Setup node-specific interactions
    this.setupNodeInteractions();
    this.setupLinkInteractions();
  }

  /**
   * Setup interactions specific to nodes
   */
  setupNodeInteractions() {
    if (!this.nodeElements) return;

    this.nodeElements
      .style('cursor', 'pointer')
      .on('click', (event, d) => {
        event.stopPropagation();
        this.handleNodeClick(event, d);
      })
      .on('mousedown', (event, d) => {
        event.stopPropagation();
        this.handleNodeMouseDown(event, d);
      })
      .on('mouseenter', (event, d) => {
        this.handleNodeMouseEnter(event, d);
      })
      .on('mouseleave', (event, d) => {
        this.handleNodeMouseLeave(event, d);
      });
  }

  /**
   * Setup interactions specific to links
   */
  setupLinkInteractions() {
    if (!this.linkElements) return;

    this.linkElements
      .style('cursor', 'pointer')
      .on('click', (event, d) => {
        event.stopPropagation();
        this.handleLinkClick(event, d);
      })
      .on('mouseenter', (event, d) => {
        this.handleLinkMouseEnter(event, d);
      })
      .on('mouseleave', (event, d) => {
        this.handleLinkMouseLeave(event, d);
      });
  }

  /**
   * Update data references
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   */
  updateData(nodes, links) {
    this.nodes = nodes || [];
    this.links = links || [];
  }

  /**
   * Update layer mode state
   * @param {boolean} isInLayerMode - Whether layer mode is active
   */
  updateLayerMode(isInLayerMode) {
    this.isInLayerMode = isInLayerMode;
  }

  /**
   * Handle mouse movement over the SVG
   * @param {Event} event - Mouse event
   */
  handleMouseMove(event) {
    if (this.isDragging) {
      this.handleDragMove(event);
      return;
    }

    if (this.isInLayerMode) return;

    // Get mouse position in graph coordinates
    const mousePos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());

    // Emit dock hover effects for the main graph
    this.emit('dockHover', { mousePosition: mousePos });

    this.updateContinuousHoverEffects(mousePos);
  }

  /**
   * Handle mouse leaving the SVG area
   * @param {Event} event - Mouse event
   */
  handleMouseLeave(event) {
    // Reset dock hover effects
    this.emit('dockHoverReset');

    this.resetHoverEffects();
    if (this.isDragging) {
      this.endDrag();
    }
  }

  /**
   * Handle click events on the SVG background
   * @param {Event} event - Mouse event
   */
  handleClick(event) {
    // Only handle background clicks (not propagated from nodes/links)
    this.emit('backgroundClick', { event });
  }

  /**
   * Handle mouse down events for drag initiation
   * @param {Event} event - Mouse event
   */
  handleMouseDown(event) {
    if (event.button !== 0) return; // Only left mouse button

    const mousePos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    const clickedNode = this.findNodeAtPosition(mousePos);

    if (clickedNode) {
      this.startDrag(event, clickedNode);
    }
  }

  /**
   * Handle mouse up events
   * @param {Event} event - Mouse event
   */
  handleMouseUp(event) {
    if (this.isDragging) {
      this.endDrag();
    }
  }

  /**
   * Handle context menu (right-click) events
   * @param {Event} event - Mouse event
   */
  handleContextMenu(event) {
    event.preventDefault();
    
    const mousePos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    const clickedNode = this.findNodeAtPosition(mousePos);

    if (clickedNode) {
      this.emit('nodeContextMenu', { node: clickedNode, event });
    } else {
      this.emit('backgroundContextMenu', { event });
    }
  }

  /**
   * Handle node click events
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeClick(event, node) {
    const currentTime = Date.now();
    const isDoubleClick = (currentTime - this.lastClickTime < this.config.doubleClickDelay) &&
                         (this.lastClickNode === node);

    if (isDoubleClick) {
      this.emit('nodeDoubleClick', { node, event });
    } else {
      this.emit('nodeClick', { node, event });
    }

    this.lastClickTime = currentTime;
    this.lastClickNode = node;
  }

  /**
   * Handle node mouse down for drag initiation
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeMouseDown(event, node) {
    this.startDrag(event, node);
  }

  /**
   * Handle node mouse enter
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeMouseEnter(event, node) {
    this.emit('nodeMouseEnter', { node, event });
  }

  /**
   * Handle node mouse leave
   * @param {Event} event - Mouse event
   * @param {Object} node - Node data
   */
  handleNodeMouseLeave(event, node) {
    this.emit('nodeMouseLeave', { node, event });
  }

  /**
   * Handle link click events
   * @param {Event} event - Mouse event
   * @param {Object} link - Link data
   */
  handleLinkClick(event, link) {
    this.emit('linkClick', { link, event });
  }

  /**
   * Handle link mouse enter
   * @param {Event} event - Mouse event
   * @param {Object} link - Link data
   */
  handleLinkMouseEnter(event, link) {
    this.emit('linkMouseEnter', { link, event });
  }

  /**
   * Handle link mouse leave
   * @param {Event} event - Mouse event
   * @param {Object} link - Link data
   */
  handleLinkMouseLeave(event, link) {
    this.emit('linkMouseLeave', { link, event });
  }

  /**
   * Start drag operation
   * @param {Event} event - Mouse event
   * @param {Object} node - Node being dragged
   */
  startDrag(event, node) {
    this.draggedNode = node;
    this.isDragging = false; // Will become true if mouse moves beyond threshold
    this.dragStartPos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    
    // Prevent default to avoid text selection
    event.preventDefault();
  }

  /**
   * Handle drag movement
   * @param {Event} event - Mouse event
   */
  handleDragMove(event) {
    if (!this.draggedNode) return;

    const currentPos = this.coordinateTransform.eventToGraph(event, this.svgElement.node());
    
    if (!this.isDragging) {
      // Check if we've moved beyond the drag threshold
      const distance = this.coordinateTransform.calculateDistance(this.dragStartPos, currentPos);
      if (distance > this.config.dragThreshold) {
        this.isDragging = true;
        this.emit('dragStart', { node: this.draggedNode, event });
      }
    }

    if (this.isDragging) {
      // Update node position
      this.draggedNode.fx = currentPos.x;
      this.draggedNode.fy = currentPos.y;
      
      this.emit('dragMove', { 
        node: this.draggedNode, 
        position: currentPos, 
        event 
      });
    }
  }

  /**
   * End drag operation
   */
  endDrag() {
    if (this.draggedNode) {
      if (this.isDragging) {
        this.emit('dragEnd', { node: this.draggedNode });
      }
      
      // Optionally release the node's fixed position
      // this.draggedNode.fx = null;
      // this.draggedNode.fy = null;
    }

    this.draggedNode = null;
    this.isDragging = false;
    this.dragStartPos = null;
  }

  /**
   * Find node at a specific position
   * @param {Object} position - {x, y} position in graph coordinates
   * @returns {Object|null} - Node at position or null
   */
  findNodeAtPosition(position) {
    const clickRadius = this.config.clickRadius;
    
    for (const node of this.nodes) {
      if (node.x !== undefined && node.y !== undefined) {
        const distance = this.coordinateTransform.calculateDistance(position, node);
        const nodeRadius = (node.size || 10) + clickRadius;
        
        if (distance <= nodeRadius) {
          return node;
        }
      }
    }
    
    return null;
  }

  /**
   * Update continuous hover effects based on mouse position
   * @param {Object} mousePosition - {x, y} mouse position in graph coordinates
   */
  updateContinuousHoverEffects(mousePosition) {
    // Find the closest node within hover radius
    let closestNode = null;
    let closestDistance = Infinity;

    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        const distance = this.coordinateTransform.calculateDistance(node, mousePosition);
        const nodeRadius = (node.size || 10);
        
        // Prioritize nodes that the mouse is directly over
        const isDirectlyOver = distance <= nodeRadius;
        
        if (isDirectlyOver && distance < closestDistance) {
          closestNode = node;
          closestDistance = distance;
        } else if (!closestNode && distance <= this.config.hoverRadius) {
          closestNode = node;
          closestDistance = distance;
        }
      }
    });

    if (closestNode !== this.hoveredNode) {
      if (this.hoveredNode) {
        this.emit('nodeHoverEnd', { node: this.hoveredNode });
      }
      
      this.hoveredNode = closestNode;
      
      if (this.hoveredNode) {
        this.emit('nodeHoverStart', { node: this.hoveredNode, distance: closestDistance });
      }
    }

    if (closestNode) {
      this.emit('nodeHover', { 
        node: closestNode, 
        distance: closestDistance, 
        mousePosition 
      });
    } else {
      this.emit('noHover', { mousePosition });
    }
  }

  /**
   * Reset all hover effects
   */
  resetHoverEffects() {
    if (this.hoveredNode) {
      this.emit('nodeHoverEnd', { node: this.hoveredNode });
      this.hoveredNode = null;
    }
    
    this.emit('hoverReset');
  }

  /**
   * Enable or disable node dragging
   * @param {boolean} enabled - Whether dragging should be enabled
   */
  setDragEnabled(enabled) {
    this.config.dragEnabled = enabled;
  }

  /**
   * Enable or disable hover effects
   * @param {boolean} enabled - Whether hover effects should be enabled
   */
  setHoverEnabled(enabled) {
    this.config.hoverEnabled = enabled;
    if (!enabled) {
      this.resetHoverEffects();
    }
  }

  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);
  }

  /**
   * Get interaction statistics
   * @returns {Object} - Interaction state information
   */
  getStats() {
    return {
      hoveredNode: this.hoveredNode ? this.hoveredNode.id : null,
      isDragging: this.isDragging,
      draggedNode: this.draggedNode ? this.draggedNode.id : null,
      isInLayerMode: this.isInLayerMode,
      config: { ...this.config }
    };
  }

  /**
   * Programmatically trigger hover on a specific node
   * @param {string} nodeId - ID of node to hover
   */
  hoverNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node !== this.hoveredNode) {
      if (this.hoveredNode) {
        this.emit('nodeHoverEnd', { node: this.hoveredNode });
      }
      
      this.hoveredNode = node;
      this.emit('nodeHoverStart', { node, distance: 0 });
      this.emit('nodeHover', { node, distance: 0, mousePosition: node });
    }
  }

  /**
   * Clear programmatic hover
   */
  clearHover() {
    this.resetHoverEffects();
  }

  /**
   * Add event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }

  /**
   * Remove event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function to remove
   */
  off(eventType, callback) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = this.eventHandlers[eventType].filter(cb => cb !== callback);
    }
    return this;
  }

  /**
   * Emit event to all listeners
   * @param {string} eventType - Type of event
   * @param {Object} data - Event data
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event handler for ${eventType}:`, error);
        }
      });
    }
  }

  /**
   * Remove all event listeners and cleanup
   */
  destroy() {
    // Remove DOM event listeners
    if (this.svgElement) {
      Object.values(this.boundHandlers).forEach(handler => {
        this.svgElement.on(handler.name, null);
      });
    }

    // Clear node and link interactions
    if (this.nodeElements) {
      this.nodeElements.on('.interaction', null);
    }
    if (this.linkElements) {
      this.linkElements.on('.interaction', null);
    }

    // Clear state
    this.eventHandlers = {};
    this.hoveredNode = null;
    this.draggedNode = null;
    this.isDragging = false;
    this.nodes = [];
    this.links = [];
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = InteractionManager;
} else if (typeof window !== 'undefined') {
  window.InteractionManager = InteractionManager;
}

// core/VisualEffectsManager.js
/**
 * Visual Effects Manager for Knowledge Graph Explorer
 * Handles 3D-style hover effects, layer transitions, audience filtering, and visual state management
 */
class VisualEffectsManager {
  constructor(config = {}) {
    this.config = {
      // Hover effect settings
      hoverRadius: 50,
      maxHoverScale: 1.3,
      hoverTransitionDuration: 100,
      
      // Layer effect settings
      layerTransitionDuration: 400,
      
      // Audience effect settings
      audienceTransitionDuration: 300,
      audienceBlurAmount: 2,
      audienceOpacityReduced: 0.3,
      
      // Distance-based scaling
      distanceScaling: {
        distance1: 0.9,
        distance2: 0.7,
        distance3: 0.5,
        distanceOther: 0.3
      },
      
      // Layer mode scaling
      layerScaling: {
        activeLayer: 1.0,
        connectedNodes: {
          distance1: 0.7,
          distance2: 0.5,
          distanceOther: 0.3
        },
        disconnectedNodes: 0.5  // Changed from 0.2 to 0.5 for less dramatic zoom out
      },
      
      // Theme settings
      theme: {
        fontSizeBase: 12,
        fontSizeSmall: 10,
        fontSizeLarge: 14,
        defaultOpacity: 1.0,
        dimmedOpacity: 0.6,
        baseStrokeWidth: 2
      },
      
      ...config
    };

    // State
    this.nodes = [];
    this.links = [];
    this.nodeDistances = new Map();
    this.isInLayerMode = false;
    this.isInAudienceMode = false;
    this.currentLayer = null;
    this.currentAudience = 'current_focus';
    this.hoveredNode = null;
    this.selectedNode = null;
    this.selectedNodeRelated = new Set();

    // DOM element references
    this.nodeElements = null;
    this.linkElements = null;
    this.labelElements = null;
  }

  /**
   * Initialize with DOM elements
   * @param {Object} elements - Object containing D3 selections
   */
  initialize(elements) {
    this.nodeElements = elements.nodes;
    this.linkElements = elements.links;
    this.labelElements = elements.labels;
  }

  /**
   * Update data references
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   */
  updateData(nodes, links) {
    this.nodes = nodes || [];
    this.links = links || [];
    this.nodeDistances.clear();
  }

  /**
   * Calculate graph distance between two nodes using BFS
   * @param {string} sourceId - Source node ID
   * @param {string} targetId - Target node ID
   * @returns {number} - Graph distance (hops between nodes)
   */
  calculateGraphDistance(sourceId, targetId) {
    if (sourceId === targetId) return 0;
    
    const cacheKey = `${sourceId}-${targetId}`;
    if (this.nodeDistances.has(cacheKey)) {
      return this.nodeDistances.get(cacheKey);
    }
    
    // Build adjacency list
    const adjacencyList = new Map();
    this.nodes.forEach(node => adjacencyList.set(node.id, []));
    
    this.links.forEach(link => {
      const sourceNodeId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetNodeId = typeof link.target === 'object' ? link.target.id : link.target;
      
      if (adjacencyList.has(sourceNodeId) && adjacencyList.has(targetNodeId)) {
        adjacencyList.get(sourceNodeId).push(targetNodeId);
        adjacencyList.get(targetNodeId).push(sourceNodeId);
      }
    });
    
    // BFS to find shortest path
    const queue = [{ nodeId: sourceId, distance: 0 }];
    const visited = new Set([sourceId]);
    
    while (queue.length > 0) {
      const { nodeId, distance } = queue.shift();
      
      if (nodeId === targetId) {
        this.nodeDistances.set(cacheKey, distance);
        this.nodeDistances.set(`${targetId}-${sourceId}`, distance);
        return distance;
      }
      
      const neighbors = adjacencyList.get(nodeId) || [];
      for (const neighborId of neighbors) {
        if (!visited.has(neighborId)) {
          visited.add(neighborId);
          queue.push({ nodeId: neighborId, distance: distance + 1 });
        }
      }
    }
    
    // No path found
    const maxDistance = 999;
    this.nodeDistances.set(cacheKey, maxDistance);
    this.nodeDistances.set(`${targetId}-${sourceId}`, maxDistance);
    return maxDistance;
  }

  /**
   * Apply continuous hover effects (Mac dock style)
   * @param {Object} centerNode - Node being hovered
   * @param {number} centerDistance - Distance from mouse to center node
   * @param {Object} mousePosition - Mouse position in graph coordinates
   */
  applyContinuousHoverEffects(centerNode, centerDistance, mousePosition) {
    if (this.isInLayerMode || this.isInAudienceMode) return;

    const nodeEffects = this.nodes.map(node => {
      let scaleFactor, opacityFactor;
    
      if (node.id === centerNode.id) {
        // Center node scales based on mouse proximity
        const proximityFactor = Math.max(0, 1 - centerDistance / this.config.hoverRadius);
        scaleFactor = 1 + (this.config.maxHoverScale - 1) * proximityFactor;
        opacityFactor = 1.0;
      } else {
        // Other nodes scale based on graph distance from center node
        const graphDistance = this.calculateGraphDistance(centerNode.id, node.id);
        const proximityFactor = Math.max(0, 1 - centerDistance / this.config.hoverRadius);
      
        let baseScale = this.getDistanceBasedScale(graphDistance);
      
        // Apply proximity-based scaling
        scaleFactor = baseScale + (1 - baseScale) * (1 - proximityFactor);
        opacityFactor = baseScale + (1 - baseScale) * (1 - proximityFactor);
      }
    
      return {
        nodeId: node.id,
        scaleFactor,
        opacityFactor
      };
    });
  
    this.applyNodeTransitions(nodeEffects, this.config.hoverTransitionDuration);
  }

  /**
   * Get scale factor based on graph distance
   * @param {number} distance - Graph distance
   * @returns {number} - Scale factor
   */
  getDistanceBasedScale(distance) {
    const scaling = this.config.distanceScaling;
    if (distance === 1) return scaling.distance1;
    if (distance === 2) return scaling.distance2;
    if (distance === 3) return scaling.distance3;
    return scaling.distanceOther;
  }

  /**
   * Reset all hover effects to normal state
   */
  resetHoverEffects() {
    if (this.isInLayerMode || this.isInAudienceMode) {
      // Don't reset if in layer or audience mode - other effects take precedence
      return;
    }

    this.resetToNormalState();
  }

  /**
   * Set selected node information for visual effects
   * @param {Object|null} selectedNode - Selected node or null
   * @param {Set} selectedNodeRelated - Set of related node IDs
   */
  setSelectedNode(selectedNode, selectedNodeRelated) {
    this.selectedNode = selectedNode;
    this.selectedNodeRelated = selectedNodeRelated || new Set();
  }

  /**
   * Apply audience-based visual effects (blur non-relevant nodes)
   * @param {string} audienceId - Current audience filter
   * @param {Array} nodes - Array of node objects
   */
  applyAudienceEffects(audienceId, nodes) {
    this.currentAudience = audienceId;
    this.isInAudienceMode = true;

    if (!this.nodeElements) return;
    
    // Apply blur and opacity effects based on audience relevance
    this.nodeElements
      .transition()
      .duration(this.config.audienceTransitionDuration)
      .style('filter', d => {
        // If this node is related to the selected node, never blur it
        if (this.selectedNode && this.selectedNodeRelated.has(d.id)) {
          return 'none';
        }

        // Handle audience as array or string
        let nodeAudience = d.audience || ['general'];
        if (typeof nodeAudience === 'string') {
          nodeAudience = [nodeAudience];
        }
        return nodeAudience.includes(audienceId) ? 'none' : `blur(${this.config.audienceBlurAmount}px)`;
      })
      .style('opacity', d => {
        // If this node is related to the selected node, full opacity
        if (this.selectedNode && this.selectedNodeRelated.has(d.id)) {
          return this.config.theme.defaultOpacity;
        }

        // Handle audience as array or string
        let nodeAudience = d.audience || ['general'];
        if (typeof nodeAudience === 'string') {
          nodeAudience = [nodeAudience];
        }
        return nodeAudience.includes(audienceId) ? this.config.theme.defaultOpacity : this.config.audienceOpacityReduced;
      });
    
    // Link visibility is now managed by KnowledgeGraphExplorer.updateLinkVisibility()
    // based on label visibility rather than audience relevance
  }

  /**
   * Reset all visual effects to normal state
   */
  resetToNormalState() {
    if (this.nodeElements) {
      this.nodeElements
        .transition()
        .duration(200)
        .ease(d3.easeQuadOut)
        .attr('r', d => d.size || 10)
        .attr('opacity', this.config.theme.defaultOpacity)
        .style('filter', 'none');
    }
    
    if (this.labelElements) {
      this.labelElements
        .transition()
        .duration(200)
        .ease(d3.easeQuadOut)
        .style('font-size', this.config.theme.fontSizeBase + 'px')
        .attr('opacity', this.config.theme.defaultOpacity);
    }
    
    if (this.linkElements) {
      this.linkElements
        .transition()
        .duration(200)
        .ease(d3.easeQuadOut)
        .attr('opacity', this.config.theme.dimmedOpacity)
        .attr('stroke-width', d => Math.sqrt(d.strength || 0.5) * this.config.theme.baseStrokeWidth)
        .style('filter', 'none');
    }
  }

  /**
   * Apply layer-based visual effects
   * @param {string} activeLayer - ID of the active layer
   */
  applyLayerEffects(activeLayer) {
    this.currentLayer = activeLayer;
    this.isInLayerMode = activeLayer !== null;
    
    if (!this.isInLayerMode) {
      // If no audience mode is active, reset to normal state
      if (!this.isInAudienceMode) {
        this.resetToNormalState();
      }
      return;
    }

    const nodeLayerEffects = this.nodes.map(node => {
      const isActiveLayer = node.layer === activeLayer;
      const hasActiveConnection = this.hasConnectionToActiveLayer(node, activeLayer);
      
      let scaleFactor, opacityFactor;
      
      if (isActiveLayer) {
        scaleFactor = this.config.layerScaling.activeLayer;
        opacityFactor = this.config.layerScaling.activeLayer;
      } else if (hasActiveConnection) {
        const distance = this.getMinDistanceToActiveLayer(node, activeLayer);
        const connectedScaling = this.config.layerScaling.connectedNodes;
        
        if (distance === 1) {
          scaleFactor = connectedScaling.distance1;
          opacityFactor = connectedScaling.distance1;
        } else if (distance === 2) {
          scaleFactor = connectedScaling.distance2;
          opacityFactor = connectedScaling.distance2;
        } else {
          scaleFactor = connectedScaling.distanceOther;
          opacityFactor = connectedScaling.distanceOther;
        }
      } else {
        scaleFactor = this.config.layerScaling.disconnectedNodes;
        opacityFactor = this.config.layerScaling.disconnectedNodes;
      }
      
      return {
        nodeId: node.id,
        scaleFactor,
        opacityFactor,
        isActiveLayer
      };
    });
    
    this.applyLayerTransitions(nodeLayerEffects);
  }

  /**
   * Check if node has connection to active layer
   * @param {Object} node - Node to check
   * @param {string} activeLayer - Active layer ID
   * @returns {boolean} - Whether node connects to active layer
   */
  hasConnectionToActiveLayer(node, activeLayer) {
    return this.links.some(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      
      if (node.id === sourceId) {
        const targetNode = this.nodes.find(n => n.id === targetId);
        return targetNode && targetNode.layer === activeLayer;
      } else if (node.id === targetId) {
        const sourceNode = this.nodes.find(n => n.id === sourceId);
        return sourceNode && sourceNode.layer === activeLayer;
      }
      
      return false;
    });
  }

  /**
   * Get minimum distance to any node in active layer
   * @param {Object} node - Node to check
   * @param {string} activeLayer - Active layer ID
   * @returns {number} - Minimum distance to active layer
   */
  getMinDistanceToActiveLayer(node, activeLayer) {
    const activeLayerNodes = this.nodes.filter(n => n.layer === activeLayer);
    let minDistance = 999;
    
    for (const activeNode of activeLayerNodes) {
      const distance = this.calculateGraphDistance(node.id, activeNode.id);
      minDistance = Math.min(minDistance, distance);
    }
    
    return minDistance;
  }

  /**
   * Apply node transitions for hover effects
   * @param {Array} nodeEffects - Array of effect objects
   * @param {number} duration - Transition duration in ms
   */
  applyNodeTransitions(nodeEffects, duration = 250) {
    const effectsMap = new Map();
    nodeEffects.forEach(effect => {
      effectsMap.set(effect.nodeId, effect);
    });
    
    if (this.nodeElements) {
      this.nodeElements
        .transition()
        .duration(duration)
        .ease(d3.easeQuadOut)
        .attr('r', d => {
          const effect = effectsMap.get(d.id);
          return (d.size || 10) * (effect ? effect.scaleFactor : 1);
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    
    if (this.labelElements) {
      this.labelElements
        .transition()
        .duration(duration)
        .ease(d3.easeQuadOut)
        .style('font-size', d => {
          const effect = effectsMap.get(d.id);
          const baseFontSize = this.config.theme.fontSizeBase;
          return `${baseFontSize * (effect ? effect.scaleFactor : 1)}px`;
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    
    if (this.linkElements) {
      this.linkElements
        .transition()
        .duration(duration)
        .ease(d3.easeQuadOut)
        .attr('opacity', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          
          const sourceEffect = effectsMap.get(sourceId);
          const targetEffect = effectsMap.get(targetId);
          
          const sourceOpacity = sourceEffect ? sourceEffect.opacityFactor : this.config.theme.defaultOpacity;
          const targetOpacity = targetEffect ? targetEffect.opacityFactor : this.config.theme.defaultOpacity;
          
          return Math.min(sourceOpacity, targetOpacity) * this.config.theme.dimmedOpacity;
        });
    }
  }

  /**
   * Apply layer transitions with longer duration and different easing
   * @param {Array} nodeLayerEffects - Array of layer effect objects
   */
  applyLayerTransitions(nodeLayerEffects) {
    const effectsMap = new Map();
    nodeLayerEffects.forEach(effect => {
      effectsMap.set(effect.nodeId, effect);
    });
    
    if (this.nodeElements) {
      this.nodeElements
        .transition()
        .duration(this.config.layerTransitionDuration)
        .ease(d3.easeQuadInOut)
        .attr('r', d => {
          const effect = effectsMap.get(d.id);
          return (d.size || 10) * (effect ? effect.scaleFactor : 1);
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    
    if (this.labelElements) {
      this.labelElements
        .transition()
        .duration(this.config.layerTransitionDuration)
        .ease(d3.easeQuadInOut)
        .style('font-size', d => {
          const effect = effectsMap.get(d.id);
          const baseFontSize = this.config.theme.fontSizeBase;
          return `${baseFontSize * (effect ? effect.scaleFactor : 1)}px`;
        })
        .attr('opacity', d => {
          const effect = effectsMap.get(d.id);
          return effect ? effect.opacityFactor : this.config.theme.defaultOpacity;
        });
    }
    
    if (this.linkElements) {
      this.linkElements
        .transition()
        .duration(this.config.layerTransitionDuration)
        .ease(d3.easeQuadInOut)
        .attr('opacity', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          
          const sourceEffect = effectsMap.get(sourceId);
          const targetEffect = effectsMap.get(targetId);
          
          const sourceOpacity = sourceEffect ? sourceEffect.opacityFactor : this.config.theme.defaultOpacity;
          const targetOpacity = targetEffect ? targetEffect.opacityFactor : this.config.theme.defaultOpacity;
          
          return Math.min(sourceOpacity, targetOpacity) * this.config.theme.dimmedOpacity;
        })
        .attr('stroke-width', d => {
          const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
          const targetId = typeof d.target === 'object' ? d.target.id : d.target;
          
          const sourceEffect = effectsMap.get(sourceId);
          const targetEffect = effectsMap.get(targetId);
          
          const baseWidth = Math.sqrt(d.strength || 0.5) * this.config.theme.baseStrokeWidth;
          const sourceScale = sourceEffect ? sourceEffect.scaleFactor : 1;
          const targetScale = targetEffect ? targetEffect.scaleFactor : 1;
          
          return baseWidth * Math.max(sourceScale, targetScale);
        });
    }
  }

  /**
   * Highlight specific nodes with special effects
   * @param {Array} nodeIds - Array of node IDs to highlight
   * @param {Object} highlightConfig - Highlight configuration
   */
  highlightNodes(nodeIds, highlightConfig = {}) {
    const config = {
      scaleFactor: 1.2,
      opacityFactor: 1.0,
      duration: 300,
      ...highlightConfig
    };

    const highlightSet = new Set(nodeIds);
    
    const nodeEffects = this.nodes.map(node => ({
      nodeId: node.id,
      scaleFactor: highlightSet.has(node.id) ? config.scaleFactor : 0.5,
      opacityFactor: highlightSet.has(node.id) ? config.opacityFactor : 0.3
    }));

    this.applyNodeTransitions(nodeEffects, config.duration);
  }

  /**
   * Create pulsing animation effect
   * @param {string} nodeId - Node ID to animate
   * @param {Object} pulseConfig - Pulse configuration
   */
  pulseNode(nodeId, pulseConfig = {}) {
    const config = {
      scaleFactor: 1.5,
      duration: 600,
      iterations: 3,
      ...pulseConfig
    };

    const node = this.nodes.find(n => n.id === nodeId);
    if (!node) return;

    const nodeElement = this.nodeElements ? this.nodeElements.filter(d => d.id === nodeId) : null;
    const labelElement = this.labelElements ? this.labelElements.filter(d => d.id === nodeId) : null;

    if (nodeElement && nodeElement.size() > 0) {
      const baseSize = node.size || 10;
      const baseFontSize = this.config.theme.fontSizeBase;

      // Create pulsing animation
      for (let i = 0; i < config.iterations; i++) {
        nodeElement
          .transition()
          .delay(i * config.duration)
          .duration(config.duration / 2)
          .ease(d3.easeQuadInOut)
          .attr('r', baseSize * config.scaleFactor)
          .transition()
          .duration(config.duration / 2)
          .ease(d3.easeQuadInOut)
          .attr('r', baseSize);

        if (labelElement && labelElement.size() > 0) {
          labelElement
            .transition()
            .delay(i * config.duration)
            .duration(config.duration / 2)
            .ease(d3.easeQuadInOut)
            .style('font-size', `${baseFontSize * config.scaleFactor}px`)
            .transition()
            .duration(config.duration / 2)
            .ease(d3.easeQuadInOut)
            .style('font-size', `${baseFontSize}px`);
        }
      }
    }
  }

  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);
  }

  /**
   * Get current visual state
   * @returns {Object} - Visual state information
   */
  getState() {
    return {
      isInLayerMode: this.isInLayerMode,
      isInAudienceMode: this.isInAudienceMode,
      currentLayer: this.currentLayer,
      currentAudience: this.currentAudience,
      hoveredNode: this.hoveredNode ? this.hoveredNode.id : null,
      nodeCount: this.nodes.length,
      linkCount: this.links.length,
      config: { ...this.config }
    };
  }

  /**
   * Clear distance cache (call when graph structure changes)
   */
  clearDistanceCache() {
    this.nodeDistances.clear();
  }

  /**
   * Cleanup and reset all effects
   */
  destroy() {
    this.resetToNormalState();
    this.nodeDistances.clear();
    this.nodes = [];
    this.links = [];
    this.hoveredNode = null;
    this.currentLayer = null;
    this.currentAudience = 'current_focus';
    this.isInLayerMode = false;
    this.isInAudienceMode = false;
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = VisualEffectsManager;
} else if (typeof window !== 'undefined') {
  window.VisualEffectsManager = VisualEffectsManager;
}

// core/MiniMapManager.js
/**
 * MiniMap Manager for Knowledge Graph Explorer
 * Handles the miniature overview map with viewport indicator and navigation
 */
class MiniMapManager {
  constructor(config = {}) {
    this.config = {
      width: 150,
      height: 120,
      padding: 10,
      position: 'bottom-left', // 'bottom-left', 'bottom-right', 'top-left', 'top-right'
      
      // Visual settings
      backgroundColor: '#f8f9faE6', // 90% opacity
      borderColor: '#2780e3',
      borderWidth: 1,
      borderRadius: 6,
      
      // Viewport indicator
      viewportColor: '#2780e3',
      viewportOpacity: 0.7,
      viewportStrokeWidth: 2,
      
      // Node/link styling in minimap
      nodeOpacity: 0.8,
      linkOpacity: 0.4,
      nodeMinSize: 1,
      nodeMaxSize: 3,
      linkStrokeWidth: 0.5,
      
      // Interaction
      clickToNavigate: true,
      showOnHover: false,
      
      ...config
    };

    // State
    this.nodes = [];
    this.links = [];
    this.isVisible = true;
    this.coordinateTransform = null;
    
    // Rendering state
    this.scale = 1;
    this.offsetX = 0;
    this.offsetY = 0;
    this.bounds = null;
    
    // DOM elements
    this.container = null;
    this.containerElement = null;
    this.svg = null;
    this.mainGroup = null;
    this.linkGroup = null;
    this.nodeGroup = null;
    this.viewportIndicator = null;

    // Event handlers
    this.eventHandlers = {};
  }

  /**
   * Initialize minimap with parent container and coordinate transform
   * @param {Element} parentContainer - Parent DOM element
   * @param {CoordinateTransform} coordinateTransform - Coordinate transformation utility
   */
  initialize(parentContainer, coordinateTransform) {
    this.container = parentContainer;
    this.coordinateTransform = coordinateTransform;
    
    this.createMiniMapContainer();
    this.setupSVG();
    this.setupEventListeners();
  }

  /**
   * Create the minimap container element
   */
  createMiniMapContainer() {
    this.containerElement = document.createElement('div');
    this.containerElement.className = 'mini-map';
    this.containerElement.style.cssText = this.getContainerStyles();
    
    this.container.appendChild(this.containerElement);
  }

  /**
   * Get CSS styles for the container
   * @returns {string} - CSS style string
   */
  getContainerStyles() {
    const position = this.getPositionStyles();
    
    return `
      position: absolute;
      width: ${this.config.width}px;
      height: ${this.config.height}px;
      background-color: ${this.config.backgroundColor};
      border: ${this.config.borderWidth}px solid ${this.config.borderColor};
      border-radius: ${this.config.borderRadius}px;
      overflow: hidden;
      cursor: pointer;
      backdrop-filter: blur(5px);
      z-index: 10;
      ${position}
    `.replace(/\s+/g, ' ').trim();
  }

  /**
   * Get position styles based on configuration
   * @returns {string} - Position CSS
   */
  getPositionStyles() {
    const margin = 10;
    
    switch (this.config.position) {
      case 'top-left':
        return `top: ${margin}px; left: ${margin}px;`;
      case 'top-right':
        return `top: ${margin}px; right: ${margin}px;`;
      case 'bottom-right':
        return `bottom: ${margin}px; right: ${margin}px;`;
      case 'bottom-left':
      default:
        return `bottom: ${margin}px; left: ${margin}px;`;
    }
  }

  /**
   * Setup SVG and its groups
   */
  setupSVG() {
    this.svg = d3.select(this.containerElement)
      .append('svg')
      .attr('width', this.config.width)
      .attr('height', this.config.height);

    // Create groups for different elements
    this.mainGroup = this.svg.append('g').attr('class', 'mini-map-main');
    this.linkGroup = this.mainGroup.append('g').attr('class', 'mini-map-links');
    this.nodeGroup = this.mainGroup.append('g').attr('class', 'mini-map-nodes');
    
    // Create viewport indicator
    this.viewportIndicator = this.svg.append('rect')
      .attr('class', 'viewport-indicator')
      .attr('fill', 'none')
      .attr('stroke', this.config.viewportColor)
      .attr('stroke-width', this.config.viewportStrokeWidth)
      .attr('opacity', this.config.viewportOpacity);
  }

  /**
   * Setup event listeners
   */
  setupEventListeners() {
    if (this.config.clickToNavigate) {
      this.svg.on('click', (event) => {
        const [x, y] = d3.pointer(event);
        this.navigateToPosition(x, y);
      });
    }

    if (this.config.showOnHover) {
      this.containerElement.addEventListener('mouseenter', () => {
        this.show();
      });
      
      this.containerElement.addEventListener('mouseleave', () => {
        this.hide();
      });
    }
  }

  /**
   * Update data and refresh the minimap
   * @param {Array} nodes - Array of node objects
   * @param {Array} links - Array of link objects
   */
  updateData(nodes, links) {
    this.nodes = nodes || [];
    this.links = links || [];
    this.render();
  }

  /**
   * Calculate bounds of all nodes
   * @returns {Object|null} - Bounds object or null if no nodes
   */
  calculateBounds() {
    if (this.nodes.length === 0) return null;

    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        minX = Math.min(minX, node.x);
        maxX = Math.max(maxX, node.x);
        minY = Math.min(minY, node.y);
        maxY = Math.max(maxY, node.y);
      }
    });

    if (minX === Infinity) return null;

    return {
      minX, maxX, minY, maxY,
      width: maxX - minX,
      height: maxY - minY,
      centerX: (minX + maxX) / 2,
      centerY: (minY + maxY) / 2
    };
  }

  /**
   * Calculate scale and offset for fitting content
   */
  calculateTransform() {
    this.bounds = this.calculateBounds();
    if (!this.bounds) {
      this.scale = 1;
      this.offsetX = 0;
      this.offsetY = 0;
      return;
    }

    const availableWidth = this.config.width - 2 * this.config.padding;
    const availableHeight = this.config.height - 2 * this.config.padding;

    const scaleX = availableWidth / this.bounds.width;
    const scaleY = availableHeight / this.bounds.height;
    this.scale = Math.min(scaleX, scaleY, 0.3); // Max scale to prevent too much zoom

    this.offsetX = (this.config.width - this.bounds.width * this.scale) / 2 - this.bounds.minX * this.scale;
    this.offsetY = (this.config.height - this.bounds.height * this.scale) / 2 - this.bounds.minY * this.scale;
  }

  /**
   * Render the minimap
   */
  render() {
    this.calculateTransform();
    this.renderLinks();
    this.renderNodes();
    this.updateViewportIndicator();
  }

  /**
   * Render links in the minimap
   */
  renderLinks() {
    if (!this.bounds) return;

    const linkSelection = this.linkGroup
      .selectAll('line')
      .data(this.links, d => d.id || `${d.source}-${d.target}`);

    linkSelection.exit().remove();

    linkSelection.enter()
      .append('line')
      .attr('stroke', this.config.borderColor)
      .attr('stroke-width', this.config.linkStrokeWidth)
      .attr('stroke-opacity', this.config.linkOpacity)
      .merge(linkSelection)
      .attr('x1', d => {
        const sourceNode = this.nodes.find(n => n.id === (typeof d.source === 'object' ? d.source.id : d.source));
        return this.offsetX + (sourceNode ? sourceNode.x : 0) * this.scale;
      })
      .attr('y1', d => {
        const sourceNode = this.nodes.find(n => n.id === (typeof d.source === 'object' ? d.source.id : d.source));
        return this.offsetY + (sourceNode ? sourceNode.y : 0) * this.scale;
      })
      .attr('x2', d => {
        const targetNode = this.nodes.find(n => n.id === (typeof d.target === 'object' ? d.target.id : d.target));
        return this.offsetX + (targetNode ? targetNode.x : 0) * this.scale;
      })
      .attr('y2', d => {
        const targetNode = this.nodes.find(n => n.id === (typeof d.target === 'object' ? d.target.id : d.target));
        return this.offsetY + (targetNode ? targetNode.y : 0) * this.scale;
      });
  }

  /**
   * Render nodes in the minimap
   */
  renderNodes() {
    if (!this.bounds) return;

    const nodeSelection = this.nodeGroup
      .selectAll('circle')
      .data(this.nodes, d => d.id);

    nodeSelection.exit().remove();

    nodeSelection.enter()
      .append('circle')
      .attr('stroke', 'none')
      .attr('opacity', this.config.nodeOpacity)
      .merge(nodeSelection)
      .attr('cx', d => this.offsetX + d.x * this.scale)
      .attr('cy', d => this.offsetY + d.y * this.scale)
      .attr('r', d => this.getNodeRadius(d))
      .attr('fill', d => this.getNodeColor(d));
  }

  /**
   * Get node radius for minimap
   * @param {Object} node - Node object
   * @returns {number} - Radius value
   */
  getNodeRadius(node) {
    const baseRadius = (node.size || 10) / 10; // Normalize
    return Math.max(
      this.config.nodeMinSize,
      Math.min(this.config.nodeMaxSize, baseRadius)
    );
  }

  /**
   * Get node color (can be overridden for custom coloring)
   * @param {Object} node - Node object
   * @returns {string} - Color value
   */
  getNodeColor(node) {
    // Default color scheme - can be customized
    const colorMap = {
      'education': '#2780e3',
      'research': '#3fb618',
      'industry': '#ffdd3c',
      'current': '#ff0039',
      'geographic': '#613d7c'
    };
    
    return colorMap[node.type] || colorMap[node.layer] || this.config.borderColor;
  }

  /**
   * Update viewport indicator based on current zoom/pan
   */
  updateViewportIndicator() {
    if (!this.coordinateTransform || !this.bounds) return;

    const transform = this.coordinateTransform.getTransform();
    const viewport = this.coordinateTransform.getVisibleBounds();

    // Calculate viewport rectangle in minimap coordinates
    const viewportWidth = viewport.width * this.scale;
    const viewportHeight = viewport.height * this.scale;
    
    const viewportX = this.offsetX + (viewport.minX - this.bounds.minX) * this.scale;
    const viewportY = this.offsetY + (viewport.minY - this.bounds.minY) * this.scale;

    // Clamp to minimap boundaries
    const clampedX = Math.max(0, Math.min(this.config.width - viewportWidth, viewportX));
    const clampedY = Math.max(0, Math.min(this.config.height - viewportHeight, viewportY));
    const clampedWidth = Math.min(viewportWidth, this.config.width - clampedX);
    const clampedHeight = Math.min(viewportHeight, this.config.height - clampedY);

    this.viewportIndicator
      .attr('x', clampedX)
      .attr('y', clampedY)
      .attr('width', Math.max(1, clampedWidth))
      .attr('height', Math.max(1, clampedHeight));
  }

  /**
   * Navigate to a position clicked in the minimap
   * @param {number} miniX - X coordinate in minimap
   * @param {number} miniY - Y coordinate in minimap
   */
  navigateToPosition(miniX, miniY) {
    if (!this.coordinateTransform || !this.bounds) return;

    // Convert minimap coordinates to graph coordinates
    const graphX = (miniX - this.offsetX) / this.scale + this.bounds.minX;
    const graphY = (miniY - this.offsetY) / this.scale + this.bounds.minY;

    this.emit('navigate', { 
      graphPosition: { x: graphX, y: graphY },
      miniMapPosition: { x: miniX, y: miniY }
    });
  }

  /**
   * Set minimap position
   * @param {string} position - Position string
   */
  setPosition(position) {
    this.config.position = position;
    if (this.containerElement) {
      const positionStyles = this.getPositionStyles();
      this.containerElement.style.cssText = this.getContainerStyles();
    }
  }

  /**
   * Show the minimap
   */
  show() {
    this.isVisible = true;
    if (this.containerElement) {
      this.containerElement.style.display = 'block';
    }
  }

  /**
   * Hide the minimap
   */
  hide() {
    this.isVisible = false;
    if (this.containerElement) {
      this.containerElement.style.display = 'none';
    }
  }

  /**
   * Toggle minimap visibility
   */
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }

  /**
   * Update minimap size
   * @param {number} width - New width
   * @param {number} height - New height
   */
  resize(width, height) {
    this.config.width = width;
    this.config.height = height;
    
    if (this.containerElement) {
      this.containerElement.style.width = width + 'px';
      this.containerElement.style.height = height + 'px';
    }
    
    if (this.svg) {
      this.svg.attr('width', width).attr('height', height);
    }
    
    this.render();
  }

  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);
    
    if (this.containerElement) {
      this.containerElement.style.cssText = this.getContainerStyles();
    }
    
    this.render();
  }

  /**
   * Get minimap statistics
   * @returns {Object} - Minimap state information
   */
  getStats() {
    return {
      isVisible: this.isVisible,
      position: this.config.position,
      dimensions: {
        width: this.config.width,
        height: this.config.height
      },
      bounds: this.bounds,
      transform: {
        scale: this.scale,
        offsetX: this.offsetX,
        offsetY: this.offsetY
      },
      nodeCount: this.nodes.length,
      linkCount: this.links.length
    };
  }

  /**
   * Focus on a specific node in the minimap
   * @param {string} nodeId - Node ID to focus on
   */
  focusNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node.x !== undefined && node.y !== undefined) {
      this.navigateToPosition(
        this.offsetX + node.x * this.scale,
        this.offsetY + node.y * this.scale
      );
    }
  }

  /**
   * Highlight specific nodes in the minimap
   * @param {Array} nodeIds - Array of node IDs to highlight
   * @param {Object} highlightConfig - Highlight configuration
   */
  highlightNodes(nodeIds, highlightConfig = {}) {
    const config = {
      color: '#ff0039',
      strokeWidth: 2,
      ...highlightConfig
    };

    const highlightSet = new Set(nodeIds);
    
    this.nodeGroup.selectAll('circle')
      .attr('stroke', d => highlightSet.has(d.id) ? config.color : 'none')
      .attr('stroke-width', d => highlightSet.has(d.id) ? config.strokeWidth : 0);
  }

  /**
   * Clear all highlights
   */
  clearHighlights() {
    this.nodeGroup.selectAll('circle')
      .attr('stroke', 'none')
      .attr('stroke-width', 0);
  }

  /**
   * Add event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }

  /**
   * Remove event listener
   * @param {string} eventType - Type of event
   * @param {Function} callback - Callback function to remove
   */
  off(eventType, callback) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = this.eventHandlers[eventType].filter(cb => cb !== callback);
    }
    return this;
  }

  /**
   * Emit event to all listeners
   * @param {string} eventType - Type of event
   * @param {Object} data - Event data
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in minimap event handler for ${eventType}:`, error);
        }
      });
    }
  }

  /**
   * Cleanup and destroy the minimap
   */
  destroy() {
    // Remove DOM elements
    if (this.containerElement && this.container) {
      this.container.removeChild(this.containerElement);
    }

    // Clear references
    this.eventHandlers = {};
    this.nodes = [];
    this.links = [];
    this.containerElement = null;
    this.svg = null;
    this.coordinateTransform = null;
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = MiniMapManager;
} else if (typeof window !== 'undefined') {
  window.MiniMapManager = MiniMapManager;
}

// core/LabelLayoutManager.js
/**
 * Label Layout Manager for Knowledge Graph Explorer
 * Handles intelligent positioning of node labels to prevent overlaps
 */
class LabelLayoutManager {
  constructor(config = {}) {
    this.config = {
      // Label positioning preferences
      enabled: true,
      preferredPositions: ['bottom', 'right', 'top', 'left'],
      maxDistance: 50,
      minDistance: 15,
      padding: 8,

      // Collision detection
      collisionIterations: 3,
      positioningIterations: 2,

      // Animation
      transitionDuration: 200,

      // Font metrics (estimated ratios for common fonts)
      fontMetrics: {
        widthRatio: 0.6,  // Character width to font size ratio
        heightRatio: 1.1  // Line height to font size ratio
      },

      ...config
    };

    this.labels = [];
    this.nodes = [];
    this.labelElements = null;
    this.currentZoomScale = 1;

    // Cache for text measurements
    this.textMeasureCache = new Map();

    // Position constants for different directions
    this.POSITIONS = {
      bottom: { dx: 0, dy: 1 },
      right: { dx: 1, dy: 0 },
      top: { dx: 0, dy: -1 },
      left: { dx: -1, dy: 0 }
    };
  }

  /**
   * Initialize with node data and label elements
   * @param {Array} nodes - Array of node objects
   * @param {Selection} labelElements - D3 selection of label elements
   */
  initialize(nodes, labelElements) {
    this.nodes = nodes;
    this.labelElements = labelElements;
    this.updateLabelData();
  }

  /**
   * Update label data from current node positions and visibility
   */
  updateLabelData() {
    if (!this.labelElements || !this.nodes) return;

    this.labels = [];

    this.labelElements.each((d, i, nodes) => {
      const element = nodes[i];
      const node = d;

      // Only process visible labels
      const opacity = parseFloat(d3.select(element).style('opacity')) || 0;
      if (opacity <= 0) return;

      const labelData = {
        id: node.id,
        node: node,
        element: element,
        text: node.label || '',
        originalX: node.x,
        originalY: node.y + (node.size || 10) + 18,
        x: node.x,
        y: node.y + (node.size || 10) + 18,
        width: 0,
        height: 0,
        fontSize: this.getCurrentFontSize(element),
        preferredPosition: 'bottom',
        currentPosition: 'bottom'
      };

      // Calculate text dimensions
      this.calculateTextDimensions(labelData);

      this.labels.push(labelData);
    });
  }

  /**
   * Calculate text dimensions for a label
   * @param {Object} labelData - Label data object
   */
  calculateTextDimensions(labelData) {
    const cacheKey = `${labelData.text}_${labelData.fontSize}_${this.currentZoomScale}`;

    if (this.textMeasureCache.has(cacheKey)) {
      const cached = this.textMeasureCache.get(cacheKey);
      labelData.width = cached.width;
      labelData.height = cached.height;
      return;
    }

    // Use text measurement if available, otherwise estimate
    if (labelData.element) {
      try {
        const bbox = labelData.element.getBBox();
        labelData.width = bbox.width;
        labelData.height = bbox.height;
      } catch (e) {
        // Fallback to estimation
        this.estimateTextDimensions(labelData);
      }
    } else {
      this.estimateTextDimensions(labelData);
    }

    // Cache the result
    this.textMeasureCache.set(cacheKey, {
      width: labelData.width,
      height: labelData.height
    });

    // Limit cache size
    if (this.textMeasureCache.size > 200) {
      const firstKey = this.textMeasureCache.keys().next().value;
      this.textMeasureCache.delete(firstKey);
    }
  }

  /**
   * Estimate text dimensions based on font metrics
   * @param {Object} labelData - Label data object
   */
  estimateTextDimensions(labelData) {
    const fontSize = labelData.fontSize;
    const text = labelData.text || '';

    labelData.width = text.length * fontSize * this.config.fontMetrics.widthRatio;
    labelData.height = fontSize * this.config.fontMetrics.heightRatio;
  }

  /**
   * Get current font size from element or zoom-adjusted default
   * @param {Element} element - Label element
   * @returns {number} Font size in pixels
   */
  getCurrentFontSize(element) {
    if (element) {
      const style = window.getComputedStyle(element);
      const fontSize = parseFloat(style.fontSize);
      if (!isNaN(fontSize)) return fontSize;
    }

    // Fallback: estimate based on zoom scale
    const baseSize = 14;
    return baseSize / this.currentZoomScale;
  }

  /**
   * Update zoom scale for font size calculations
   * @param {number} zoomScale - Current zoom scale
   */
  updateZoomScale(zoomScale) {
    this.currentZoomScale = zoomScale;
    this.textMeasureCache.clear(); // Clear cache when zoom changes
  }

  /**
   * Calculate optimal label positions to avoid overlaps
   * @param {Array} visibleLabels - Array of visible labels (optional, uses all if not provided)
   */
  calculateOptimalPositions(visibleLabels = null) {
    if (!this.config.enabled) return;

    const labelsToProcess = visibleLabels || this.labels.filter(label =>
      this.labelElements && this.labelElements.filter(function() { return this === label.element; }).size() > 0
    );

    if (labelsToProcess.length === 0) return;

    // Update text dimensions for all labels
    labelsToProcess.forEach(label => {
      this.calculateTextDimensions(label);
    });

    // Apply collision avoidance algorithm
    for (let iteration = 0; iteration < this.config.positioningIterations; iteration++) {
      this.resolveCollisions(labelsToProcess);
    }
  }

  /**
   * Resolve collisions between labels using intelligent repositioning
   * @param {Array} labels - Labels to process
   */
  resolveCollisions(labels) {
    // Create spatial index for efficient collision detection
    const spatialIndex = this.createSpatialIndex(labels);

    for (let i = 0; i < labels.length; i++) {
      const labelA = labels[i];
      const conflicts = this.findConflicts(labelA, spatialIndex);

      if (conflicts.length > 0) {
        this.repositionLabel(labelA, conflicts);
      }
    }
  }

  /**
   * Create a simple spatial index for labels
   * @param {Array} labels - Labels to index
   * @returns {Map} Spatial index map
   */
  createSpatialIndex(labels) {
    const gridSize = 100;
    const index = new Map();

    labels.forEach(label => {
      const bounds = this.getLabelBounds(label);
      const gridX = Math.floor(bounds.centerX / gridSize);
      const gridY = Math.floor(bounds.centerY / gridSize);

      // Add to multiple grid cells if label spans across them
      for (let x = Math.floor(bounds.left / gridSize); x <= Math.floor(bounds.right / gridSize); x++) {
        for (let y = Math.floor(bounds.top / gridSize); y <= Math.floor(bounds.bottom / gridSize); y++) {
          const key = `${x},${y}`;
          if (!index.has(key)) index.set(key, []);
          index.get(key).push(label);
        }
      }
    });

    return index;
  }

  /**
   * Find labels that conflict with the given label
   * @param {Object} label - Label to check conflicts for
   * @param {Map} spatialIndex - Spatial index for efficient lookup
   * @returns {Array} Array of conflicting labels
   */
  findConflicts(label, spatialIndex) {
    const bounds = this.getLabelBounds(label);
    const gridSize = 100;
    const conflicts = new Set();

    // Check relevant grid cells
    for (let x = Math.floor(bounds.left / gridSize); x <= Math.floor(bounds.right / gridSize); x++) {
      for (let y = Math.floor(bounds.top / gridSize); y <= Math.floor(bounds.bottom / gridSize); y++) {
        const key = `${x},${y}`;
        const candidates = spatialIndex.get(key) || [];

        candidates.forEach(candidate => {
          if (candidate.id !== label.id && this.labelsOverlap(label, candidate)) {
            conflicts.add(candidate);
          }
        });
      }
    }

    return Array.from(conflicts);
  }

  /**
   * Check if two labels overlap
   * @param {Object} labelA - First label
   * @param {Object} labelB - Second label
   * @returns {boolean} True if labels overlap
   */
  labelsOverlap(labelA, labelB) {
    const boundsA = this.getLabelBounds(labelA);
    const boundsB = this.getLabelBounds(labelB);

    return !(boundsA.right < boundsB.left ||
             boundsA.left > boundsB.right ||
             boundsA.bottom < boundsB.top ||
             boundsA.top > boundsB.bottom);
  }

  /**
   * Get bounding box for a label including padding
   * @param {Object} label - Label object
   * @returns {Object} Bounding box {left, right, top, bottom, centerX, centerY}
   */
  getLabelBounds(label) {
    const padding = this.config.padding;
    const halfWidth = label.width / 2;
    const halfHeight = label.height / 2;

    return {
      left: label.x - halfWidth - padding,
      right: label.x + halfWidth + padding,
      top: label.y - halfHeight - padding,
      bottom: label.y + halfHeight + padding,
      centerX: label.x,
      centerY: label.y
    };
  }

  /**
   * Reposition a label to avoid conflicts
   * @param {Object} label - Label to reposition
   * @param {Array} conflicts - Conflicting labels
   */
  repositionLabel(label, conflicts) {
    const node = label.node;
    let bestPosition = null;
    let bestScore = -Infinity;

    // Try each preferred position
    for (const position of this.config.preferredPositions) {
      const candidatePos = this.calculatePositionForDirection(node, label, position);
      const score = this.scorePosition(candidatePos, conflicts, label);

      if (score > bestScore) {
        bestScore = score;
        bestPosition = candidatePos;
      }
    }

    if (bestPosition) {
      label.x = bestPosition.x;
      label.y = bestPosition.y;
      label.currentPosition = bestPosition.direction;
    }
  }

  /**
   * Calculate label position for a specific direction from node
   * @param {Object} node - Node object
   * @param {Object} label - Label object
   * @param {string} direction - Direction ('bottom', 'right', 'top', 'left')
   * @returns {Object} Position {x, y, direction}
   */
  calculatePositionForDirection(node, label, direction) {
    const pos = this.POSITIONS[direction];
    const nodeRadius = node.size || 10;
    const distance = this.config.minDistance + nodeRadius;

    let x = node.x;
    let y = node.y;

    if (direction === 'bottom') {
      y = node.y + distance + (label.height / 2);
    } else if (direction === 'top') {
      y = node.y - distance - (label.height / 2);
    } else if (direction === 'right') {
      x = node.x + distance + (label.width / 2);
    } else if (direction === 'left') {
      x = node.x - distance - (label.width / 2);
    }

    return { x, y, direction };
  }

  /**
   * Score a position based on conflicts and preferences
   * @param {Object} position - Position to score
   * @param {Array} conflicts - Conflicting labels
   * @param {Object} label - Label being positioned
   * @returns {number} Position score (higher is better)
   */
  scorePosition(position, conflicts, label) {
    let score = 0;

    // Create temporary label with new position
    const tempLabel = { ...label, x: position.x, y: position.y };

    // Penalty for conflicts
    conflicts.forEach(conflict => {
      if (this.labelsOverlap(tempLabel, conflict)) {
        score -= 100;
      }
    });

    // Bonus for preferred positions
    const preferenceIndex = this.config.preferredPositions.indexOf(position.direction);
    score += (this.config.preferredPositions.length - preferenceIndex) * 10;

    // Penalty for distance from node
    const distance = Math.sqrt(
      Math.pow(position.x - label.node.x, 2) +
      Math.pow(position.y - label.node.y, 2)
    );

    if (distance > this.config.maxDistance) {
      score -= (distance - this.config.maxDistance) * 2;
    }

    return score;
  }

  /**
   * Apply calculated positions to label elements with animation
   * @param {Array} labelsToUpdate - Labels to update (optional, uses all if not provided)
   */
  applyPositions(labelsToUpdate = null) {
    if (!this.labelElements) return;

    const labels = labelsToUpdate || this.labels;

    // Update positions with smooth transitions
    labels.forEach(label => {
      const element = d3.select(label.element);

      if (this.config.transitionDuration > 0) {
        element
          .transition()
          .duration(this.config.transitionDuration)
          .ease(d3.easeQuadOut)
          .attr('x', label.x)
          .attr('y', label.y);
      } else {
        element
          .attr('x', label.x)
          .attr('y', label.y);
      }
    });
  }

  /**
   * Update data and recalculate positions
   * @param {Array} nodes - Updated node array
   * @param {Selection} labelElements - Updated label elements
   */
  updateData(nodes, labelElements) {
    this.nodes = nodes;
    this.labelElements = labelElements;
    this.updateLabelData();

    if (this.config.enabled) {
      this.calculateOptimalPositions();
      this.applyPositions();
    }
  }

  /**
   * Force immediate position update without animation
   */
  forceUpdate() {
    this.updateLabelData();

    if (this.config.enabled) {
      this.calculateOptimalPositions();

      // Apply positions immediately
      const originalDuration = this.config.transitionDuration;
      this.config.transitionDuration = 0;
      this.applyPositions();
      this.config.transitionDuration = originalDuration;
    }
  }

  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    Object.assign(this.config, newConfig);

    if (this.config.enabled) {
      this.forceUpdate();
    }
  }

  /**
   * Enable or disable label collision detection
   * @param {boolean} enabled - Whether to enable collision detection
   */
  setEnabled(enabled) {
    this.config.enabled = enabled;

    if (enabled) {
      this.forceUpdate();
    }
  }

  /**
   * Clear all cached data
   */
  clearCache() {
    this.textMeasureCache.clear();
  }

  /**
   * Get statistics about current label layout
   * @returns {Object} Layout statistics
   */
  getStats() {
    const stats = {
      totalLabels: this.labels.length,
      cacheSize: this.textMeasureCache.size,
      positionDistribution: {},
      averageDistance: 0
    };

    // Count position distribution
    this.labels.forEach(label => {
      const pos = label.currentPosition;
      stats.positionDistribution[pos] = (stats.positionDistribution[pos] || 0) + 1;
    });

    // Calculate average distance from nodes
    if (this.labels.length > 0) {
      const totalDistance = this.labels.reduce((sum, label) => {
        const distance = Math.sqrt(
          Math.pow(label.x - label.node.x, 2) +
          Math.pow(label.y - label.node.y, 2)
        );
        return sum + distance;
      }, 0);

      stats.averageDistance = totalDistance / this.labels.length;
    }

    return stats;
  }

  /**
   * Cleanup and destroy the manager
   */
  destroy() {
    this.labels = [];
    this.nodes = [];
    this.labelElements = null;
    this.textMeasureCache.clear();
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = LabelLayoutManager;
} else if (typeof window !== 'undefined') {
  window.LabelLayoutManager = LabelLayoutManager;
}

// core/UIControlsManager.js
/**
 * UI Controls Manager for Knowledge Graph Explorer
 * Handles timeline controls, layer buttons, audience filtering, info panels, and other UI elements
 */
class UIControlsManager {
  constructor(config = {}) {
    this.config = {
      showTimeline: true,
      showLayerControls: true,
      showAudienceControls: true,
      showNodeInfo: true,
      showMiniMap: true,
      timelineHeight: 60,
      controlPanelWidth: 200,
      ...config
    };

    // State
    this.graph = null;
    this.container = null;
    this.layers = [];
    this.timeline = { start: 2000, end: 2025 };
    this.currentTimelinePosition = null;
    this.activeLayer = null;
    this.activeAudience = 'current_focus';
    this.selectedNode = null;

    // DOM elements
    this.uiContainer = null;
    this.timelineContainer = null;
    this.layerContainer = null;
    this.audienceContainer = null;
    this.infoPanel = null;
    this.timelineSlider = null;
    this.refreshButton = null;

    // Event handlers
    this.eventHandlers = {};
  }

  /**
   * Detect if dark theme is currently active
   * @returns {boolean} True if dark theme is active
   */
  isDarkTheme() {
    // Check for Quarto's dark theme attribute
    if (document.documentElement.getAttribute('data-bs-theme') === 'dark') {
      return true;
    }

    // Check for manual dark theme classes
    if (document.body.classList.contains('dark-theme') ||
        document.documentElement.classList.contains('dark-theme')) {
      return true;
    }

    // Check for dark background color on body as fallback
    const bodyStyles = window.getComputedStyle(document.body);
    const bodyBg = bodyStyles.backgroundColor;
    if (bodyBg) {
      // Convert rgb to hex for comparison if needed
      const rgb = bodyBg.match(/\d+/g);
      if (rgb) {
        const r = parseInt(rgb[0]);
        const g = parseInt(rgb[1]);
        const b = parseInt(rgb[2]);
        // Consider it dark if background is darker than medium gray
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
      }
    }

    return false;
  }

  /**
   * Get theme-appropriate colors for UI elements
   * @returns {Object} Color scheme object
   */
  getThemeColors() {
    const isDark = this.isDarkTheme();

    if (isDark) {
      return {
        background: '#2d2d2d',
        border: '#404040',
        text: '#e9ecef',
        textSecondary: '#adb5bd',
        containerBg: 'rgba(45, 45, 45, 0.98)',
        accent: '#ffdd3c'
      };
    } else {
      return {
        background: '#f8f9fa',
        border: '#e9ecef',
        text: '#333',
        textSecondary: '#555',
        containerBg: 'rgba(255, 255, 255, 0.98)',
        accent: '#2780e3'
      };
    }
  }

  /**
   * Initialize UI controls
   * @param {Element} container - Main container element
   * @param {Object} graph - KnowledgeGraphExplorer instance
   * @param {Object} data - Graph data with layers and timeline info
   */
  initialize(container, graph, data) {
    this.container = container;
    this.graph = graph;
    this.layers = data.layers || [];
    
    // Extract timeline range from config or data
    if (data.timeline) {
      this.timeline = data.timeline;
    }

    this.createUIStructure();
    this.setupEventListeners();
  }

  /**
   * Create the overall UI structure
   */
  createUIStructure() {
    // Don't restructure DOM - just add overlay controls to existing container
    this.container.style.position = 'relative';
    this.container.style.fontFamily = 'system-ui, -apple-system, sans-serif';

    // Create control panels as overlays
    if (this.config.showLayerControls && this.layers.length > 0) {
      this.createLayerControls();
    }

    // Add audience controls (bottom-right)
    if (this.config.showAudienceControls) {
      this.createAudienceControls();
    }

    // Add refresh button
    this.createRefreshButton();

    if (this.config.showTimeline && this.timeline.start && this.timeline.end) {
      this.createTimelineControls();
    }

    if (this.config.showNodeInfo) {
      this.createInfoPanel();
    }
  }
  
  /**
   * Create layer control buttons
   */
  createLayerControls() {
    this.layerContainer = document.createElement('div');
    this.layerContainer.className = 'kg-layer-controls';
    this.layerContainer.style.cssText = `
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      max-width: 180px;
    `;

    // Title
    const title = document.createElement('div');
    title.textContent = 'Layers';
    title.style.cssText = `
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 12px;
      color: #333;
    `;
    this.layerContainer.appendChild(title);

    // "All Layers" button
    const allButton = this.createLayerButton('all', 'All Layers', '#666');
    allButton.classList.add('active');
    this.layerContainer.appendChild(allButton);

    // Individual layer buttons
    this.layers.forEach(layer => {
      const button = this.createLayerButton(layer.id, layer.name, layer.color);
      this.layerContainer.appendChild(button);
    });

    this.container.appendChild(this.layerContainer);
  }

  /**
   * Create a single layer button
   */
  createLayerButton(layerId, layerName, color) {
    const button = document.createElement('button');
    button.className = 'kg-layer-btn';
    button.setAttribute('data-layer', layerId);
    button.style.cssText = `
      display: block;
      width: 100%;
      margin: 2px 0;
      padding: 6px 8px;
      border: 1px solid ${color};
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      text-align: left;
      transition: all 0.2s ease;
    `;

    // Color indicator
    const colorDot = document.createElement('span');
    colorDot.style.cssText = `
      display: inline-block;
      width: 8px;
      height: 8px;
      background: ${color};
      border-radius: 50%;
      margin-right: 6px;
    `;
    
    button.appendChild(colorDot);
    button.appendChild(document.createTextNode(layerName));

    // Hover and active states
    button.addEventListener('mouseenter', () => {
      if (!button.classList.contains('active')) {
        button.style.background = color + '20';
      }
    });

    button.addEventListener('mouseleave', () => {
      if (!button.classList.contains('active')) {
        button.style.background = 'white';
      }
    });

    button.addEventListener('click', () => {
      this.setActiveLayer(layerId);
    });

    return button;
  }

  /**
   * Create audience filter controls (bottom-right)
   */
  createAudienceControls() {
    this.audienceContainer = document.createElement('div');
    this.audienceContainer.className = 'kg-audience-controls';
    this.audienceContainer.style.cssText = `
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      max-width: 180px;
    `;

    // Title
    const title = document.createElement('div');
    title.textContent = 'View For';
    title.style.cssText = `
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 12px;
      color: #333;
    `;
    this.audienceContainer.appendChild(title);

    // Audience filter buttons
    const audiences = [
      { id: 'general', name: 'General Audience', color: '#2780e3' },
      { id: 'technical', name: 'Technical', color: '#3fb618' },
      { id: 'current_focus', name: 'Current Focus', color: '#ff6b35' }
    ];

    audiences.forEach(audience => {
      const button = this.createAudienceButton(audience.id, audience.name, audience.color);
      if (audience.id === 'current_focus') {
        button.classList.add('active');
      }
      this.audienceContainer.appendChild(button);
    });

    this.container.appendChild(this.audienceContainer);
  }

  /**
   * Create a single audience filter button
   */
  createAudienceButton(audienceId, audienceName, color) {
    const button = document.createElement('button');
    button.className = 'kg-audience-btn';
    button.setAttribute('data-audience', audienceId);
    button.style.cssText = `
      display: block;
      width: 100%;
      margin: 2px 0;
      padding: 6px 8px;
      border: 1px solid ${color};
      background: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      text-align: center;
      transition: all 0.2s ease;
    `;
    button.textContent = audienceName;

    // Hover and active states
    button.addEventListener('mouseenter', () => {
      if (!button.classList.contains('active')) {
        button.style.background = color + '20';
      }
    });

    button.addEventListener('mouseleave', () => {
      if (!button.classList.contains('active')) {
        button.style.background = 'white';
      }
    });

    button.addEventListener('click', () => {
      this.setActiveAudience(audienceId);
    });

    return button;
  }

  /**
   * Create refresh button for resetting node positions
   */
  createRefreshButton() {
    this.refreshButton = document.createElement('button');
    this.refreshButton.className = 'kg-refresh-btn';
    this.refreshButton.innerHTML = '🔄'; // Refresh icon
    this.refreshButton.title = 'Reset node positions';
    this.refreshButton.style.cssText = `
      position: absolute;
      top: 10px;
      left: ${this.layerContainer ? '200px' : '10px'}; /* Adjust based on layer controls */
      width: 36px;
      height: 36px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      transition: all 0.2s ease;
    `;

    // Hover effects
    this.refreshButton.addEventListener('mouseenter', () => {
      this.refreshButton.style.background = '#f0f0f0';
      this.refreshButton.style.transform = 'scale(1.05)';
    });

    this.refreshButton.addEventListener('mouseleave', () => {
      this.refreshButton.style.background = 'rgba(255, 255, 255, 0.95)';
      this.refreshButton.style.transform = 'scale(1)';
    });

    // Click handler
    this.refreshButton.addEventListener('click', () => {
      this.refreshNodePositions();
    });

    this.container.appendChild(this.refreshButton);
  }

  /**
   * Refresh/reset node positions
   */
  refreshNodePositions() {
    if (!this.graph) return;

    // Add visual feedback
    this.refreshButton.style.transform = 'rotate(360deg)';
    this.refreshButton.style.transition = 'transform 0.5s ease';

    // Reset the transform after animation
    setTimeout(() => {
      this.refreshButton.style.transform = 'scale(1)';
      this.refreshButton.style.transition = 'all 0.2s ease';
    }, 500);

    // Restart the simulation with higher energy
    if (this.graph.components && this.graph.components.forceSimulation) {
      // Clear any fixed positions
      this.graph.nodes.forEach(node => {
        node.fx = null;
        node.fy = null;
      });

      // Restart with high energy
      this.graph.components.forceSimulation.restart(1.0);
    }

    this.emit('refresh', { timestamp: Date.now() });
  }

  /**
   * Create timeline controls (compact version)
   */
  createTimelineControls() {
    this.timelineContainer = document.createElement('div');
    this.timelineContainer.className = 'kg-timeline-controls';
    this.timelineContainer.style.cssText = `
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 8px 15px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      min-width: 250px;
    `;

    // Title and current year display
    const header = document.createElement('div');
    header.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      font-size: 11px;
      color: #333;
    `;

    const title = document.createElement('span');
    title.textContent = 'Timeline';
    title.style.fontWeight = 'bold';

    this.currentYearDisplay = document.createElement('span');
    this.currentYearDisplay.textContent = 'All Years';
    this.currentYearDisplay.style.color = '#666';

    header.appendChild(title);
    header.appendChild(this.currentYearDisplay);
    this.timelineContainer.appendChild(header);

    // Timeline slider
    this.timelineSlider = document.createElement('input');
    this.timelineSlider.type = 'range';
    this.timelineSlider.min = this.timeline.start;
    this.timelineSlider.max = this.timeline.end;
    this.timelineSlider.value = this.timeline.end;
    this.timelineSlider.style.cssText = `
      width: 100%;
      margin: 4px 0;
      height: 4px;
    `;

    // Timeline labels
    const labels = document.createElement('div');
    labels.style.cssText = `
      display: flex;
      justify-content: space-between;
      font-size: 9px;
      color: #666;
      margin-top: 2px;
    `;

    const startLabel = document.createElement('span');
    startLabel.textContent = this.timeline.start;
    const endLabel = document.createElement('span');
    endLabel.textContent = this.timeline.end;

    labels.appendChild(startLabel);
    labels.appendChild(endLabel);

    // "All Years" toggle button
    const allYearsBtn = document.createElement('button');
    allYearsBtn.textContent = 'Show All Years';
    allYearsBtn.style.cssText = `
      margin-top: 6px;
      padding: 3px 6px;
      border: 1px solid #ddd;
      background: white;
      border-radius: 3px;
      cursor: pointer;
      font-size: 10px;
      width: 100%;
    `;

    this.timelineContainer.appendChild(this.timelineSlider);
    this.timelineContainer.appendChild(labels);
    this.timelineContainer.appendChild(allYearsBtn);

    // Event listeners
    this.timelineSlider.addEventListener('input', (e) => {
      this.setTimelinePosition(parseInt(e.target.value));
    });

    allYearsBtn.addEventListener('click', () => {
      this.showAllYears();
    });

    this.container.appendChild(this.timelineContainer);
  }

  /**
   * Create info panel for displaying node/link details (top-right)
   */
  createInfoPanel() {
    this.infoPanel = document.createElement('div');
    this.infoPanel.className = 'kg-info-panel';
    this.infoPanel.style.cssText = `
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 15px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
      max-width: 280px;
      height: calc(100% - 200px);
      overflow-y: auto;
      overflow-x: hidden;
      display: none;
      pointer-events: auto;
    `;

    this.container.appendChild(this.infoPanel);
  }

  /**
   * Setup event listeners with the graph
   */
  setupEventListeners() {
    if (!this.graph) return;

    // Listen for node clicks
    this.graph.on('nodeClick', (data) => {
      this.showNodeInfo(data.node);
    });

    // Listen for background clicks to hide info
    this.graph.on('backgroundClick', () => {
      this.hideInfo();
    });

    // Listen for layer changes
    this.graph.on('layerChange', (data) => {
      this.updateLayerButtons(data.layer);
    });
  }

  /**
   * Set active layer
   */
  setActiveLayer(layerId) {
    this.activeLayer = layerId === 'all' ? null : layerId;
    
    // Update graph
    if (this.graph) {
      if (layerId === 'all') {
        this.graph.showAllLayers();
      } else {
        this.graph.setActiveLayer(layerId);
      }
    }

    // Update button states
    this.updateLayerButtons(this.activeLayer);
    
    this.emit('layerChange', { layer: this.activeLayer });
  }

  /**
   * Set active audience filter
   */
  setActiveAudience(audienceId) {
    this.activeAudience = audienceId;
    
    // Update graph visual effects
    if (this.graph) {
      this.graph.setAudienceFilter(audienceId);
    }

    // Update button states
    this.updateAudienceButtons(audienceId);
    
    this.emit('audienceChange', { audience: audienceId });
  }

  /**
   * Update layer button visual states
   */
  updateLayerButtons(activeLayerId) {
    if (!this.layerContainer) return;

    const buttons = this.layerContainer.querySelectorAll('.kg-layer-btn');
    buttons.forEach(btn => {
      const layerId = btn.getAttribute('data-layer');
      const isActive = (activeLayerId === null && layerId === 'all') || 
                      (activeLayerId === layerId);
      
      btn.classList.toggle('active', isActive);
      
      if (isActive) {
        const color = layerId === 'all' ? '#666' : 
                     this.layers.find(l => l.id === layerId)?.color || '#666';
        btn.style.background = color + '30';
        btn.style.fontWeight = 'bold';
      } else {
        btn.style.background = 'white';
        btn.style.fontWeight = 'normal';
      }
    });
  }

  /**
   * Update audience button visual states
   */
  updateAudienceButtons(activeAudienceId) {
    if (!this.audienceContainer) return;

    const buttons = this.audienceContainer.querySelectorAll('.kg-audience-btn');
    buttons.forEach(btn => {
      const audienceId = btn.getAttribute('data-audience');
      const isActive = audienceId === activeAudienceId;
      
      btn.classList.toggle('active', isActive);
      
      if (isActive) {
        const audiences = {
          general: '#2780e3',
          technical: '#3fb618',
          current_focus: '#ff6b35'
        };
        const color = audiences[audienceId] || '#666';
        btn.style.background = color + '30';
        btn.style.fontWeight = 'bold';
      } else {
        btn.style.background = 'white';
        btn.style.fontWeight = 'normal';
      }
    });
  }

  /**
   * Set timeline position
   */
  setTimelinePosition(year) {
    this.currentTimelinePosition = year;
    this.currentYearDisplay.textContent = year.toString();
    
    // TODO: Filter nodes/links by timeline position
    // This would require integration with the graph's data filtering
    
    this.emit('timelineChange', { year: year });
  }

  /**
   * Show all years (reset timeline)
   */
  showAllYears() {
    this.currentTimelinePosition = null;
    this.currentYearDisplay.textContent = 'All Years';
    this.timelineSlider.value = this.timeline.end;
    
    // TODO: Reset timeline filtering
    
    this.emit('timelineChange', { year: null });
  }

  /**
   * Show node information in the info panel
   */
  showNodeInfo(node) {
    if (!this.infoPanel) return;

    this.selectedNode = node;

    // Get theme-appropriate colors
    const colors = this.getThemeColors();

    const title = document.createElement('div');
    title.style.cssText = `
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 8px;
      color: ${colors.text};
    `;
    title.textContent = node.label;

    const description = document.createElement('div');
    description.style.cssText = `
      font-size: 12px;
      line-height: 1.4;
      color: ${colors.textSecondary};
      margin: 0;
    `;
    description.textContent = node.description || 'No description available.';

    // Additional details
    const details = document.createElement('div');
    details.style.cssText = `
      font-size: 11px;
      color: ${colors.textSecondary};
      border-top: 1px solid ${colors.border};
      padding-top: 8px;
      margin-bottom: 10px;
    `;

    if (node.timespan) {
      const timespan = document.createElement('div');
      const endText = node.timespan.end ? node.timespan.end : 'current';
      timespan.textContent = `${node.timespan.start} - ${endText}`;
      details.appendChild(timespan);
    }

    // Layer tag (colored box instead of text)
    if (node.layer) {
      const layerInfo = this.layers.find(l => l.id === node.layer);
      const layerTag = document.createElement('div');
      layerTag.style.cssText = `
        display: inline-block;
        background: ${layerInfo?.color || '#666'};
        color: ${this.isDarkTheme() ? 'white' : 'black'} !important;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 10px;
        font-weight: bold;
        margin-top: 4px;
      `;
      layerTag.textContent = layerInfo?.name || node.layer;
      details.appendChild(layerTag);
    }

    // Related nodes section
    const relatedSection = this.createRelatedNodesSection(node);

    // Close button
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '×';
    closeBtn.style.cssText = `
      position: absolute;
      top: 5px;
      right: 5px;
      border: none;
      background: none;
      font-size: 16px;
      cursor: pointer;
      color: ${colors.textSecondary};
    `;
    closeBtn.addEventListener('click', () => this.hideInfo());

    // Create main content area with guaranteed space for description
    const mainContent = document.createElement('div');
    mainContent.style.cssText = `
      margin-bottom: 10px;
    `;

    // Add title and details to main content
    mainContent.appendChild(title);
    mainContent.appendChild(details);

    // Create description area with minimum height guarantee
    const descriptionContainer = document.createElement('div');
    descriptionContainer.style.cssText = `
      min-height: 80px;
      max-height: 120px;
      overflow-y: auto;
      margin-bottom: 12px;
      padding: 8px;
      background: ${colors.background};
      border-radius: 4px;
      border: 1px solid ${colors.border};
    `;
    descriptionContainer.appendChild(description);

    // Create scrollable related section
    const relatedContainer = document.createElement('div');
    relatedContainer.style.cssText = `
      border-top: 2px solid ${colors.border};
      padding-top: 8px;
      max-height: 180px;
      overflow-y: auto;
      background: ${colors.containerBg};
    `;
    relatedContainer.appendChild(relatedSection);

    // Clear and populate
    this.infoPanel.innerHTML = '';
    this.infoPanel.appendChild(closeBtn);
    this.infoPanel.appendChild(mainContent);
    this.infoPanel.appendChild(descriptionContainer);
    this.infoPanel.appendChild(relatedContainer);

    this.infoPanel.style.display = 'block';
  }

  /**
   * Create the "Related To" section showing connected nodes
   */
  createRelatedNodesSection(node) {
    // Find all links connected to this node (both as parent and child)
    const connectedLinks = this.graph.links.filter(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      return sourceId === node.id || targetId === node.id;
    });

    // Also find direct parent/child relationships
    const children = this.graph.nodes.filter(n => n.parent_node === node.id);
    const parent = node.parent_node ? this.graph.nodes.find(n => n.id === node.parent_node) : null;

    if (connectedLinks.length === 0 && children.length === 0 && !parent) {
      return document.createElement('div'); // Return empty div if no connections
    }

    // Get theme-appropriate colors
    const colors = this.getThemeColors();

    const section = document.createElement('div');
    section.style.cssText = `
      border-top: 1px solid ${colors.border};
      padding-top: 8px;
      margin-top: 8px;
    `;

    const title = document.createElement('div');
    title.textContent = 'Related To';
    title.style.cssText = `
      font-weight: bold;
      font-size: 11px;
      color: ${colors.text};
      margin-bottom: 6px;
    `;
    section.appendChild(title);

    // Add parent node
    if (parent) {
      this.addRelatedNodeLink(section, parent, 'parent');
    }

    // Add child nodes
    children.forEach(child => {
      this.addRelatedNodeLink(section, child, 'child');
    });

    // Add other connected nodes from links
    connectedLinks.forEach(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      
      const connectedNodeId = sourceId === node.id ? targetId : sourceId;
      const connectedNode = this.graph.nodes.find(n => n.id === connectedNodeId);
      
      if (connectedNode && connectedNode !== parent && !children.includes(connectedNode)) {
        this.addRelatedNodeLink(section, connectedNode, 'related');
      }
    });

    return section;
  }

  /**
   * Add a related node link to the related nodes section
   * @param {HTMLElement} container - The container to add the link to
   * @param {Object} node - The related node
   * @param {string} relationship - The relationship type ('parent', 'child', 'related')
   */
  addRelatedNodeLink(container, node, relationship) {
    // Get theme-appropriate colors
    const colors = this.getThemeColors();

    const link = document.createElement('div');
    link.style.cssText = `
      display: flex;
      align-items: center;
      margin: 2px 0;
      padding: 2px 4px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
      background: ${colors.background};
      border: 1px solid ${colors.border};
      transition: background-color 0.2s;
    `;

    // Get layer info for color
    const layerInfo = this.layers.find(l => l.id === node.layer);
    const layerColor = layerInfo?.color || '#666';

    // Create color indicator
    const colorDot = document.createElement('div');
    colorDot.style.cssText = `
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: ${layerColor};
      margin-right: 6px;
      flex-shrink: 0;
    `;

    // Create text content
    const text = document.createElement('span');
    text.style.cssText = `
      color: ${colors.text};
      font-size: 10px;
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
    `;

    // Add relationship prefix
    let prefix = '';
    switch (relationship) {
      case 'parent': prefix = '↑ '; break;
      case 'child': prefix = '↓ '; break;
      default: prefix = '→ '; break;
    }

    text.textContent = prefix + node.label;

    link.appendChild(colorDot);
    link.appendChild(text);

    // Get hover colors - slightly different from base colors
    const isDark = this.isDarkTheme();
    const hoverBg = isDark ? '#3a3a3a' : '#e9ecef';
    const originalBg = colors.background;

    // Add hover effects
    link.addEventListener('mouseenter', () => {
      link.style.backgroundColor = hoverBg;
    });

    link.addEventListener('mouseleave', () => {
      link.style.backgroundColor = originalBg;
    });

    // Add click handler to focus on related node
    link.addEventListener('click', (e) => {
      e.stopPropagation();
      this.panToNode(node);
    });

    container.appendChild(link);
  }

  /**
   * Pan the graph to focus on a specific node
   */
  panToNode(node) {
    if (!this.graph || !node.x || !node.y) return;
  
    // Use the graph's focusOnNode method if available
    if (typeof this.graph.focusOnNode === 'function') {
      this.graph.focusOnNode(node.id);
    }
  }

  /**
   * Hide the info panel
   */
  hideInfo() {
    if (this.infoPanel) {
      this.infoPanel.style.display = 'none';
    }
    this.selectedNode = null;
  }

  /**
   * Get current UI state
   */
  getState() {
    return {
      activeLayer: this.activeLayer,
      activeAudience: this.activeAudience,
      currentTimelinePosition: this.currentTimelinePosition,
      selectedNode: this.selectedNode ? this.selectedNode.id : null,
      layerCount: this.layers.length
    };
  }

  /**
   * Add event listener
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }

  /**
   * Emit event
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in UI event handler for ${eventType}:`, error);
        }
      });
    }
  }

  /**
   * Cleanup and destroy UI controls
   */
  destroy() {
    if (this.uiContainer && this.uiContainer.parentNode) {
      this.uiContainer.parentNode.removeChild(this.uiContainer);
    }
    this.eventHandlers = {};
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = UIControlsManager;
} else if (typeof window !== 'undefined') {
  window.UIControlsManager = UIControlsManager;
}

// core/KnowledgeGraphExplorer.js
/**
 * Knowledge Graph Explorer - Main Orchestrating Class
 * Coordinates all modular components to create an interactive knowledge graph
 */
class KnowledgeGraphExplorer {
  constructor(container, data, config = {}) {
    this.container = typeof container === 'string' 
      ? document.querySelector(container) 
      : container;
    
    if (!this.container) {
      throw new Error('Container element not found');
    }

    // Validate data before proceeding
    this.validateAndProcessData(data);

    // Configuration with sensible defaults
    this.config = this.mergeConfigurations(config);
    
    // Initialize modular components
    this.components = {
      dataValidator: null,
      coordinateTransform: null,
      forceSimulation: null,
      interactionManager: null,
      visualEffectsManager: null,
      miniMapManager: null,
      labelLayoutManager: null
    };

    // State management
    this.state = {
      currentLayer: null,
      currentAudience: 'current_focus',
      isTimelineActive: false,
      currentTimelinePosition: null,
      selectedNode: null,
      selectedNodeRelated: new Set(),
      selectedNodeDistances: new Map(),
      isInitialized: false,
      isPanning: false
    };

    // Event handlers for external API
    this.eventHandlers = {};

    // Initialize the graph
    this.init();
  }

  /**
   * Generate links from parent_node/parent_nodes relationships
   * @returns {Array} - Array of link objects
   */
  generateLinksFromParents() {
    const links = [];

    this.nodes.forEach(node => {
      // Support both parent_node (single) and parent_nodes (array) for backward compatibility
      let parents = [];

      // Check for single parent (backward compatibility)
      if (node.parent_node && node.parent_node !== null) {
        // parent_node can be either a string or an array
        parents = Array.isArray(node.parent_node) ? node.parent_node : [node.parent_node];
      }
      // Check for multiple parents (new format)
      else if (node.parent_nodes && node.parent_nodes !== null) {
        if (Array.isArray(node.parent_nodes)) {
          parents = node.parent_nodes;
        } else {
          // If parent_nodes is not an array, treat it as a single parent
          parents = [node.parent_nodes];
        }
      }

      // Create links for all parents
      parents.forEach(parentId => {
        // Find the parent node
        const parentNode = this.nodes.find(n => n.id === parentId);
        if (parentNode) {
          links.push({
            source: parentId,
            target: node.id,
            strength: 0.5, // Default strength
            id: `${parentId}-${node.id}`
          });
        }
      });
    });

    return links;
  }

  /**
   * Validate and process input data
   * @param {Object} data - Input data with nodes
   */
  validateAndProcessData(data) {
    // Use DataValidator if available, otherwise basic validation
    if (typeof DataValidator !== 'undefined') {
      // Generate links for validation
      const tempNodes = data.nodes || [];
      const tempLinks = [];
      
      tempNodes.forEach(node => {
        // Support both parent_node and parent_nodes
        let parents = [];
        if (node.parent_node && node.parent_node !== null) {
          // parent_node can be either a string or an array
          parents = Array.isArray(node.parent_node) ? node.parent_node : [node.parent_node];
        } else if (node.parent_nodes && node.parent_nodes !== null) {
          parents = Array.isArray(node.parent_nodes) ? node.parent_nodes : [node.parent_nodes];
        }

        parents.forEach(parentId => {
          tempLinks.push({
            source: parentId,
            target: node.id
          });
        });
      });

      const dataForValidation = {
        nodes: [...tempNodes],
        links: tempLinks
      };
      
      const validation = DataValidator.validate(dataForValidation);
      if (!validation.isValid) {
        console.warn('Data validation warnings:', validation.errors);
        if (validation.errors.length > 0) {
          throw new Error(`Data validation failed: ${validation.errors[0]}`);
        }
      }
    } else {
      // Basic validation fallback
      if (!data || !data.nodes) {
        throw new Error('Data must contain nodes array');
      }
    }

    this.originalData = data;
    this.allNodes = [...data.nodes];
    this.nodes = [...data.nodes];
    
    // Generate links from parent relationships
    this.links = this.generateLinksFromParents();
    this.allLinks = [...this.links];
  }

  /**
   * Merge user configuration with defaults
   * @param {Object} userConfig - User-provided configuration
   * @returns {Object} - Merged configuration
   */
  mergeConfigurations(userConfig) {
    const defaultConfig = {
      // Container dimensions
      width: 900,
      height: 600,
      
      // Visual theme
      theme: {
        primaryColor: '#2780e3',
        secondaryColor: '#3fb618',
        accentColor: '#ffdd3c',
        dangerColor: '#ff0039',
        mutedColor: '#868e96',
        backgroundColor: '#ffffff',
        surfaceColor: '#f8f9fa',
        textPrimary: '#212529',
        textSecondary: '#495057',
        textMuted: '#868e96',
        borderColor: '#dee2e6',
        fontFamily: 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
        fontSizeBase: 14,
        fontSizeSmall: 12,
        fontSizeLarge: 16,
        borderRadius: 6,
        shadowColor: 'rgba(0, 0, 0, 0.15)'
      },

      // Node colors - completely configurable, no hardcoded categories
      nodeColors: {},
      
      // Layer configuration - user-defined
      layers: [],
      
      // Timeline configuration
      timeline: {
        enabled: true,
        start: null, // Auto-calculated if not provided
        end: null    // Auto-calculated if not provided
      },
      
      // Feature toggles
      features: {
        showMiniMap: true,
        showTimeline: true,
        showLegend: true,
        enableHover: true,
        enableDrag: true,
        enableLayerMode: true,
        clickToNavigate: true,
        smartLabelPositioning: true
      },

      // Label positioning configuration
      labelLayout: {
        enabled: true,
        preferredPositions: ['bottom', 'right', 'top', 'left'],
        maxDistance: 50,
        minDistance: 15,
        padding: 8,
        collisionIterations: 3,
        positioningIterations: 2,
        transitionDuration: 200
      },
      
      // Interaction settings
      interaction: {
        hoverRadius: 50,
        maxHoverScale: 1.3,
        clickRadius: 20,
        dragThreshold: 5
      },
      
      // Force simulation settings - must be provided by Python config from YAML
      simulation: {},
      
      // Visual effects settings
      effects: {
        hoverTransitionDuration: 100,
        layerTransitionDuration: 400,
        distanceScaling: {
          distance1: 0.9,
          distance2: 0.7,
          distance3: 0.5,
          distanceOther: 0.3
        }
      },
      
      // MiniMap settings
      miniMap: {
        width: 150,
        height: 120,
        position: 'bottom-left',
        padding: 10
      }
    };

    return this.deepMerge(defaultConfig, userConfig);
  }

  /**
   * Deep merge two objects
   * @param {Object} target - Target object
   * @param {Object} source - Source object
   * @returns {Object} - Merged object
   */
  deepMerge(target, source) {
    const result = { ...target };
    
    for (const key in source) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        result[key] = this.deepMerge(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
    
    return result;
  }

  /**
   * Initialize all components and setup the graph
   */
  init() {
    this.setupContainer();
    this.setupSVG();
    this.initializeComponents();
    this.setupEventBindings();
    this.render();
    this.startSimulation();

    this.state.isInitialized = true;

    // Apply initial audience filter after initialization to show current focus view by default
    this.setAudienceFilter('current_focus');

    this.emit('initialized', { config: this.config, state: this.state });
  }

  /**
   * Setup the container element
   */
  setupContainer() {
    this.container.innerHTML = '';
    this.container.style.position = 'relative';
    this.container.style.width = this.config.width + 'px';
    this.container.style.height = this.config.height + 'px';
    this.container.style.backgroundColor = this.config.theme.backgroundColor;
    this.container.style.overflow = 'hidden';
    this.container.style.borderRadius = this.config.theme.borderRadius + 'px';
    this.container.style.fontFamily = this.config.theme.fontFamily;
  }

  /**
   * Setup SVG and its groups
   */
  setupSVG() {
    this.svg = d3.select(this.container)
      .append('svg')
      .attr('width', this.config.width)
      .attr('height', this.config.height);

    this.mainGroup = this.svg.append('g').attr('class', 'main-group');
    this.linkGroup = this.mainGroup.append('g').attr('class', 'links');
    this.nodeGroup = this.mainGroup.append('g').attr('class', 'nodes');
    this.labelGroup = this.mainGroup.append('g').attr('class', 'labels');

    // Setup zoom behavior
    this.zoom = d3.zoom()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        this.handleZoom(event);
      });

    this.svg.call(this.zoom);
  }

  /**
   * Initialize all modular components
   */
  initializeComponents() {
    // Initialize coordinate transform
    this.components.coordinateTransform = new CoordinateTransform();
    this.components.coordinateTransform.updateViewport(this.config.width, this.config.height);

    // Initialize force simulation
    this.components.forceSimulation = new ForceSimulation(this.config.simulation);
    this.components.forceSimulation.updateDimensions(this.config.width, this.config.height);
    this.components.forceSimulation.onTickCallback(() => this.updatePositions());

    // Initialize visual effects manager
    this.components.visualEffectsManager = new VisualEffectsManager({
      ...this.config.effects,
      theme: this.config.theme
    });

    // Initialize interaction manager
    this.components.interactionManager = new InteractionManager({
      ...this.config.interaction,
      hoverEnabled: this.config.features.enableHover,
      dragEnabled: this.config.features.enableDrag
    });

    // Initialize minimap if enabled
    if (this.config.features.showMiniMap) {
      this.components.miniMapManager = new MiniMapManager({
        ...this.config.miniMap,
        backgroundColor: this.config.theme.surfaceColor + 'E6',
        borderColor: this.config.theme.primaryColor
      });
    }

    // Initialize label layout manager if smart positioning is enabled
    if (this.config.features.smartLabelPositioning) {
      this.components.labelLayoutManager = new LabelLayoutManager({
        ...this.config.labelLayout
      });
    }

    // Initialize UI controls manager
    this.components.uiControlsManager = new UIControlsManager({
      showTimeline: this.config.features.showTimeline,
      showLayerControls: this.config.features.showLayerControls,
      showAudienceControls: this.config.features.showAudienceControls,
      showNodeInfo: this.config.features.showNodeInfo,
      showMiniMap: this.config.features.showMiniMap
    });
  }

  /**
   * Setup event bindings between components
   */
  setupEventBindings() {
    // Interaction events
    if (this.components.interactionManager) {
      const elements = {
        svg: this.svg,
        nodes: this.nodeGroup.selectAll('.node'),
        links: this.linkGroup.selectAll('.link'),
        labels: this.labelGroup.selectAll('.label')
      };

      this.components.interactionManager.initialize(elements, this.components.coordinateTransform);
      this.components.interactionManager.updateData(this.nodes, this.links);

      // Bind interaction events
      this.components.interactionManager.on('nodeClick', (data) => {
        this.setSelectedNode(data.node);
        this.emit('nodeClick', data);
      });

      this.components.interactionManager.on('linkClick', (data) => {
        this.emit('linkClick', data);
      });

      this.components.interactionManager.on('backgroundClick', (data) => {
        this.setSelectedNode(null);
        this.emit('backgroundClick', data);
      });

      this.components.interactionManager.on('dockHover', (data) => {
        this.applyDockHoverEffects(data.mousePosition);
      });

      this.components.interactionManager.on('dockHoverReset', () => {
        this.resetDockHoverEffects();
      });

      this.components.interactionManager.on('nodeHover', (data) => {
        if (this.config.features.enableHover && this.components.visualEffectsManager) {
          this.components.visualEffectsManager.applyContinuousHoverEffects(
            data.node, data.distance, data.mousePosition
          );
        }
      });

      this.components.interactionManager.on('hoverReset', () => {
        if (this.components.visualEffectsManager) {
          this.components.visualEffectsManager.resetHoverEffects();
        }
      });

      this.components.interactionManager.on('dragStart', (data) => {
        this.emit('dragStart', data);
      });

      this.components.interactionManager.on('dragEnd', (data) => {
        this.emit('dragEnd', data);
      });
    }

    // Visual effects initialization
    if (this.components.visualEffectsManager) {
      const elements = {
        nodes: this.nodeGroup.selectAll('.node'),
        links: this.linkGroup.selectAll('.link'),
        labels: this.labelGroup.selectAll('.label')
      };
      this.components.visualEffectsManager.initialize(elements);
      this.components.visualEffectsManager.updateData(this.nodes, this.links);
    }

    // MiniMap initialization and events
    if (this.components.miniMapManager) {
      this.components.miniMapManager.initialize(this.container, this.components.coordinateTransform);
      this.components.miniMapManager.updateData(this.nodes, this.links);

      this.components.miniMapManager.on('navigate', (data) => {
        this.navigateToPosition(data.graphPosition);
      });
    }

    // UI Controls Manager initialization and events
    if (this.components.uiControlsManager) {
      const graphData = {
        layers: this.originalData.layers || [],
        timeline: this.originalData.timeline || {}
      };
      this.components.uiControlsManager.initialize(this.container, this, graphData);
    }

    // Label Layout Manager initialization
    if (this.components.labelLayoutManager) {
      // Will be initialized after rendering when label elements are available
    }
  }

  /**
   * Update text sizes based on zoom level with floor and ceiling constraints
   * @param {number} zoomScale - Current zoom scale factor
   */
  updateTextSizesForZoom(zoomScale) {
    if (!this.labelGroup) return;

    // Define base text size and constraints for screen appearance
    const baseTextSize = 14;    // Base font size in pixels at 1.0 zoom
    const minScreenSize = 10;   // Minimum visual size on screen (pixels)
    const maxScreenSize = 24;   // Maximum visual size on screen (pixels)

    // Calculate text size to maintain consistent screen appearance
    // Scale inversely with zoom so text appears constant size on screen
    const screenTargetSize = baseTextSize / zoomScale;

    // Apply floor and ceiling constraints
    const constrainedSize = Math.max(minScreenSize / zoomScale,
                                   Math.min(maxScreenSize / zoomScale, screenTargetSize));

    // Apply the text size to all labels
    this.labelGroup.selectAll('.label')
      .style('font-size', `${constrainedSize}px`);

    // Update label layout manager with new zoom scale
    if (this.components.labelLayoutManager) {
      this.components.labelLayoutManager.updateZoomScale(zoomScale);
    }
  }

  /**
   * Handle zoom events
   * @param {Object} event - D3 zoom event
   */
  handleZoom(event) {
    this.components.coordinateTransform.updateTransform(event.transform);
    this.mainGroup.attr('transform', event.transform);

    // Only update text sizes if we're not in a panning transition (prevents shaking)
    if (!this.state.isPanning) {
      this.updateTextSizesForZoom(event.transform.k);
    }

    if (this.components.miniMapManager) {
      this.components.miniMapManager.updateViewportIndicator();
    }

    this.emit('zoom', { transform: event.transform });
  }

  /**
   * Render all visual elements
   */
  render() {
    this.renderLinks();
    this.renderNodes();
    this.renderLabels();
    
    // Update component references
    this.updateComponentElements();
  }

  /**
   * Update component element references after rendering
   */
  updateComponentElements() {
    const elements = {
      nodes: this.nodeGroup.selectAll('.node'),
      links: this.linkGroup.selectAll('.link'),
      labels: this.labelGroup.selectAll('.label')
    };

    if (this.components.interactionManager) {
      this.components.interactionManager.nodeElements = elements.nodes;
      this.components.interactionManager.linkElements = elements.links;
      this.components.interactionManager.labelElements = elements.labels;
      this.components.interactionManager.setupNodeInteractions();
      this.components.interactionManager.setupLinkInteractions();
    }

    if (this.components.visualEffectsManager) {
      this.components.visualEffectsManager.nodeElements = elements.nodes;
      this.components.visualEffectsManager.linkElements = elements.links;
      this.components.visualEffectsManager.labelElements = elements.labels;
    }

    if (this.components.labelLayoutManager) {
      this.components.labelLayoutManager.initialize(this.nodes, elements.labels);
    }
  }

  /**
   * Render links
   */
  renderLinks() {
    const linkSelection = this.linkGroup
      .selectAll('.link')
      .data(this.links, d => d.id || `${d.source}-${d.target}`);

    linkSelection.exit().remove();

    linkSelection.enter()
      .append('line')
      .attr('class', 'link')
      .attr('stroke', this.config.theme.mutedColor)
      .attr('stroke-width', d => Math.sqrt(d.strength || 0.5) * 2)
      .style('opacity', 0) // Start with links hidden
      .style('pointer-events', 'none');
  }

  /**
   * Render nodes with experience-based styling
   */
  renderNodes() {
    const nodeSelection = this.nodeGroup
      .selectAll('.node')
      .data(this.nodes, d => d.id);
  
    nodeSelection.exit().remove();
  
    nodeSelection.enter()
      .append('circle')
      .attr('class', 'node')
      .attr('r', d => d.size || 10)
      .attr('fill', d => this.getNodeColor(d))
      .attr('stroke', d => this.getNodeStrokeColor(d))
      .attr('stroke-width', d => this.getNodeStrokeWidth(d))
      .style('cursor', 'pointer');
  }
  
  /**
   * Get node color based on configuration, with support for experience levels
   * @param {Object} node - Node object
   * @returns {string} - Color value
   */
  getNodeColor(node) {
    let baseColor;

    // Get base color from layer (primary), then type, then default
    if (node.layer && this.config.nodeColors[node.layer]) {
      baseColor = this.config.nodeColors[node.layer];
    } else if (node.type && this.config.nodeColors[node.type]) {
      baseColor = this.config.nodeColors[node.type];
    } else if (node.color) {
      baseColor = node.color;
    } else {
      baseColor = this.config.theme.primaryColor;
    }

    // Handle experience level - default to "experienced" if not specified
    const experienceLevel = node.experienceLevel || 'experienced';
    return this.adjustColorForExperience(baseColor, experienceLevel);
  }
  
  /**
   * Adjust color based on experience level
   * @param {string} baseColor - Base color (hex format)
   * @param {string} experienceLevel - 'experienced' or 'interested'
   * @returns {string} - Adjusted color
   */
  adjustColorForExperience(baseColor, experienceLevel) {
    if (experienceLevel === 'interested') {
      // Make color lighter/less saturated for interest-only
      return this.lightenColor(baseColor, 0.4); // 40% lighter
    }
    
    // For 'experienced' or any other value, return full saturation
    return baseColor;
  }
  
  /**
   * Lighten a hex color by a given factor
   * @param {string} color - Hex color (e.g., "#2780e3")
   * @param {number} factor - Lightening factor (0-1, where 1 is white)
   * @returns {string} - Lightened hex color
   */
  lightenColor(color, factor) {
    // Remove # if present
    const hex = color.replace('#', '');
    
    // Parse RGB values
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    // Lighten each component
    const newR = Math.round(r + (255 - r) * factor);
    const newG = Math.round(g + (255 - g) * factor);
    const newB = Math.round(b + (255 - b) * factor);
    
    // Convert back to hex
    const toHex = (n) => {
      const hex = n.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    
    return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
  }

  /**
   * Get stroke color for nodes based on experience level
   * @param {Object} node - Node object
   * @returns {string} - Stroke color
   */
  getNodeStrokeColor(node) {
    // Handle experience level - default to "experienced" if not specified
    const experienceLevel = node.experienceLevel || 'experienced';

    if (experienceLevel === 'interested') {
      // Lighter stroke for interested nodes
      return this.lightenColor(this.config.theme.textPrimary, 0.5);
    }

    // Full stroke for experienced nodes
    return this.config.theme.textPrimary;
  }
  
  /**
   * Get stroke width for nodes based on experience level
   * @param {Object} node - Node object
   * @returns {number} - Stroke width
   */
  getNodeStrokeWidth(node) {
    // Handle experience level - default to "experienced" if not specified
    const experienceLevel = node.experienceLevel || 'experienced';

    if (experienceLevel === 'interested') {
      return 1; // Thinner stroke for interested
    }

    return 2; // Standard stroke for experienced
  }

  /**
   * Render labels
   */
  renderLabels() {
    const labelSelection = this.labelGroup
      .selectAll('.label')
      .data(this.nodes, d => d.id);

    labelSelection.exit().remove();

    labelSelection.enter()
      .append('text')
      .attr('class', 'label')
      .attr('text-anchor', 'middle')
      .attr('dy', '0.35em')
      .attr('font-family', this.config.theme.fontFamily)
      .style('font-size', '12px') // Will be updated by updateTextSizesForZoom
      .attr('fill', this.config.theme.textPrimary)
      .attr('pointer-events', 'none')
      .style('user-select', 'none')
      .style('opacity', 0) // Start invisible
      .text(d => d.label);
  }

  /**
   * Update positions during simulation tick
   */
  updatePositions() {
    this.linkGroup.selectAll('.link')
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);

    this.nodeGroup.selectAll('.node')
      .attr('cx', d => d.x)
      .attr('cy', d => d.y);

    // Update label positions - use smart layout only when a node is selected, otherwise use default positioning
    if (this.components.labelLayoutManager && this.config.features.smartLabelPositioning && this.state.selectedNode) {
      this.components.labelLayoutManager.updateData(this.nodes, this.labelGroup.selectAll('.label'));
    } else {
      // Default label positioning (below nodes)
      this.labelGroup.selectAll('.label')
        .attr('x', d => d.x)
        .attr('y', d => d.y + (d.size || 10) + 18);
    }

    if (this.components.miniMapManager) {
      this.components.miniMapManager.render();
    }
  }

  /**
   * Initialize node positions based on layer grid layout
   */
  initializeLayerBasedPositions() {
    // 3x3 grid layout
    const gridSize = 3;
    const cellWidth = this.config.width / gridSize;
    const cellHeight = this.config.height / gridSize;
    
    // Fill order: (1,2), (2,1), (2,3), (3,2), (2,2), (1,1), (3,3), (1,3), (3,1)
    // Convert to 0-based indexing: (0,1), (1,0), (1,2), (2,1), (1,1), (0,0), (2,2), (0,2), (2,0)
    const fillOrder = [
      [0, 1], [1, 0], [1, 2], [2, 1], [1, 1], [0, 0], [2, 2], [0, 2], [2, 0]
    ];
    
    // Get unique layers
    const uniqueLayers = [...new Set(this.nodes.map(node => node.layer))];
    
    // Assign each layer to a grid position
    const layerToGridPosition = new Map();
    uniqueLayers.forEach((layer, index) => {
      if (index < fillOrder.length) {
        layerToGridPosition.set(layer, fillOrder[index]);
      } else {
        // Fallback for extra layers - use modulo to wrap around
        layerToGridPosition.set(layer, fillOrder[index % fillOrder.length]);
      }
    });
    
    // Position nodes within their assigned grid cells
    this.nodes.forEach(node => {
      const gridPos = layerToGridPosition.get(node.layer);
      if (gridPos) {
        const [gridX, gridY] = gridPos;
        
        // Calculate cell boundaries
        const cellLeft = gridX * cellWidth;
        const cellTop = gridY * cellHeight;
        
        // Add padding within cells to avoid edges
        const padding = Math.min(cellWidth, cellHeight) * 0.1;
        
        // Random position within the cell (with padding)
        node.x = cellLeft + padding + Math.random() * (cellWidth - 2 * padding);
        node.y = cellTop + padding + Math.random() * (cellHeight - 2 * padding);
      } else {
        // Fallback to center if no layer assigned
        node.x = this.config.width / 2 + (Math.random() - 0.5) * 100;
        node.y = this.config.height / 2 + (Math.random() - 0.5) * 100;
      }
    });
  }

  /**
   * Calculate initial zoom to fit all nodes with padding
   */
  setInitialZoom() {
    if (!this.svg || !this.nodes.length) return;

    // Calculate bounding box of all nodes
    const padding = 50; // Padding around the content
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

    this.nodes.forEach(node => {
      if (node.x !== undefined && node.y !== undefined) {
        minX = Math.min(minX, node.x);
        maxX = Math.max(maxX, node.x);
        minY = Math.min(minY, node.y);
        maxY = Math.max(maxY, node.y);
      }
    });

    // If we have valid bounds
    if (isFinite(minX) && isFinite(maxX) && isFinite(minY) && isFinite(maxY)) {
      const contentWidth = maxX - minX;
      const contentHeight = maxY - minY;
      const svgWidth = this.config.width;
      const svgHeight = this.config.height;

      // Calculate scale to fit content with padding
      const scaleX = (svgWidth - 2 * padding) / contentWidth;
      const scaleY = (svgHeight - 2 * padding) / contentHeight;
      const scale = Math.min(scaleX, scaleY, 0.8); // Cap at 0.8 to ensure zoom out

      // Calculate center of content
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;

      // Calculate translation to center the content
      const translateX = svgWidth / 2 - centerX * scale;
      const translateY = svgHeight / 2 - centerY * scale;

      // Apply the transform
      const initialTransform = d3.zoomIdentity
        .translate(translateX, translateY)
        .scale(scale);

      this.svg.call(this.zoom.transform, initialTransform);

      // Update text sizes for the initial zoom level
      this.updateTextSizesForZoom(scale);
    }
  }

  /**
   * Start the force simulation
   */
  startSimulation() {
    if (this.components.forceSimulation) {
      // Initialize positions before starting simulation
      this.initializeLayerBasedPositions();
      this.components.forceSimulation.updateData(this.nodes, this.links);

      // Set initial zoom after a brief delay to ensure nodes have positions
      setTimeout(() => {
        this.setInitialZoom();
      }, 100);
    }
  }

  /**
   * Navigate to a specific position
   * @param {Object} position - {x, y} position in graph coordinates
   */
  navigateToPosition(position) {
    const scale = 1.5;
    const centerX = this.config.width / 2;
    const centerY = this.config.height / 2;
    
    const newTransform = d3.zoomIdentity
      .translate(centerX - position.x * scale, centerY - position.y * scale)
      .scale(scale);
    
    this.svg.transition()
      .duration(750)
      .call(this.zoom.transform, newTransform);
  }

  // ====== PUBLIC API METHODS ======

  /**
   * Set audience filter
   * @param {string} audienceId - 'all', 'general', 'technical', or 'current'
   */
  setAudienceFilter(audienceId) {
    this.state.currentAudience = audienceId;

    // Clear selected node when switching audiences to prevent
    // related nodes from staying visible in wrong audience context
    if (this.state.selectedNode) {
      this.setSelectedNode(null);
    }

    if (this.components.visualEffectsManager) {
      this.components.visualEffectsManager.applyAudienceEffects(audienceId, this.nodes);
    }

    this.updateLabelsForAudience(audienceId);

    this.emit('audienceChange', { audience: audienceId });
  }

  /**
   * Calculate graph distances from a selected node to all other nodes
   * @param {Object} selectedNode - The selected node
   * @returns {Map} - Map of node ID to distance from selected node
   */
  calculateGraphDistances(selectedNode) {
    const distances = new Map();
    const visited = new Set();
    const queue = [{ node: selectedNode, distance: 0 }];

    distances.set(selectedNode.id, 0);
    visited.add(selectedNode.id);

    while (queue.length > 0) {
      const { node, distance } = queue.shift();

      // Find all connected nodes (both through links and parent/child relationships)
      const connectedNodeIds = new Set();

      // Check links
      this.links.forEach(link => {
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;

        if (sourceId === node.id && !visited.has(targetId)) {
          connectedNodeIds.add(targetId);
        } else if (targetId === node.id && !visited.has(sourceId)) {
          connectedNodeIds.add(sourceId);
        }
      });

      // Check parent/child relationships
      this.nodes.forEach(n => {
        if (n.parent_node === node.id && !visited.has(n.id)) {
          connectedNodeIds.add(n.id);
        }
        if (node.parent_node === n.id && !visited.has(n.id)) {
          connectedNodeIds.add(n.id);
        }
      });

      // Add connected nodes to queue
      connectedNodeIds.forEach(nodeId => {
        if (!visited.has(nodeId)) {
          const connectedNode = this.nodes.find(n => n.id === nodeId);
          if (connectedNode) {
            visited.add(nodeId);
            distances.set(nodeId, distance + 1);
            queue.push({ node: connectedNode, distance: distance + 1 });
          }
        }
      });
    }

    return distances;
  }

  /**
   * Find all nodes related to a given node
   * @param {Object} node - The node to find relations for
   * @returns {Set} - Set of related node IDs
   */
  findRelatedNodes(node) {
    const relatedIds = new Set();

    // Add the node itself
    relatedIds.add(node.id);

    // Find all links connected to this node (both as parent and child)
    const connectedLinks = this.links.filter(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      return sourceId === node.id || targetId === node.id;
    });

    // Add connected nodes from links
    connectedLinks.forEach(link => {
      const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
      const targetId = typeof link.target === 'object' ? link.target.id : link.target;
      relatedIds.add(sourceId);
      relatedIds.add(targetId);
    });

    // Add direct parent/child relationships
    const children = this.nodes.filter(n => n.parent_node === node.id);
    children.forEach(child => relatedIds.add(child.id));

    if (node.parent_node) {
      relatedIds.add(node.parent_node);
    }

    return relatedIds;
  }

  /**
   * Update link visibility to only show links between nodes with visible labels
   */
  updateLinkVisibility() {
    if (!this.linkGroup) return;

    // During initial setup, don't show any links until properly initialized
    if (!this.state.isInitialized) {
      this.linkGroup.selectAll('.link').style('opacity', 0);
      return;
    }

    // Get all nodes with visible labels (opacity > 0)
    const nodesWithVisibleLabels = new Set();

    if (this.labelGroup) {
      this.labelGroup.selectAll('.label').each(function(d) {
        const opacity = parseFloat(d3.select(this).style('opacity')) || 0;
        if (opacity > 0) {
          nodesWithVisibleLabels.add(d.id);
        }
      });
    }

    // Update link visibility based on selection state
    this.linkGroup.selectAll('.link')
      .transition()
      .duration(300)
      .ease(d3.easeQuadOut)
      .style('opacity', d => {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;

        if (this.state.selectedNode) {
          // When a node is selected, only show links directly connected to that node
          const selectedNodeId = this.state.selectedNode.id;
          const isConnectedToSelected = (sourceId === selectedNodeId || targetId === selectedNodeId);

          // Show link if it's connected to selected node AND both endpoints have visible labels
          const sourceVisible = nodesWithVisibleLabels.has(sourceId);
          const targetVisible = nodesWithVisibleLabels.has(targetId);

          return (isConnectedToSelected && sourceVisible && targetVisible) ? 0.6 : 0;
        } else {
          // When no node is selected, show links between any nodes with visible labels
          const sourceVisible = nodesWithVisibleLabels.has(sourceId);
          const targetVisible = nodesWithVisibleLabels.has(targetId);

          return (sourceVisible && targetVisible) ? 0.6 : 0;
        }
      })
      .style('pointer-events', d => {
        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
        const targetId = typeof d.target === 'object' ? d.target.id : d.target;

        if (this.state.selectedNode) {
          // When a node is selected, only show links directly connected to that node
          const selectedNodeId = this.state.selectedNode.id;
          const isConnectedToSelected = (sourceId === selectedNodeId || targetId === selectedNodeId);

          const sourceVisible = nodesWithVisibleLabels.has(sourceId);
          const targetVisible = nodesWithVisibleLabels.has(targetId);

          return (isConnectedToSelected && sourceVisible && targetVisible) ? 'auto' : 'none';
        } else {
          // When no node is selected, enable links between any nodes with visible labels
          const sourceVisible = nodesWithVisibleLabels.has(sourceId);
          const targetVisible = nodesWithVisibleLabels.has(targetId);

          return (sourceVisible && targetVisible) ? 'auto' : 'none';
        }
      });
  }

  /**
   * Update label visibility based on audience and layer
   * @param {string} audienceId - Current audience filter
   */
  updateLabelsForAudience(audienceId) {
    if (!this.labelGroup) return;

    // Use immediate updates during panning to prevent conflicts, smooth transitions otherwise
    const labelSelection = this.labelGroup.selectAll('.label');
    const updateMethod = this.state.isPanning ? labelSelection : labelSelection.transition().duration(200);

    updateMethod.style('opacity', d => {
        // Always show labels for related nodes when a node is selected
        if (this.state.selectedNode && this.state.selectedNodeRelated.has(d.id)) {
          return 1;
        }

        // Hide labels for subnodes when "All Layers" is active and no specific layer is selected
        if (this.state.currentLayer === null && d.subnode) {
          return 0;
        }

        // Handle audience as array or string
        let nodeAudience = d.audience || ['general'];
        if (typeof nodeAudience === 'string') {
          nodeAudience = [nodeAudience];
        }

        return nodeAudience.includes(audienceId) ? 1 : 0;
      });

    // Update link visibility immediately if not panning and initialized, otherwise delay until panning completes
    if (!this.state.isPanning && this.state.isInitialized) {
      this.updateLinkVisibility();
    }
  }

  /**
   * Apply Mac dock-style hover effects based on mouse proximity
   * @param {Object} mousePosition - Mouse position in graph coordinates
   */
  applyDockHoverEffects(mousePosition) {
    // Only apply dock effects when no node is selected (info panel not visible)
    if (this.state.selectedNode !== null || !this.nodeGroup) return;

    this.nodeGroup.selectAll('.node')
      .transition()
      .duration(200)
      .ease(d3.easeQuadOut)
      .attr('r', d => {
        const originalSize = d.size || 10;
        const distance = Math.sqrt(Math.pow(d.x - mousePosition.x, 2) + Math.pow(d.y - mousePosition.y, 2));

        // Define influence radius (adjust based on your graph scale)
        const maxInfluenceRadius = 100;

        if (distance <= 30) {
          // Very close - largest zoom (like Mac dock)
          return originalSize * 1.4;
        } else if (distance <= 50) {
          // Close - medium zoom
          return originalSize * 1.25;
        } else if (distance <= maxInfluenceRadius) {
          // Within influence radius - slight zoom with falloff
          const factor = 1 + (0.15 * (1 - distance / maxInfluenceRadius));
          return originalSize * factor;
        } else {
          // Outside influence - normal size
          return originalSize;
        }
      });
  }

  /**
   * Reset dock hover effects to normal node sizes
   */
  resetDockHoverEffects() {
    // Only reset if no node is selected
    if (this.state.selectedNode !== null || !this.nodeGroup) return;

    this.nodeGroup.selectAll('.node')
      .transition()
      .duration(300)
      .ease(d3.easeQuadOut)
      .attr('r', d => d.size || 10);
  }

  /**
   * Apply size scaling to nodes based on their distance from selected node
   * @param {Map} distances - Map of node ID to distance from selected node
   */
  applyNodeSizeScaling(distances) {
    if (!this.nodeGroup) return;

    this.nodeGroup.selectAll('.node')
      .transition()
      .duration(400)
      .ease(d3.easeQuadOut)
      .attr('r', d => {
        const originalSize = d.size || 10;
        const distance = distances.get(d.id);

        if (distance === undefined) {
          // Unconnected nodes - reduce significantly
          return originalSize * 0.6;
        } else if (distance === 0) {
          // Selected node - increase significantly
          return originalSize * 1.5;
        } else if (distance === 1) {
          // Directly connected - increase slightly
          return originalSize * 1.2;
        } else if (distance === 2) {
          // 2 nodes away - slight decrease
          return originalSize * 0.8;
        } else {
          // Further away - decrease more
          return originalSize * Math.max(0.5, 1 - (distance * 0.15));
        }
      });
  }

  /**
   * Reset all nodes to their original sizes
   */
  resetNodeSizes() {
    if (!this.nodeGroup) return;

    this.nodeGroup.selectAll('.node')
      .transition()
      .duration(400)
      .ease(d3.easeQuadOut)
      .attr('r', d => d.size || 10);
  }

  /**
   * Pan the view to center on a specific node
   * @param {Object} node - Node to center on
   */
  centerOnNode(node) {
    if (!node || !this.svg || !this.zoom) return;

    const svgRect = this.svg.node().getBoundingClientRect();
    const centerX = svgRect.width / 2;
    const centerY = svgRect.height / 2;

    // Calculate the transform to center the node
    const currentTransform = d3.zoomTransform(this.svg.node());
    const newTransform = d3.zoomIdentity
      .translate(centerX - node.x * currentTransform.k, centerY - node.y * currentTransform.k)
      .scale(currentTransform.k);

    // Set panning flag to prevent text size updates during transition
    this.state.isPanning = true;

    // Smoothly transition to the new position
    this.svg.transition()
      .duration(400)
      .ease(d3.easeQuadOut)
      .call(this.zoom.transform, newTransform)
      .on('end', () => {
        // Clear panning flag and update text size for final zoom level
        this.state.isPanning = false;
        this.updateTextSizesForZoom(newTransform.k);
        // Update link visibility after panning completes
        this.updateLinkVisibility();
      });
  }

  /**
   * Set selected node and update related node visibility
   * @param {Object|null} node - Selected node or null to clear selection
   */
  setSelectedNode(node) {
    if (node) {
      this.state.selectedNode = node;
      this.state.selectedNodeRelated = this.findRelatedNodes(node);
      this.state.selectedNodeDistances = this.calculateGraphDistances(node);

      // Update VisualEffectsManager with selected node information
      if (this.components.visualEffectsManager) {
        this.components.visualEffectsManager.setSelectedNode(node, this.state.selectedNodeRelated);
      }

      // Apply visual effects
      this.applyNodeSizeScaling(this.state.selectedNodeDistances);
      this.centerOnNode(node);

      // Re-apply audience effects to respect selected node state
      if (this.components.visualEffectsManager) {
        this.components.visualEffectsManager.applyAudienceEffects(this.state.currentAudience, this.nodes);
      }
    } else {
      this.state.selectedNode = null;
      this.state.selectedNodeRelated = new Set();
      this.state.selectedNodeDistances = new Map();

      // Clear VisualEffectsManager selected node information
      if (this.components.visualEffectsManager) {
        this.components.visualEffectsManager.setSelectedNode(null, new Set());
      }

      // Reset visual effects
      this.resetNodeSizes();

      // Re-apply audience effects to normal state
      if (this.components.visualEffectsManager) {
        this.components.visualEffectsManager.applyAudienceEffects(this.state.currentAudience, this.nodes);
      }
    }

    // Update label visibility to show related nodes
    this.updateLabelsForAudience(this.state.currentAudience);

    // Trigger smart label positioning if a node is selected
    if (node && this.components.labelLayoutManager && this.config.features.smartLabelPositioning) {
      // Give a small delay to let the label visibility updates complete
      setTimeout(() => {
        this.components.labelLayoutManager.updateData(this.nodes, this.labelGroup.selectAll('.label'));
      }, 50);
    }
  }

  /**
   * Set active layer
   * @param {string|null} layerId - Layer ID or null for all layers
   */
  setActiveLayer(layerId) {
    this.state.currentLayer = layerId;
    
    if (this.components.visualEffectsManager) {
      this.components.visualEffectsManager.applyLayerEffects(layerId);
    }
    
    if (this.components.interactionManager) {
      this.components.interactionManager.updateLayerMode(layerId !== null);
    }
    
    // Update labels based on subnode visibility and current audience
    this.updateLabelsForAudience(this.state.currentAudience);
    
    this.emit('layerChange', { layer: layerId });
  }

  /**
   * Show all layers
   */
  showAllLayers() {
    this.setActiveLayer(null);
  }

  /**
   * Update data and refresh the graph
   * @param {Object} newData - New data object
   */
  updateData(newData) {
    this.validateAndProcessData(newData);
    
    // Update all components with new data
    Object.values(this.components).forEach(component => {
      if (component && component.updateData) {
        component.updateData(this.nodes, this.links);
      }
    });
    
    this.render();
    this.startSimulation();
    
    this.emit('dataUpdate', { nodeCount: this.nodes.length, linkCount: this.links.length });
  }

  /**
   * Focus on a specific node
   * @param {string} nodeId - Node ID
   */
  focusOnNode(nodeId) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node && node.x !== undefined && node.y !== undefined) {
      this.navigateToPosition({ x: node.x, y: node.y });
      this.emit('nodeFocus', { node });
    }
  }

  /**
   * Restart the simulation
   */
  restartSimulation() {
    if (this.components.forceSimulation) {
      this.components.forceSimulation.restart();
    }
  }

  /**
   * Update configuration
   * @param {Object} newConfig - Configuration updates
   */
  updateConfig(newConfig) {
    this.config = this.deepMerge(this.config, newConfig);
    
    // Update components with new config
    Object.values(this.components).forEach(component => {
      if (component && component.updateConfig) {
        component.updateConfig(newConfig);
      }
    });
    
    this.emit('configUpdate', { config: this.config });
  }

  /**
   * Add event listener
   * @param {string} eventType - Event type
   * @param {Function} callback - Callback function
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = [];
    }
    this.eventHandlers[eventType].push(callback);
    return this;
  }

  /**
   * Remove event listener
   * @param {string} eventType - Event type
   * @param {Function} callback - Callback function
   */
  off(eventType, callback) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType] = this.eventHandlers[eventType].filter(cb => cb !== callback);
    }
    return this;
  }

  /**
   * Emit event
   * @param {string} eventType - Event type
   * @param {Object} data - Event data
   */
  emit(eventType, data = {}) {
    if (this.eventHandlers[eventType]) {
      this.eventHandlers[eventType].forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event handler for ${eventType}:`, error);
        }
      });
    }
  }

  /**
   * Get current state and statistics
   * @returns {Object} - Current state information
   */
  getState() {
    return {
      ...this.state,
      nodeCount: this.nodes.length,
      linkCount: this.links.length,
      config: this.config,
      components: Object.keys(this.components).reduce((acc, key) => {
        acc[key] = this.components[key] ? 'initialized' : 'not available';
        return acc;
      }, {})
    };
  }

  /**
   * Cleanup and destroy the graph
   */
  destroy() {
    // Destroy all components
    Object.values(this.components).forEach(component => {
      if (component && component.destroy) {
        component.destroy();
      }
    });
    
    // Clear container
    this.container.innerHTML = '';
    
    // Clear references
    this.eventHandlers = {};
    this.components = {};
    this.nodes = [];
    this.links = [];
  }
}

// Export for different module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = KnowledgeGraphExplorer;
} else if (typeof window !== 'undefined') {
  window.KnowledgeGraphExplorer = KnowledgeGraphExplorer;
}


        // Initialize when ready
        function initGraph() {
            try {
                console.log('Starting graph initialization...');
                
                // Decode base64 data
                const dataStr = atob('eyJub2RlcyI6IFt7ImlkIjogIm1hZ25ldGljX21vbm9wb2xlcyIsICJsYWJlbCI6ICJNYWduZXRpYyBNb25vcG9sZXMiLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogMiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTEsICJlbmQiOiAyMDEyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImJpdHNfZWR1Y2F0aW9uIiwgImNhbGN1bHVzIiwgImxpbmVhcl9hbGdlYnJhIiwgImNvbXBsZXhfYW5hbHlzaXMiXSwgImRlc2NyaXB0aW9uIjogIlRoZSBmaXJzdCBvcmlnaW5hbCBxdWVzdGlvbiBJIGFza2VkIGFuZCB0cmllZCB0byBmb2xsb3cgdGhyb3VnaCAtIE1heHdlbGwncyBlcXVhdGlvbnMgYXJlIGFzeW1tZXRyaWMgc2luY2UgdGhlcmUgYXJlIG5vIG1hZ25ldGljIG1vbm9wb2xlcy4gV2hhdCB3b3VsZCB0aGUgbWF0aGVtYXRpY2FsIHRoZW9yeSBsb29rIGxpa2UgaWYgd2UgcG9zaXQgdGhlaXIgZXhpc3RlbmNlLCBhbmQgd2hhdCB3b3VsZCB0aGUgY29uc2VxdWVuY2VzIGJlPyBBcyBpdCB0dXJuZWQgb3V0LCBJIHJlYWxpemVkIHRoaXMgd2FzIGEgdmVyeSBvbGQgcXVlc3Rpb24gRGlyYWMgaGFkIGFscmVhZHkgYXNrZWQuIn0sIHsiaWQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJsYWJlbCI6ICJRdWFudHVtIEZvdW5kYXRpb25zIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDE1LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMiwgImVuZCI6IDIwMTR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJiaXRzX2VkdWNhdGlvbiIsICJtdW5pY2giLCAiZGV0bGVmX2R1cnIiLCAicGhpbG9zb3BoeV9waHlzaWNzIiwgImJvdHRvbV91cF9hcHByb2FjaCIsICJpbnZpdGVkX3RhbGtzIiwgIm1hc3RlcnNfdGhlc2lzX2xtdSIsICJsYXRleCJdLCAiZGVzY3JpcHRpb24iOiAiSSBnb3QgaW50cmlndWVkIGJ5IHRoZSBub24tbG9jYWwgbmF0dXJlIG9mIHF1YW50dW0gbWVjaGFuaWNzIGFuZCB0aGUgbWVhc3VyZW1lbnQgcHJvYmxlbSwgd2hpY2ggbGVkIG1lIHRvIGV4cGxvcmUgaW50ZXJwcmV0YXRpb25zIG9mIFFNLCBhbmQgaW4gcGFydGljdWxhciBCb2htaWFuIG1lY2hhbmljcy4ifSwgeyJpZCI6ICJkZXRsZWZfZHVyciIsICJsYWJlbCI6ICJEZXRsZWYgRFx1MDBmY3JyIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDE2LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMiwgImVuZCI6IDIwMTR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJtdW5pY2giLCAibWFzdGVyc190aGVzaXNfbG11IiwgInBoaWxvc29waHlfcGh5c2ljcyIsICJib3R0b21fdXBfYXBwcm9hY2giXSwgImRlc2NyaXB0aW9uIjogIk15IGFkdmlzb3IgaW4gTXVuaWNoIHdobywgaW4gbWFueSB3YXlzLCBzaGFwZWQgbXkgd2VsdGJpbGQuIEkgbGVhcm50IG11Y2ggbW9yZSB0aGFuIGp1c3QgcGh5c2ljcyBmcm9tIGhpbTsgaHVtaWxpdHksIGN1cmlvc2l0eSBhYm91dCB0aGUgd29ybGQsIGFuZCBhIGRlZXAgc2Vuc2Ugb2YgY2FyZSBmb3IgdGhlIHBlb3BsZSBoZSBpbnRlcmFjdGVkIHdpdGguIn0sIHsiaWQiOiAicmVub3JtYWxpemF0aW9uIiwgImxhYmVsIjogIlJlbm9ybWFsaXphdGlvbiAmIFVWIFByb2JsZW0iLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogNSwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTMsICJlbmQiOiAyMDE2fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImRldGxlZl9kdXJyIiwgInF1YW50dW1fZm91bmRhdGlvbnMiLCAiY29tcGxleF9hbmFseXNpcyIsICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJmb3VyaWVyX2xhcGxhY2UiLCAicGVydHVyYmF0aW9uX3RoZW9yeSJdLCAiZGVzY3JpcHRpb24iOiAiSSBmaXJzdCBlbmNvdW50ZXJlZCB0aGUgcHJvYmxlbSBvZiByZW5vcm1hbGl6YXRpb24gaW4gY2xhc3NpY2FsIGVsZWN0cm9keW5hbWljcywgd2hpY2ggbGVkIG1lIHRvIGV4cGxvcmUgdGhlIGJyb2FkZXIgaXNzdWUgb2YgaW5maW5pdGllcyBpbiBRRlQgYW5kIHRoZSByZW5vcm1hbGl6YXRpb24gZ3JvdXAuIFVuZGVyc3RhbmRpbmcgV2hlZWxlciBhbmQgRmV5bm1hbidzIGFic29yYmVyIHRoZW9yeSB3YXMgYW5vdGhlciBrZXkgc3RlcCBpbiBzaGFwaW5nIHRoZSBzdHlsZSBvZiB0aG91Z2h0L3dvcmsgd2hlcmUgYXJyaXZpbmcgYXQgYW4gZWxlZ2FudCBhbmQgY29tcGxldGUgbWF0aGVtYXRpY2FsIGZyYW1ld29yayBmb3IgYWxyZWFkeSBlbXBpcmljYWxseSBkZXNjcmliYWJsZSBwaGVub21lbmEgd2FzIHRoZSBmb2N1cy4ifSwgeyJpZCI6ICJzZWxmX2ZvcmNlIiwgImxhYmVsIjogIlNlbGYgRm9yY2UgUHJvYmxlbSIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTMsICJlbmQiOiAyMDE2fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJlbm9ybWFsaXphdGlvbiIsICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAicGVydHVyYmF0aW9uX3RoZW9yeSIsICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJtYXRoZW1hdGljYSJdLCAiZGVzY3JpcHRpb24iOiAiR2l2ZW4gbXkgb3ZlcmFyY2hpbmcgaW50ZXJlc3QgaW4gdGhlIFVWIHByb2JsZW0sIEkgd2FzIG5hdHVyYWxseSBkcmF3biB0byB0aGUgc2VsZi1mb3JjZSBwcm9ibGVtIGluIEdSLCB3aGljaCBpcyBhIGNsYXNzaWNhbCBhbmFsb2d1ZSBvZiB0aGUgcmVub3JtYWxpemF0aW9uIHByb2JsZW0gaW4gUUZULiBUaGlzIHdhcyB3aGF0IHRvb2sgbWUgdG8gU2FtIEdyYWxsYSBhdCB0aGUgVW5pdmVyc2l0eSBvZiBBcml6b25hIGZvciBteSBQaEQuIn0sIHsiaWQiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHkiLCAibGFiZWwiOiAiQmxhY2sgSG9sZSBTdGFiaWxpdHkiLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogMTgsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE2LCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiBmYWxzZSwgInBhcmVudF9ub2RlIjogWyJzZWxmX2ZvcmNlIiwgInVvZmFfZWR1Y2F0aW9uIiwgInNhbV9ncmFsbGEiLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5IiwgInBlcnR1cmJhdGlvbl90aGVvcnkiLCAicHl0aG9uIiwgIm1hdGhlbWF0aWNhIl0sICJkZXNjcmlwdGlvbiI6ICJNeSBQaEQgcmVzZWFyY2ggaW52ZXN0aWdhdGVkIGEgc3VidGxlIGJ1dCBmdW5kYW1lbnRhbCBpbnN0YWJpbGl0eSB0aGF0IG9jY3VycyBhdCBleHRyZW1hbCBibGFjayBob2xlIGhvcml6b25zLiBJIHdhcyBmYXNjaW5hdGVkIGJ5IHVuZGVyc3RhbmRpbmcgdGhlIHBoeXNpY2FsIG1lY2hhbmlzbXMgYmVoaW5kIHRoaXMgcGhlbm9tZW5vbiAtIHdoeSBjZXJ0YWluIHBlcnR1cmJhdGlvbnMgZ2V0IHRyYXBwZWQgbmVhciB0aGUgaG9yaXpvbiBmb3IgcGFyYW1ldHJpY2FsbHkgbG9uZyB0aW1lcyBiZWZvcmUgZmFsbGluZyBpbi4gVXNpbmcgc2ltcGxpZmllZCBtb2RlbHMgbGlrZSB0aGUgQlRaIGJsYWNrIGhvbGUgYXMgYSB0aGVvcmV0aWNhbCBwbGF5Z3JvdW5kLCBJIGRpc2NvdmVyZWQgdGhpcyBpbnN0YWJpbGl0eSBpcyBjb25uZWN0ZWQgdG8gc3BlY2lhbCBudWxsIGdlb2Rlc2ljIHRyYWplY3RvcmllcyB0aGF0IHNwaXJhbCBhcm91bmQgdGhlIGJsYWNrIGhvbGUgbWFueSB0aW1lcyBiZWZvcmUgY3Jvc3NpbmcgdGhlIGhvcml6b24uIEV4dGVuZGluZyB0byBtb3JlIHJlYWxpc3RpYyBnZW9tZXRyaWVzLCBJIGZvdW5kIHRoaXMgaG9yaXpvbiBpbnN0YWJpbGl0eSBwbGF5cyBhIGNydWNpYWwgcm9sZSBpbiBob2xvZ3JhcGhpYyBkdWFsaXR5LCBiZWluZyBlc3NlbnRpYWwgZm9yIG1haW50YWluaW5nIHNlbWktbG9jYWwgcXVhbnR1bSBjcml0aWNhbGl0eSBpbiBkdWFsIGZpZWxkIHRoZW9yaWVzIGFuZCBjb25uZWN0aW5nIGJsYWNrIGhvbGUgcGh5c2ljcyB0byBjcml0aWNhbCBwaGVub21lbmEsIHBvd2VyIGxhd3MsIGFuZCBwaGFzZSB0cmFuc2l0aW9ucy4ifSwgeyJpZCI6ICJidHpfYmxhY2tfaG9sZSIsICJsYWJlbCI6ICJCVFogQmxhY2sgSG9sZSIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTYsICJlbmQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgImNvbXBsZXhfYW5hbHlzaXMiLCAic3BlY2lhbF9mdW5jdGlvbnMiLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5Il0sICJkZXNjcmlwdGlvbiI6ICJBIHRocmVlLWRpbWVuc2lvbmFsIGJsYWNrIGhvbGUgc29sdXRpb24gaW4gQW50aS1kZSBTaXR0ZXIgc3BhY2UgdGhhdCBzZXJ2ZXMgYXMgYSBzaW1wbGlmaWVkIG1vZGVsIGZvciBzdHVkeWluZyBibGFjayBob2xlIHBoeXNpY3Mgd2hpbGUgcmV0YWluaW5nIGVzc2VudGlhbCBmZWF0dXJlcyBsaWtlIGhvcml6b25zIGFuZCB0aGVybW9keW5hbWljcy4gSW4gbXkgcmVzZWFyY2gsIEkgdXNlZCB0aGUgZXh0cmVtYWwgQlRaIGFzIGEgdHJhY3RhYmxlIHBsYXlncm91bmQgdG8gdW5kZXJzdGFuZCB0aGUgQXJldGFraXMgaW5zdGFiaWxpdHksIGRldmVsb3BpbmcgdGltZS1kb21haW4gdGVjaG5pcXVlcyB0byBjb25zdHJ1Y3QgdGhlIHJldGFyZGVkIEdyZWVuIGZ1bmN0aW9uIHVzaW5nIHRoZSBtZXRob2Qgb2YgaW1hZ2VzLiBJIHNvbHZlZCB0aGUgbnVsbCBnZW9kZXNpYyBlcXVhdGlvbiBpbiBmdWxsIGdlbmVyYWxpdHkgYW5kIGRlbW9uc3RyYXRlZCB0aGF0IHRoZSBob3Jpem9uIGluc3RhYmlsaXR5IGFyaXNlcyBmcm9tIGEgc3BlY2lmaWMgY2xhc3Mgb2YgbnVsbCBnZW9kZXNpY3MgdGhhdCBvcmJpdCBuZWFyIHRoZSBldmVudCBob3Jpem9uIGFyYml0cmFyaWx5IG1hbnkgdGltZXMgYmVmb3JlIGZhbGxpbmcgaW4sIHByb3ZpZGluZyB0aGUgZmlyc3QgY2xlYXIgcGh5c2ljYWwgaW50ZXJwcmV0YXRpb24gb2YgaG93IHBlcnR1cmJhdGlvbnMgZ2V0IHRyYXBwZWQgbmVhciBleHRyZW1hbCBob3Jpem9ucy4ifSwgeyJpZCI6ICJhcmV0YWtpc19pbnN0YWJpbGl0eSIsICJsYWJlbCI6ICJBcmV0YWtpcyBJbnN0YWJpbGl0eSIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTYsICJlbmQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgImJ0el9ibGFja19ob2xlIiwgInBlcnR1cmJhdGlvbl90aGVvcnkiLCAiZm91cmllcl9sYXBsYWNlIl0sICJkZXNjcmlwdGlvbiI6ICJBIGNvdW50ZXJpbnR1aXRpdmUgaW5zdGFiaWxpdHkgb2YgZXh0cmVtYWwgYmxhY2sgaG9sZSBob3Jpem9ucyB3aGVyZSBmaWVsZCBwZXJ0dXJiYXRpb25zIGRlY2F5IGV2ZXJ5d2hlcmUgZXhjZXB0IHByZWNpc2VseSBvbiB0aGUgaG9yaXpvbiwgd2hlcmUgdHJhbnN2ZXJzZSBkZXJpdmF0aXZlcyBncm93IHBvbHlub21pYWxseSB3aXRoIHRpbWUuIFRoaXMgaW5zdGFiaWxpdHkgd2FzIHN1cnByaXNpbmcgYmVjYXVzZSBleHRyZW1hbCBibGFjayBob2xlcyB3ZXJlIHRob3VnaHQgdG8gYmUgc3RhYmxlLiBNeSB3b3JrIGV4dGVuZGVkIHVuZGVyc3RhbmRpbmcgb2YgdGhpcyBwaGVub21lbm9uIGZyb20gY29tcGFjdCB0byBwbGFuYXIgaG9yaXpvbiBnZW9tZXRyaWVzLCBzaG93aW5nIGl0IHBlcnNpc3RzIGluIGNhc2VzIHJlbGV2YW50IHRvIGhvbG9ncmFwaHkuIEkgZGVtb25zdHJhdGVkIHRoZSBwaHlzaWNhbCBtZWNoYW5pc206IG51bGwgZ2VvZGVzaWNzIHRoYXQgc3BlbmQgcGFyYW1ldHJpY2FsbHkgbG9uZyB0aW1lcyBuZWFyIHRoZSBob3Jpem9uIGJlZm9yZSBmYWxsaW5nIGluLCBlZmZlY3RpdmVseSB0cmFwcGluZyBwZXJ0dXJiYXRpb25zIGFuZCBjYXVzaW5nIHRoZSBtYXRoZW1hdGljYWwgZ3Jvd3RoIG9mIGRlcml2YXRpdmVzIGF0IHRoZSBob3Jpem9uIGJvdW5kYXJ5LiJ9LCB7ImlkIjogInBfcm5hZHM1IiwgImxhYmVsIjogIlBsYW5hciBSZWlzc25lci1Ob3Jkc3RyXHUwMGY2bSBBZFM1IiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDEwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNiwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYXJldGFraXNfaW5zdGFiaWxpdHkiLCAiYWRzX2NmdCIsICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiXSwgImRlc2NyaXB0aW9uIjogIkZpdmUtZGltZW5zaW9uYWwgY2hhcmdlZCBibGFjayBob2xlcyB3aXRoIHBsYW5hciBob3Jpem9uIHRvcG9sb2d5IGluIEFudGktZGUgU2l0dGVyIHNwYWNlLCBwYXJ0aWN1bGFybHkgcmVsZXZhbnQgZm9yIGhvbG9ncmFwaGljIGFwcGxpY2F0aW9ucy4gV2UgcHJvdmVkIHRoYXQgZXh0cmVtYWwgcGxhbmFyIFJOLUFkUzUgYmxhY2sgaG9sZXMgZXhoaWJpdCB0aGUgQXJldGFraXMgaW5zdGFiaWxpdHkgZGVzcGl0ZSBoYXZpbmcgbm9uLWNvbXBhY3QgaG9yaXpvbiBnZW9tZXRyeSwgZXh0ZW5kaW5nIHByZXZpb3VzIHJlc3VsdHMgdGhhdCByZXF1aXJlZCBjb21wYWN0IGhvcml6b25zLiBUaGlzIHdvcmsgcmV2ZWFsZWQgZGVlcCBjb25uZWN0aW9ucyBiZXR3ZWVuIGJ1bGsgaG9yaXpvbiBpbnN0YWJpbGl0aWVzIGFuZCBib3VuZGFyeSBwaHlzaWNzOiB0aGUgc3BhdGlhbGx5IGxvY2FsaXplZCBwb3dlci1sYXcgZ3Jvd3RoIG9mIHN0cmVzcy1lbmVyZ3kgb24gdGhlIGhvcml6b24gY29ycmVzcG9uZHMgdG8gc2VtaS1sb2NhbCBxdWFudHVtIGNyaXRpY2FsaXR5IGluIHRoZSBkdWFsIGZpZWxkIHRoZW9yeSwgd2hlcmUgdGVtcG9yYWwgY29uZm9ybWFsIHN5bW1ldHJ5IGVtZXJnZXMgYW5kIHRoZSBidWxrIGluc3RhYmlsaXR5IGlzIGVzc2VudGlhbCBmb3IgcHJlc2VydmluZyB0aGlzIHN5bW1ldHJ5IHVuZGVyIGludGVyYWN0aW9ucyJ9LCB7ImlkIjogImNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIiwgImxhYmVsIjogIkNyaXRpY2FsIFBoZW5vbWVuYSAmIFNjYWxpbmciLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogMTQsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE2LCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJwX3JuYWRzNSIsICJib3R0b21fdXBfYXBwcm9hY2giLCAiYWRzX2NmdCIsICJzdGF0aXN0aWNzIiwgImFnZW50X2Jhc2VkX21vZGVsbGluZyJdLCAiZGVzY3JpcHRpb24iOiAiVW5pdmVyc2FsIGJlaGF2aW9yIG5lYXIgcGhhc2UgdHJhbnNpdGlvbnMgY2hhcmFjdGVyaXplZCBieSBwb3dlciBsYXdzLCBzY2FsaW5nIHN5bW1ldHJpZXMsIGFuZCBlbWVyZ2VudCBjb25mb3JtYWwgaW52YXJpYW5jZS4gTXkgZWFybHkgZXhwb3N1cmUgdG8gcGhhc2UgdHJhbnNpdGlvbnMgYW5kIHRoZSByZW5vcm1hbGl6YXRpb24gZ3JvdXAgaW4gc3RhdGlzdGljYWwgcGh5c2ljcyBmYXNjaW5hdGVkIG1lIHdpdGggaG93IHNpbXBsZSBtaWNyb3Njb3BpYyBydWxlcyBjb3VsZCBnaXZlIHJpc2UgdG8gdW5pdmVyc2FsIG1hY3Jvc2NvcGljIGJlaGF2aW9yLiBXaGVuIG15IGJsYWNrIGhvbGUgcmVzZWFyY2ggcmV2ZWFsZWQgdW5leHBlY3RlZCBjb25uZWN0aW9ucyB0byBjcml0aWNhbCBwaGVub21lbmEgLSB3aXRoIGhvcml6b24gaW5zdGFiaWxpdGllcyBjb3JyZXNwb25kaW5nIHRvIHNlbWktbG9jYWwgcXVhbnR1bSBjcml0aWNhbGl0eSBpbiBkdWFsIGZpZWxkIHRoZW9yaWVzIC0gaXQgZGVlcGVuZWQgbXkgYXBwcmVjaWF0aW9uIGZvciBob3cgdGhlc2UgdW5pdmVyc2FsIHBhdHRlcm5zIGVtZXJnZSBhY3Jvc3MgdmFzdGx5IGRpZmZlcmVudCBwaHlzaWNhbCBzeXN0ZW1zLiBUaGlzIHNwYXJrZWQgbXkgYnJvYWRlciBpbnRlcmVzdCBpbiB1bml2ZXJzYWxpdHkgYW5kIGVtZXJnZW50IHBoZW5vbWVuYSBiZXlvbmQgcGh5c2ljczogc2NhbGluZyBsYXdzIGluIG5ldXJhbCBuZXR3b3JrIHRyYWluaW5nLCBwaGFzZSB0cmFuc2l0aW9ucyBpbiBtdWx0aS1hZ2VudCBzeXN0ZW1zLCBtYXJrZXQgZHluYW1pY3MsIGFuZCBjb2xsZWN0aXZlIGJlaGF2aW9yLiBUaGUgbWF0aGVtYXRpY2FsIHNpZ25hdHVyZXMgb2YgY3JpdGljYWxpdHkgLSBwb3dlciBsYXdzLCBzY2FsZSBpbnZhcmlhbmNlLCBlbWVyZ2VudCBzeW1tZXRyaWVzIC0gYXBwZWFyIHJlbWFya2FibHkgY29uc2lzdGVudGx5IGFjcm9zcyBzZWVtaW5nbHkgZGlzcGFyYXRlIGRvbWFpbnMsIHN1Z2dlc3RpbmcgZGVlcCB1bmRlcmx5aW5nIHByaW5jaXBsZXMgZ292ZXJuaW5nIGNvbXBsZXggZW1lcmdlbnQgYmVoYXZpb3IuIn0sIHsiaWQiOiAic2FtX2dyYWxsYSIsICJsYWJlbCI6ICJTYW0gR3JhbGxhIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDE1LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNSwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsidW9mYV9lZHVjYXRpb24iLCAic2VsZl9mb3JjZSIsICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJ0dWNzb24iLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5Il0sICJkZXNjcmlwdGlvbiI6ICJNeSBQaEQgYWR2aXNvciBhdCB0aGUgVW5pdmVyc2l0eSBvZiBBcml6b25hLiBJIHdlbnQgdG8gd29yayB3aXRoIFNhbSBiZWNhdXNlIG9mIGhpcyBleHBlcnRpc2UgaW4gdGhlIHNlbGYtZm9yY2UgcHJvYmxlbSwgYnV0IGVuZGVkIHVwIGdldHRpbmcgaW50ZXJlc3RlZCBpbiBvdGhlciBhcmVhcyBvZiBjbGFzc2ljYWwgYW5kIHNlbWktY2xhc3NpY2FsIHJlbGF0aXZpdHkuIE9uZSB0aGluZyBJIHJlYWxseSBhcHByZWNpYXRlZCBhYm91dCBTYW0ncyByZXNlYXJjaCB3YXMgaGlzIGFuYWx5dGljYWwgYXBwcm9hY2ggdG8gdW5kZXJzdGFuZGluZyBob3cgZGlmZmVyZW50IHBoeXNpY2FsIHNjYWxlcyBpbnRlcmFjdCBpbiB2YXJpb3VzIGxpbWl0cyAtIHRoZSBzeXN0ZW1hdGljIHdheSBoZSBoYW5kbGVkIGFwcHJveGltYXRpb25zIHdoZW4gbXVsdGlwbGUgc2NhbGVzIGFyZSBhdCBwbGF5LiBUaGlzIGJlY2FtZSBhIGtleSBwYXJ0IG9mIGhvdyBJIHRoaW5rIGFib3V0IHBoeXNpY3MgcHJvYmxlbXMuIEV2ZW4gdGhvdWdoIG15IHJlc2VhcmNoIHNoaWZ0ZWQgZnJvbSBzZWxmLWZvcmNlIHRvIGJsYWNrIGhvbGUgc3RhYmlsaXR5LCBTYW0gd2FzIGFuIGV4Y2VsbGVudCBhZHZpc29yIHdobyB0YXVnaHQgbWUgcmlnb3JvdXMgbWF0aGVtYXRpY2FsIHRlY2huaXF1ZXMgYW5kIGhlbHBlZCBtZSBkZXZlbG9wIHBoeXNpY2FsIGludHVpdGlvbiBhYm91dCBncmF2aXRhdGlvbmFsIHBoZW5vbWVuYS4ifSwgeyJpZCI6ICJhZHNfY2Z0IiwgImxhYmVsIjogIkFkUy9DRlQgQ29ycmVzcG9uZGVuY2UiLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogNiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTgsICJlbmQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInBfcm5hZHM1IiwgImNvbXBsZXhfYW5hbHlzaXMiLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5Il0sICJkZXNjcmlwdGlvbiI6ICJIb2xvZ3JhcGhpYyBkdWFsaXR5IGJldHdlZW4gZ3Jhdml0eSB0aGVvcmllcyBpbiBBbnRpLWRlIFNpdHRlciBzcGFjZSBhbmQgY29uZm9ybWFsIGZpZWxkIHRoZW9yaWVzIG9uIHRoZSBib3VuZGFyeS4gSSB3YXMgaW5pdGlhbGx5IGRyYXduIHRvIEFkUy9DRlQgYXMgd2hhdCBJIHRob3VnaHQgd291bGQgYmUgbXkgZW50cnkgcG9pbnQgaW50byBtb3JlIGZ1bmRhbWVudGFsIHBoeXNpY3MsIGdpdmVuIHRoZSBwcm9mb3VuZCBxdWVzdGlvbnMgaXQgcmFpc2VzIGFib3V0IHRoZSBuYXR1cmUgb2Ygc3BhY2V0aW1lIGFuZCBxdWFudHVtIGdyYXZpdHkuIEhvd2V2ZXIsIGl0IHF1aWNrbHkgYmVjYW1lIGNsZWFyIHRoYXQgZnVsbHkgYXBwcmVjaWF0aW5nIHRoZSBjb3JyZXNwb25kZW5jZSByZXF1aXJlcyBkZWVwIGV4cGVydGlzZSBpbiBzdHJpbmcgdGhlb3J5LCB3aGljaCByZW1haW5lZCBiZXlvbmQgbXkgcmVhY2guIE5ldmVydGhlbGVzcywgbXkgYmxhY2sgaG9sZSB3b3JrIHByb3ZpZGVkIGEgd2luZG93IGludG8gc3BlY2lmaWMgYXNwZWN0cyBvZiB0aGUgZHVhbGl0eSwgcGFydGljdWxhcmx5IGhvdyBidWxrIGhvcml6b24gcGh5c2ljcyBtYXBzIHRvIGJvdW5kYXJ5IGNyaXRpY2FsIHBoZW5vbWVuYSwgZ2l2aW5nIG1lIGEgdGFzdGUgb2YgaXRzIHJlbWFya2FibGUgZGVwdGggd2hpbGUgaGlnaGxpZ2h0aW5nIGhvdyBtdWNoIHJlbWFpbnMgdG8gYmUgdW5kZXJzdG9vZC4ifSwgeyJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2giLCAibGFiZWwiOiAiQm90dG9tLVVwIEFwcHJvYWNoIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDE1LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxM30sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IGZhbHNlLCAicGFyZW50X25vZGUiOiBbImRldGxlZl9kdXJyIiwgInBoaWxvc29waHlfcGh5c2ljcyIsICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAicmVpbmZvcmNlbWVudF9sZWFybmluZyJdLCAiZGVzY3JpcHRpb24iOiAiQnVpbGRpbmcgdW5kZXJzdGFuZGluZyBmcm9tIGZ1bmRhbWVudGFsIHByaW5jaXBsZXMgYW5kIG1pY3Jvc2NvcGljIGR5bmFtaWNzLiBUaGlzIGFwcHJvYWNoIHN0YXJ0cyB3aXRoIGJhc2ljIGF4aW9tcyBhYm91dCBob3cgbmF0dXJlIHdvcmtzIGFuZCBkZXJpdmVzIGNvbmNsdXNpb25zIHRocm91Z2ggbWF0aGVtYXRpY2FsIGZyYW1ld29ya3MgLSBsaWtlIEJvaG1pYW4gbWVjaGFuaWNzIHByb3ZpZGluZyBhIGRldGVybWluaXN0aWMgZm91bmRhdGlvbiBmb3IgcXVhbnR1bSBtZWNoYW5pY3MsIG9yIGdlbmVyYWwgcmVsYXRpdml0eSBlbWVyZ2luZyBmcm9tIHRoZSBlcXVpdmFsZW5jZSBwcmluY2lwbGUuIE1vc3Qgb2YgdGhlb3JldGljYWwgcGh5c2ljcyBmb2xsb3dzIHRoaXMgcGF0dGVybjogcHJvcG9zZSBmdW5kYW1lbnRhbCBydWxlcyBhbmQgd29yayBvdXQgdGhlaXIgY29uc2VxdWVuY2VzLiBJIGFwcGx5IHRoaXMgdGhpbmtpbmcgYmV5b25kIHBoeXNpY3MgdG9vLCBsaWtlIGluIGFnZW50LWJhc2VkIG1vZGVsaW5nIHdoZXJlIEkgc3RhcnQgYnkgZGVmaW5pbmcgd2hhdCBpbmRpdmlkdWFsIGFnZW50cyBkbyBpbiBhIG1hcmtldCBhbmQgdGhlbiBzZWUgd2hhdCBlbWVyZ2VudCBwaGVub21lbmEgYXJpc2UsIHJhdGhlciB0aGFuIGp1c3Qgb2JzZXJ2aW5nIHBhdHRlcm5zIGFuZCBzdG9wcGluZyB0aGVyZS4gVGhpcyBhcHByb2FjaCBhcHBlYWxzIHRvIG1lIGJlY2F1c2UgaXQgc2Vla3MgdG8gdW5kZXJzdGFuZCB0aGUgdW5kZXJseWluZyBtZWNoYW5pc21zIHRoYXQgZ2VuZXJhdGUgb2JzZXJ2ZWQgYmVoYXZpb3IuIn0sIHsiaWQiOiAidG9wX2Rvd25fYXBwcm9hY2giLCAibGFiZWwiOiAiVG9wLURvd24gQXBwcm9hY2giLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTUsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIwfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJzdGF0aXN0aWNzIiwgImV4cGVyaW1lbnRhbF9kZXNpZ24iXSwgImRlc2NyaXB0aW9uIjogIlN0YXJ0aW5nIGZyb20gb2JzZXJ2ZWQgcGhlbm9tZW5hIGFuZCB3b3JraW5nIGJhY2t3YXJkcyB0byB1bmRlcmx5aW5nIG1lY2hhbmlzbXMuIFRoaXMgaXMgdGhlIGFwcHJvYWNoIG9mIHN0YXRpc3RpY3MsIG1hY2hpbmUgbGVhcm5pbmcsIGFuZCBBSSAtIHlvdSBiZWdpbiB3aXRoIGRhdGEgYW5kIHRyeSB0byBpbmZlciBwYXR0ZXJucywgcmVsYXRpb25zaGlwcywgb3IgbW9kZWxzIHRoYXQgZXhwbGFpbiB3aGF0IHlvdSBvYnNlcnZlLiBSYXRoZXIgdGhhbiBzdGFydGluZyB3aXRoIHRoZW9yZXRpY2FsIGF4aW9tcywgeW91IGxldCB0aGUgZGF0YSBndWlkZSB5b3UgdG93YXJkIHVuZGVyc3RhbmRpbmcuIFRoaXMgZW1waXJpY2FsIGFwcHJvYWNoIGhhcyBiZWNvbWUgY2VudHJhbCB0byBteSB3b3JrIGluIGRhdGEgc2NpZW5jZSwgd2hlcmUgdGhlIGdvYWwgaXMgb2Z0ZW4gdG8gZXh0cmFjdCBpbnNpZ2h0cyBkaXJlY3RseSBmcm9tIG9ic2VydmVkIGJlaGF2aW9yIHdpdGhvdXQgbmVjZXNzYXJpbHkgaGF2aW5nIGEgY29tcGxldGUgdGhlb3JldGljYWwgZnJhbWV3b3JrIGJlZm9yZWhhbmQuIEJvdGggYXBwcm9hY2hlcyBhcmUgdmFsdWFibGUsIGFuZCBtdWNoIG9mIG15IGN1cnJlbnQgd29yayBpbnZvbHZlcyBicmlkZ2luZyBiZXR3ZWVuIHRoZW0gLSB1c2luZyBib3R0b20tdXAgaW5zaWdodHMgdG8gaW5mb3JtIGRhdGEtZHJpdmVuIG1vZGVscyBhbmQgdXNpbmcgZW1waXJpY2FsIGZpbmRpbmdzIHRvIGd1aWRlIHRoZW9yZXRpY2FsIHVuZGVyc3RhbmRpbmcuIn0sIHsiaWQiOiAicGhpbG9zb3BoeV9waHlzaWNzIiwgImxhYmVsIjogIlBoaWxvc29waHkgb2YgUGh5c2ljcyIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiA2LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMywgImVuZCI6IDIwMTh9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgImV4cGVyaWVuY2VMZXZlbCI6ICJpbnRlcmVzdGVkIiwgInBhcmVudF9ub2RlIjogWyJxdWFudHVtX2ZvdW5kYXRpb25zIiwgImRldGxlZl9kdXJyIiwgIm11bmljaCIsICJiaXRzX2VkdWNhdGlvbiJdLCAiZGVzY3JpcHRpb24iOiAiVGhlIGRlZXAgY29uY2VwdHVhbCBxdWVzdGlvbnMgdW5kZXJseWluZyBwaHlzaWNhbCB0aGVvcmllcyBhbmQgdGhlaXIgaW1wbGljYXRpb25zIGZvciBvdXIgdW5kZXJzdGFuZGluZyBvZiByZWFsaXR5LiBJIHdhcyBwYXJ0aWN1bGFybHkgZHJhd24gdG8gcXVlc3Rpb25zIGFib3V0IHBoeXNpY3MgYW5kIGZyZWUgd2lsbCwgdGFraW5nIGEgY291cnNlIHdpdGggSmVuYW5uIElzbWFlbCB0aGF0IGV4cGxvcmVkIGhvdyBkZXRlcm1pbmlzdGljIHBoeXNpY2FsIGxhd3MgcmVsYXRlIHRvIGh1bWFuIGFnZW5jeSBhbmQgY2hvaWNlLiBUaGUgZm91bmRhdGlvbnMgb2YgcXVhbnR1bSBtZWNoYW5pY3MgYWxzbyBmYXNjaW5hdGVkIG1lIC0gdGhlIG1lYXN1cmVtZW50IHByb2JsZW0sIHRoZSByb2xlIG9mIHRoZSBvYnNlcnZlciwgYW5kIHdoYXQgZGlmZmVyZW50IGludGVycHJldGF0aW9ucyBsaWtlIEJvaG1pYW4gbWVjaGFuaWNzIG1pZ2h0IHRlbGwgdXMgYWJvdXQgdGhlIG5hdHVyZSBvZiByZWFsaXR5LiBUaGVzZSBwaGlsb3NvcGhpY2FsIGlucXVpcmllcyBjb21wbGVtZW50ZWQgbXkgdGVjaG5pY2FsIHBoeXNpY3Mgd29yayBieSBmb3JjaW5nIG1lIHRvIHRoaW5rIGNhcmVmdWxseSBhYm91dCB3aGF0IG91ciBtYXRoZW1hdGljYWwgZnJhbWV3b3JrcyBhY3R1YWxseSBtZWFuIGFuZCB3aGF0IHRoZXkgaW1wbHkgYWJvdXQgdGhlIHdvcmxkLiBVbmRlcnN0YW5kaW5nIHRoZSBjb25jZXB0dWFsIGZvdW5kYXRpb25zIGhlbHBlZCBjbGFyaWZ5IHdoeSBjZXJ0YWluIGFwcHJvYWNoZXMgaW4gcGh5c2ljcyBhcmUgY29tcGVsbGluZyBhbmQgd2hhdCBhc3N1bXB0aW9ucyB3ZSdyZSBtYWtpbmcgd2hlbiB3ZSBhZG9wdCBwYXJ0aWN1bGFyIHRoZW9yZXRpY2FsIGZyYW1ld29ya3MuIn0sIHsiaWQiOiAicHVibGljYXRpb25zIiwgImxhYmVsIjogIlBoeXNpY3MgUHVibGljYXRpb25zIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDEwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxOH0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiBmYWxzZSwgInBhcmVudF9ub2RlIjogWyJibGFja19ob2xlX3N0YWJpbGl0eSIsICJhcmV0YWtpc19pbnN0YWJpbGl0eSIsICJidHpfYmxhY2tfaG9sZSIsICJwX3JuYWRzNSIsICJsYXRleCIsICJzYW1fZ3JhbGxhIl0sICJkZXNjcmlwdGlvbiI6ICJNeSByZXNlYXJjaCBwdWJsaWNhdGlvbnMgaW4gZ3Jhdml0YXRpb25hbCBwaHlzaWNzIGFuZCBibGFjayBob2xlIHRoZW9yeSwgYXZhaWxhYmxlIG9uIElOU1BJUkUtSEVQLiBLZXkgcGFwZXJzIGluY2x1ZGU6XG5cblwiSG9yaXpvbiBpbnN0YWJpbGl0eSBvZiB0aGUgZXh0cmVtYWwgQlRaIGJsYWNrIGhvbGVcIiAoMjAyMCkgLSBTLkUuIEdyYWxsYSwgQS4gUmF2aXNoYW5rYXIsIFAuIFppbW1lcm1hbiwgSm91cm5hbCBvZiBIaWdoIEVuZXJneSBQaHlzaWNzIC0gRGVtb25zdHJhdGVkIHRoZSBBcmV0YWtpcyBpbnN0YWJpbGl0eSBpbiB0aGUgQlRaIGJsYWNrIGhvbGUgYW5kIGNvbm5lY3RlZCBpdCB0byBudWxsIGdlb2Rlc2ljcyB0aGF0IG9yYml0IG5lYXIgdGhlIGhvcml6b24uXG5cblwiU2VtaS1sb2NhbCBxdWFudHVtIGNyaXRpY2FsaXR5IGFuZCB0aGUgaW5zdGFiaWxpdHkgb2YgZXh0cmVtYWwgcGxhbmFyIGhvcml6b25zXCIgKDIwMTgpIC0gUy5FLiBHcmFsbGEsIEEuIFJhdmlzaGFua2FyLCBQLiBaaW1tZXJtYW4gLSBFeHRlbmRlZCB0aGUgQXJldGFraXMgaW5zdGFiaWxpdHkgdG8gcGxhbmFyIGdlb21ldHJpZXMgYW5kIHJldmVhbGVkIGNvbm5lY3Rpb25zIHRvIGNyaXRpY2FsIHBoZW5vbWVuYSBpbiBob2xvZ3JhcGhpYyBmaWVsZCB0aGVvcmllcy5cblxuUGhEIERpc3NlcnRhdGlvbjogXCJPbiB0aGUgSG9yaXpvbiBJbnN0YWJpbGl0eSBvZiBFeHRyZW1hbCBCbGFjayBIb2xlcyBhbmQgQmxhY2sgQnJhbmVzXCIgKDIwMjEpIC0gVW5pdmVyc2l0eSBvZiBBcml6b25hIC0gQ29tcHJlaGVuc2l2ZSBzdHVkeSBvZiBleHRyZW1hbCBob3Jpem9uIGluc3RhYmlsaXRpZXMgYWNyb3NzIGRpZmZlcmVudCBnZW9tZXRyaWVzIGFuZCB0aGVpciBpbXBsaWNhdGlvbnMgZm9yIGhvbG9ncmFwaGljIGR1YWxpdHkuXG5cblRoZXNlIHB1YmxpY2F0aW9ucyByZXByZXNlbnQgbXkgY29udHJpYnV0aW9ucyB0byB1bmRlcnN0YW5kaW5nIGJsYWNrIGhvbGUgc3RhYmlsaXR5IGFuZCB0aGUgc3VycHJpc2luZyBjb25uZWN0aW9ucyBiZXR3ZWVuIGdyYXZpdGF0aW9uYWwgcGh5c2ljcyBhbmQgY3JpdGljYWwgcGhlbm9tZW5hLlxuIn0sIHsiaWQiOiAiY29uZmVyZW5jZXMiLCAibGFiZWwiOiAiQ29uZmVyZW5jZXMgJiBTY2hvb2xzIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDEwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNCwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IGZhbHNlLCAicGFyZW50X25vZGUiOiBbInB1YmxpY2F0aW9ucyIsICJpbnZpdGVkX3RhbGtzIiwgImxhdGV4IiwgInVvZmFfZWR1Y2F0aW9uIl0sICJkZXNjcmlwdGlvbiI6ICJQcmVzZW50YXRpb25zIGF0IG1ham9yIHBoeXNpY3MgY29uZmVyZW5jZXMgaW5jbHVkaW5nIFBhY2lmaWMgQ29hc3QgR3Jhdml0eSBNZWV0ICgyMDE4LCAyMDIxKSBhdCBDYWx0ZWNoIGFuZCBVbml2ZXJzaXR5IG9mIEFyaXpvbmEsIGFuZCBBbWVyaWNhbiBQaHlzaWNhbCBTb2NpZXR5IEFwcmlsIE1lZXRpbmcgKDIwMTkpIGluIERlbnZlci4gVG9waWNzIGZvY3VzZWQgb24gZXh0cmVtYWwgYmxhY2sgaG9sZSBpbnN0YWJpbGl0aWVzLCBjcml0aWNhbCBiZWhhdmlvciBpbiBob2xvZ3JhcGhpYyBzeXN0ZW1zLCBhbmQgdGhlIEJUWiBibGFjayBob2xlIGhvcml6b24gaW5zdGFiaWxpdHkuIEFsc28gYXR0ZW5kZWQgc3BlY2lhbGl6ZWQgd29ya3Nob3BzIGFuZCBzY2hvb2xzIGluY2x1ZGluZyB0aGUgU3VtbWVyIFNjaG9vbCBvbiBGb3VuZGF0aW9ucyBvZiBRdWFudHVtIE1lY2hhbmljcyBkZWRpY2F0ZWQgdG8gSm9obiBCZWxsICgyMDE0KSwgV29ya3Nob3Agb24gTXVsdGktVGltZSBXYXZlZnVuY3Rpb25zIGF0IFJ1dGdlcnMgKDIwMTgpLCBhbmQgQmFyY2Vsb25hIFN1bW1lciBTY2hvb2wgb24gTWFjaGluZSBMZWFybmluZyBhbmQgTWVjaGFuaXN0aWMgTW9kZWxpbmcgKDIwMTkpLlxuIn0sIHsiaWQiOiAiaW52aXRlZF90YWxrcyIsICJsYWJlbCI6ICJJbnZpdGVkIFRhbGtzIiwgImxheWVyIjogInBoeXNpY3MiLCAic2l6ZSI6IDgsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE0LCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIl0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsiY29uZmVyZW5jZXMiLCAicHVibGljYXRpb25zIiwgInF1YW50dW1fZm91bmRhdGlvbnMiLCAiYmxhY2tfaG9sZV9zdGFiaWxpdHkiXSwgImRlc2NyaXB0aW9uIjogIkludml0ZWQgcHJlc2VudGF0aW9ucyBhdCBsZWFkaW5nIHJlc2VhcmNoIGluc3RpdHV0aW9ucyBpbiBJbmRpYSBhbmQgR2VybWFueS4gR2F2ZSB0YWxrcyBvbiBcIlRoZSBBcmV0YWtpcyBpbnN0YWJpbGl0eSBvZiBleHRyZW1hbCBhc3ltcHRvdGljYWxseSBBZFMgYmxhY2sgaG9sZXNcIiBhdCBDaGVubmFpIE1hdGhlbWF0aWNhbCBJbnN0aXR1dGUgYW5kIEluc3RpdHV0ZSBvZiBNYXRoZW1hdGljYWwgU2NpZW5jZXMgKDIwMTkpLCBzaGFyaW5nIG15IFBoRCByZXNlYXJjaCBmaW5kaW5ncyB3aXRoIHRoZSBJbmRpYW4gdGhlb3JldGljYWwgcGh5c2ljcyBjb21tdW5pdHkuIEVhcmxpZXIgcHJlc2VudGVkIHdvcmsgb24gcXVhbnR1bSBtZWNoYW5pY3MgZm91bmRhdGlvbnMgYXQgTHVkd2lnIE1heGltaWxpYW5zIFVuaXZlcnNpdHksIE11bmljaCAoMjAxNCkgb24gXCJUaGUgdGltZSBvcGVyYXRvciBhbmQgdGhlIHRpbWUtZW5lcmd5IHVuY2VydGFpbnR5IHJlbGF0aW9uIGluIHF1YW50dW0gbWVjaGFuaWNzXCIgZHVyaW5nIG15IG1hc3RlcidzIHRoZXNpcyBwZXJpb2QuXG4ifSwgeyJpZCI6ICJ1b2ZhX2VkdWNhdGlvbiIsICJsYWJlbCI6ICJVbml2ZXJzaXR5IG9mIEFyaXpvbmEiLCAibGF5ZXIiOiAicGVyc29uYWwiLCAic2l6ZSI6IDEzLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNSwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsiYml0c19lZHVjYXRpb24iLCAidHVjc29uIiwgInNhbV9ncmFsbGEiLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJQaEQgaW4gUGh5c2ljcyB1bmRlciBTYW11ZWwgRS4gR3JhbGxhLCBmb2N1c2luZyBvbiBleHRyZW1hbCBibGFjayBob2xlIGhvcml6b24gaW5zdGFiaWxpdGllcy4gQWxzbyBjb21wbGV0ZWQgTWFzdGVyIG9mIFNjaWVuY2UgaW4gUGh5c2ljcyBhcyBwYXJ0IG9mIHRoZSBkb2N0b3JhbCBwcm9ncmFtLiJ9LCB7ImlkIjogImJpdHNfZWR1Y2F0aW9uIiwgImxhYmVsIjogIkJJVFMgUGlsYW5pIiwgImxheWVyIjogInBlcnNvbmFsIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMDksICJlbmQiOiAyMDE0fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IGZhbHNlLCAicGFyZW50X25vZGUiOiBbImh5ZGVyYWJhZCIsICJjYWxjdWx1cyIsICJsaW5lYXJfYWxnZWJyYSIsICJjb21wbGV4X2FuYWx5c2lzIl0sICJkZXNjcmlwdGlvbiI6ICJJbnRlZ3JhdGVkIE1hc3RlciBvZiBTY2llbmNlIGluIFBoeXNpY3MgKEhvbm9ycykgYW5kIEJhY2hlbG9yIG9mIFBoYXJtYWN5IChIb25vcnMpIGZyb20gQmlybGEgSW5zdGl0dXRlIG9mIFRlY2hub2xvZ3kgYW5kIFNjaWVuY2VzLCBQaWxhbmksIEh5ZGVyYWJhZC4ifSwgeyJpZCI6ICJncmFkdWF0ZV9yZXNlYXJjaCIsICJsYWJlbCI6ICJHcmFkdWF0ZSBSZXNlYXJjaCAtIFVvZkEiLCAibGF5ZXIiOiAicGh5c2ljcyIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE1LCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInVvZmFfZWR1Y2F0aW9uIiwgImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInB5dGhvbiIsICJtYXRoZW1hdGljYSJdLCAiZGVzY3JpcHRpb24iOiAiR3JhZHVhdGUgUmVzZWFyY2ggQXNzb2NpYXRlIGludmVzdGlnYXRpbmcgZXh0cmVtYWwgYmxhY2sgaG9sZSBob3Jpem9uIGluc3RhYmlsaXRpZXMuIERpc2NvdmVyZWQgY29ubmVjdGlvbnMgYmV0d2VlbiBncmF2aXRhdGlvbmFsIHBoeXNpY3MgYW5kIHNlbWktbG9jYWwgcXVhbnR1bSBjcml0aWNhbGl0eSwgaWRlbnRpZmllZCBwaHlzaWNhbCBtZWNoYW5pc21zIGludm9sdmluZyBudWxsIGdlb2Rlc2ljcywgYW5kIGRldmVsb3BlZCBjb21wdXRhdGlvbmFsIG1ldGhvZHMgdXNpbmcgTWF0aGVtYXRpY2EgYW5kIFB5dGhvbiBvbiBzdXBlcmNvbXB1dGVycy4ifSwgeyJpZCI6ICJtYXN0ZXJzX3RoZXNpc19sbXUiLCAibGFiZWwiOiAiTWFzdGVyJ3MgVGhlc2lzIC0gTE1VIE11bmljaCIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTMsICJlbmQiOiAyMDE0fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImRldGxlZl9kdXJyIiwgIm11bmljaCIsICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgImxhdGV4Il0sICJkZXNjcmlwdGlvbiI6ICJSZXNlYXJjaCBvbiBhcnJpdmFsIHRpbWUgZGlzdHJpYnV0aW9ucyBpbiBxdWFudHVtIHRoZW9yeSwgY2lyY3VtdmVudGluZyBQYXVsaSdzIHRoZW9yZW0gdG8gZGVzY3JpYmUgYXJyaXZhbCB0aW1lIHN0YXRpc3RpY3MsIGFuZCBleHBsb3JpbmcgcmVub3JtYWxpemF0aW9uIGluIFF1YW50dW0gRWxlY3Ryb2R5bmFtaWNzIHVzaW5nIFdoZWVsZXItRmV5bm1hbiBFbGVjdHJvZHluYW1pY3MgaWRlYXMuIn0sIHsiaWQiOiAidGVhY2hpbmdfdW9mYSIsICJsYWJlbCI6ICJUZWFjaGluZyAtIFVuaXZlcnNpdHkgb2YgQXJpem9uYSIsICJsYXllciI6ICJwaHlzaWNzIiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNSwgImVuZCI6IDIwMjB9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJ1b2ZhX2VkdWNhdGlvbiIsICJ0dWNzb24iLCAiY2FsY3VsdXMiLCAibGluZWFyX2FsZ2VicmEiXSwgImRlc2NyaXB0aW9uIjogIkdyYWR1YXRlIFRlYWNoaW5nIEFzc29jaWF0ZSBmb3IgaW50cm9kdWN0b3J5IGFuZCBpbnRlcm1lZGlhdGUgcGh5c2ljcyBjb3Vyc2VzIGluY2x1ZGluZyBtZWNoYW5pY3MsIGVsZWN0cm9tYWduZXRpc20sIGxhYm9yYXRvcnkgd29yaywgYW5kIGhvbm9ycyBzZWN0aW9ucy4gVGF1Z2h0IGFjcm9zcyBtdWx0aXBsZSBzZW1lc3RlcnMgZnJvbSAyMDE1LTIwMjEuIn0sIHsiaWQiOiAiZmFzY2luYXRpb25fbGVhcm5pbmciLCAibGFiZWwiOiAiRmFzY2luYXRpb24gQmFzZWQgTGVhcm5pbmciLCAibGF5ZXIiOiAiYXBwbGljYXRpb25zIiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMywgImVuZCI6IDIwMTR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbIm11bmljaCIsICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAiYm90dG9tX3VwX2FwcHJvYWNoIl0sICJkZXNjcmlwdGlvbiI6ICJDby1mb3VuZGluZyB0ZWFtIG1lbWJlciBvZiBNdW5pY2gtYmFzZWQgc3RhcnR1cCBjcmVhdGluZyBmYXNjaW5hdGlvbi1iYXNlZCBsZWFybmluZyBwbGF0Zm9ybS4gUHJvZHVjZWQgcGVkYWdvZ2ljYWwgY29udGVudCBhbmQgY29vcmRpbmF0ZWQgd2l0aCBpbnRlcmRpc2NpcGxpbmFyeSB0ZWFtIHRvIGRldmVsb3AgTVZQIGNvbWJpbmluZyBsaW5lYXIgYW5kIG5vbi1saW5lYXIgcGVkYWdvZ3kgYXBwcm9hY2hlcy4ifSwgeyJpZCI6ICJ0dXJub19leHBlcmllbmNlIiwgImxhYmVsIjogIlR1cm5vIC0gTWFya2V0cGxhY2UgRGF0YSBTY2llbnRpc3QiLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogZmFsc2UsICJwYXJlbnRfbm9kZSI6IFsidmFuY291dmVyIiwgInJvdmVyX2V4cGVyaWVuY2UiLCAicmVjb21tZW5kYXRpb25fc3lzdGVtcyIsICJnYW1lX3RoZW9yeSIsICJtYXJrZXRwbGFjZXMiXSwgImRlc2NyaXB0aW9uIjogIk1hcmtldHBsYWNlIERhdGEgU2NpZW50aXN0IGJ1aWxkaW5nIGFuYWx5dGljcyBmcmFtZXdvcmtzIGZvciBzdXBwbHktZGVtYW5kIGhlYWx0aCBhbmFseXNpcywgcmVjb21tZW5kYXRpb24gc3lzdGVtcyBhY2hpZXZpbmcgNDAlIGZ1bm5lbCBjb252ZXJzaW9uIGxpZnQsIGFuZCBjdXN0b21lciBsaWZldGltZSB2YWx1ZSBwcmVkaWN0aW9uIG1vZGVscy4gRGV2ZWxvcGVkIGVuZC10by1lbmQgTUwgZnJhbWV3b3JrcyBmcm9tIGlkZWF0aW9uIHRocm91Z2ggZGVwbG95bWVudCBhbmQgbW9uaXRvcmluZyBmb3IgbWFya2V0cGxhY2Ugb3B0aW1pemF0aW9uLiJ9LCB7ImlkIjogInJvdmVyX2V4cGVyaWVuY2UiLCAibGFiZWwiOiAiUm92ZXIgLSBEYXRhIFNjaWVudGlzdCBJSSAmIElJSSIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiAxOCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjEsICJlbmQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IGZhbHNlLCAicGFyZW50X25vZGUiOiBbImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAic2VhdHRsZSIsICJzY2hudWNraSIsICJtYXJrZXRwbGFjZXMiLCAicHl0aG9uIiwgInNxbCJdLCAiZGVzY3JpcHRpb24iOiAiSSB3YXMgYSBEYXRhIFNjaWVudGlzdCBpbiB0aGUgc3VwcGx5IG1hbmFnZW1lbnQgdGVhbSwgZGV2ZWxvcGluZyBmb3JlY2FzdGluZyBhbmQgTWFya292IENoYWluIG1vZGVscyBmb3Igc3VwcGx5LWRlbWFuZCBvcHRpbWl6YXRpb24gYWNyb3NzIGdsb2JhbCBwZXQgc2VydmljZXMgbWFya2V0cywgZHJpdmluZyA0JSBhbm51YWwgcmV2ZW51ZSBpbmNyZWFzZS4gQnVpbHQgcmVjb21tZW5kYXRpb24gYWxnb3JpdGhtcywgRVRMIHBpcGVsaW5lcywgYWdlbnQtYmFzZWQgbW9kZWxzIGZvciBzdHJhdGVnaWMgcGxhbm5pbmcsIGFuZCBkZXBsb3llZCBMTE0gc29sdXRpb25zIGZvciB0aGUgVHJ1c3QgJiBTYWZldHkgdGVhbS4ifSwgeyJpZCI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIiwgImxhYmVsIjogIlRoZSBEYXRhIEluY3ViYXRvciAtIEZlbGxvd3NoaXAiLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIxLCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiBmYWxzZSwgInBhcmVudF9ub2RlIjogWyJ1b2ZhX2VkdWNhdGlvbiIsICJweXRob24iLCAic3RhdGlzdGljcyIsICJ0b3BfZG93bl9hcHByb2FjaCIsICJzZWF0dGxlIl0sICJkZXNjcmlwdGlvbiI6ICJJbnRlbnNpdmUgZGF0YSBzY2llbmNlIGZlbGxvd3NoaXAgcHJvZ3JhbSBmb3IgU1RFTSBQaERzLiBDb21wbGV0ZWQgY2Fwc3RvbmUgcHJvamVjdCBvbiBTb3V0aCBJbmRpYW4gY2xhc3NpY2FsIG11c2ljIHJhZ2FtIGlkZW50aWZpY2F0aW9uIHVzaW5nIG1hY2hpbmUgbGVhcm5pbmcsIGFjaGlldmluZyA3NSUgYWNjdXJhY3kgb24gMTAtY2xhc3MgY2xhc3NpZmljYXRpb24uIERldmVsb3BlZCBGbGFzayB3ZWIgYXBwbGljYXRpb24gYW5kIHdvcmtlZCBvbiB0cmFuc2ZlciBsZWFybmluZyB3aXRoIENOTnMgZm9yIGltYWdlIGNsYXNzaWZpY2F0aW9uLiJ9LCB7ImlkIjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAibGFiZWwiOiAiUGVydHVyYmF0aW9uIFRoZW9yeSIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNSwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYmxhY2tfaG9sZV9zdGFiaWxpdHkiLCAiY29tcGxleF9hbmFseXNpcyIsICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAiZm91cmllcl9sYXBsYWNlIl0sICJkZXNjcmlwdGlvbiI6ICJTeXN0ZW1hdGljIG1ldGhvZCBmb3IgZmluZGluZyBhcHByb3hpbWF0ZSBzb2x1dGlvbnMgdG8gcHJvYmxlbXMgdGhhdCBjYW5ub3QgYmUgc29sdmVkIGV4YWN0bHksIGVzc2VudGlhbCBmb3IgYmxhY2sgaG9sZSBwaHlzaWNzIGNhbGN1bGF0aW9ucywgd2hlcmUgbm9uLWxpbmVhciBiZWhhdmlvciBpcyBoaWdobHkgaW50cmFjdGFibGUuIn0sIHsiaWQiOiAiY29tcGxleF9hbmFseXNpcyIsICJsYWJlbCI6ICJDb21wbGV4IEFuYWx5c2lzIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDYsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDEyLCAiZW5kIjogMjAxOH0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJiaXRzX2VkdWNhdGlvbiIsICJjYWxjdWx1cyIsICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJmb3VyaWVyX2xhcGxhY2UiXSwgImRlc2NyaXB0aW9uIjogIlRoZW9yeSBvZiBmdW5jdGlvbnMgb2YgY29tcGxleCB2YXJpYWJsZXMsIGNyaXRpY2FsIGZvciBhZHZhbmNlZCBwaHlzaWNzIGFuZCBtYXRoZW1hdGljYWwgbW9kZWxpbmcuIE1vc3Qgb2YgbXkgcmVzZWFyY2ggb24gT0RFcyBpbiBibGFjayBob2xlIHNwYWNldGltZXMgaW52b2x2ZWQgY29tcGxleCBhbmFseXNpcyB0ZWNobmlxdWVzLiJ9LCB7ImlkIjogInNwZWNpYWxfZnVuY3Rpb25zIiwgImxhYmVsIjogIlNwZWNpYWwgRnVuY3Rpb25zICYgT0RFcyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiA3LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxNCwgImVuZCI6IDIwMTl9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiY29tcGxleF9hbmFseXNpcyIsICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgIm1hdGhlbWF0aWNhIiwgInB5dGhvbiJdLCAiZGVzY3JpcHRpb24iOiAiSHlwZXJnZW9tZXRyaWMgZnVuY3Rpb25zLCBXaGl0dGFrZXIgRnVuY3Rpb25zLCBIYW5rZWwgZnVuY3Rpb25zLCBCZXNzZWwgZnVuY3Rpb25zLCBhbW9uZ3N0IG1hbnkgb3RoZXJzLCBhbmQgZGlmZmVyZW50aWFsIGVxdWF0aW9uIHRlY2huaXF1ZXMgZm9yIHNvbHZpbmcgcGh5c2ljcyBwcm9ibGVtcy4gTW9zdCBvZiBteSByZXNlYXJjaCBpbnZvbHZlZCB0aGUgc3R1ZHkgb2YgdGhlc2Ugc3BlY2lhbCBmdW5jdGlvbnMuIn0sIHsiaWQiOiAiZm91cmllcl9sYXBsYWNlIiwgImxhYmVsIjogIkZvdXJpZXIgJiBMYXBsYWNlIFRyYW5zZm9ybXMiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTEsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDExfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImNvbXBsZXhfYW5hbHlzaXMiLCAicGVydHVyYmF0aW9uX3RoZW9yeSIsICJpc2FpX3Byb2plY3QiLCAidGltZV9zZXJpZXNfZm9yZWNhc3RpbmciXSwgImRlc2NyaXB0aW9uIjogIkZyZXF1ZW5jeSBkb21haW4gYW5hbHlzaXMgYW5kIGludGVncmFsIHRyYW5zZm9ybXMsIGJyaWRnaW5nIHBoeXNpY3MgYW5kIGRhdGEgc2NpZW5jZSBhcHBsaWNhdGlvbnMuIFVzZWQgZXh0ZW5zaXZlbHkgaW4gYmxhY2sgaG9sZSBwZXJ0dXJiYXRpb24gdGhlb3J5IGFuZCB0aW1lIHNlcmllcyBhbmFseXNpcyBvZiBhdWRpbyBkYXRhLiJ9LCB7ImlkIjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJsYWJlbCI6ICJEaWZmZXJlbnRpYWwgR2VvbWV0cnkiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogOSwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTQsICJlbmQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInVvZmFfZWR1Y2F0aW9uIiwgImxpbmVhcl9hbGdlYnJhIiwgImNhbGN1bHVzIiwgInNhbV9ncmFsbGEiXSwgImRlc2NyaXB0aW9uIjogIk1hdGhlbWF0aWNhbCBmcmFtZXdvcmsgZm9yIGdlbmVyYWwgcmVsYXRpdml0eSBhbmQgY3VydmVkIHNwYWNldGltZSBwaHlzaWNzLiJ9LCB7ImlkIjogImNhbGN1bHVzIiwgImxhYmVsIjogIkNhbGN1bHVzIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDgsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDA5fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYml0c19lZHVjYXRpb24iLCAibWFnbmV0aWNfbW9ub3BvbGVzIiwgImNvbXBsZXhfYW5hbHlzaXMiLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5Il0sICJkZXNjcmlwdGlvbiI6ICJGdW5kYW1lbnRhbCBtYXRoZW1hdGljYWwgdG9vbCB1bmRlcmx5aW5nIGFsbCBxdWFudGl0YXRpdmUgYW5hbHlzaXMuIn0sIHsiaWQiOiAibGluZWFyX2FsZ2VicmEiLCAibGFiZWwiOiAiTGluZWFyIEFsZ2VicmEiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogOCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMDl9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJiaXRzX2VkdWNhdGlvbiIsICJjYWxjdWx1cyIsICJweXRob24iLCAiY2xhc3NpZmljYXRpb24iLCAicmVncmVzc2lvbiJdLCAiZGVzY3JpcHRpb24iOiAiTWF0cml4IG9wZXJhdGlvbnMgYW5kIHZlY3RvciBzcGFjZXMsIGVzc2VudGlhbCBmb3IgcXVhbnR1bSBwaHlzaWNzLCBtYWNoaW5lIGxlYXJuaW5nIGFuZCBkYXRhIGFuYWx5c2lzLiJ9LCB7ImlkIjogInN0YXRpc3RpY3MiLCAibGFiZWwiOiAiU3RhdGlzdGljcyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjB9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJiYXllc2lhbl9zdGF0aXN0aWNzIiwgInB5dGhvbiJdLCAiZGVzY3JpcHRpb24iOiAiTWF0aGVtYXRpY2FsIGZvdW5kYXRpb24gZm9yIGRhdGEgYW5hbHlzaXMsIGh5cG90aGVzaXMgdGVzdGluZywgYW5kIHVuY2VydGFpbnR5IHF1YW50aWZpY2F0aW9uLiJ9LCB7ImlkIjogImdhbWVfdGhlb3J5IiwgImxhYmVsIjogIkdhbWUgVGhlb3J5IiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDcsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJ0dXJub19leHBlcmllbmNlIiwgImRlY2lzaW9uX21ha2luZ19hZ2VudHMiLCAiYXVjdGlvbnNfZGVzaWduIiwgIm1hcmtldHBsYWNlcyJdLCAiZGVzY3JpcHRpb24iOiAiTWF0aGVtYXRpY2FsIGZyYW1ld29yayBmb3Igc3RyYXRlZ2ljIGRlY2lzaW9uLW1ha2luZyBhbmQgbXVsdGktYWdlbnQgaW50ZXJhY3Rpb25zLiBJJ3ZlIGJlZW4gaW50ZXJlc3RlZCBpbiB0aGlzIGFyZWEgYmVjYXVzZSBvZiBteSBpbnRlcmVzdCBpbiBtYXJrZXRwbGFjZSBlY29ub21pY3MgYW5kIGdhbWUtcGxheS4ifSwgeyJpZCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgImxhYmVsIjogIlJlY29tbWVuZGF0aW9uIFN5c3RlbXMiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTQsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJweXRob24iLCAiY2xhc3NpZmljYXRpb24iLCAibGVhcm5fdG9fcmFuayJdLCAiZGVzY3JpcHRpb24iOiAiQWxnb3JpdGhtcyBmb3IgbWF0Y2hpbmcgdXNlcnMgd2l0aCByZWxldmFudCBjb250ZW50IG9yIHNlcnZpY2VzIGluIG1hcmtldHBsYWNlIHNldHRpbmdzLiBJIHRyYWluZWQgYW5kIGRlcGxveWVkIGNvbXBvbmVudHMgb2YgYSByZWNvbW1lbmRhdGlvbiBzeXN0ZW0gYXQgUm92ZXIsIGFuZCBhbmFseXplZCBleHBlcmltZW50cyBiZWZvcmUgcm9sbGluZyBvdXQgdGhlIHN5c3RlbSB0byBhbGwgdXNlcnMuIEF0IFR1cm5vLCBJIGJ1aWx0IGZyb20gZW5kIHRvIGVuZCwgdGhlIGVudGlyZSByZWNvbW1lbmRhdGlvbiBzeXN0ZW0gZnJhbWV3b3JrIGZvciByYW5raW5nIHNlcnZpY2UgcHJvdmlkZXJzIGF0IHNlYXJjaCwgaWUuIGlkZWF0aW9uIC0+IGZlYXR1cmUgZW5naW5lZXJpbmcgLT4gbW9kZWwgdHJhaW5pbmcgLT4gZGVwbG95bWVudCAtPiB0ZXN0aW5nIC0+IG1vbml0b3JpbmcuIn0sIHsiaWQiOiAiY2x1c3RlcmluZ19hbGdvcml0aG1zIiwgImxhYmVsIjogIkNsdXN0ZXJpbmcgQWxnb3JpdGhtcyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJweXRob24iLCAiZ2Vvc3BhdGlhbF9hbmFseXNpcyIsICJzZW1hbnRpY19zZWFyY2giXSwgImRlc2NyaXB0aW9uIjogIlVuc3VwZXJ2aXNlZCBsZWFybmluZyBtZXRob2RzIGZvciBkaXNjb3ZlcmluZyBwYXR0ZXJucyBhbmQgZ3JvdXBpbmdzIGluIGRhdGEuIEkgdXNlZCBjbHVzdGVyaW5nIHRlY2huaXF1ZXMgdG8gZGVmaW5lIHJlYXNvbmFibGUgbWFya2V0IGJvdW5kYXJpZXMgZm9yIHN1cHBseS1kZW1hbmQgZm9yZWNhc3RpbmcgYXQgVHVybm8uIn0sIHsiaWQiOiAiY2xhc3NpZmljYXRpb24iLCAibGFiZWwiOiAiQ2xhc3NpZmljYXRpb24iLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTMsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJweXRob24iLCAibGluZWFyX2FsZ2VicmEiLCAic3RhdGlzdGljcyIsICJpc2FpX3Byb2plY3QiXSwgImRlc2NyaXB0aW9uIjogIlN1cGVydmlzZWQgbGVhcm5pbmcgdGVjaG5pcXVlcyBmb3IgcHJlZGljdGluZyBjYXRlZ29yaWNhbCBvdXRjb21lcy4gVXNlZCBhY3Jvc3MgYSB2YXJpZXR5IG9mIGFwcGxpY2F0aW9ucyBhdCBSb3ZlciBhbmQgVHVybm8uIn0sIHsiaWQiOiAicmVncmVzc2lvbiIsICJsYWJlbCI6ICJSZWdyZXNzaW9uIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDE0LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAicHl0aG9uIiwgImxpbmVhcl9hbGdlYnJhIiwgInN0YXRpc3RpY3MiLCAicHJpY2luZ19lbGFzdGljaXR5Il0sICJkZXNjcmlwdGlvbiI6ICJTdGF0aXN0aWNhbCBtZXRob2RzIGZvciBtb2RlbGluZyByZWxhdGlvbnNoaXBzIGJldHdlZW4gdmFyaWFibGVzIGFuZCBwcmVkaWN0aW5nIGNvbnRpbnVvdXMgb3V0Y29tZXMuIFVzZWQgZXh0ZW5zaXZlbHkgZm9yIHZhcmlvdXMgYXBwbGljYXRpb25zIGF0IFJvdmVyIGFuZCBUdXJuby4ifSwgeyJpZCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJsYWJlbCI6ICJUaW1lIFNlcmllcyBGb3JlY2FzdGluZyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxMiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJyb3Zlcl9leHBlcmllbmNlIiwgInB5dGhvbiIsICJzdGF0aXN0aWNzIiwgImZvdXJpZXJfbGFwbGFjZSIsICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0Il0sICJkZXNjcmlwdGlvbiI6ICJQcmVkaWN0aW5nIGZ1dHVyZSB2YWx1ZXMgYmFzZWQgb24gaGlzdG9yaWNhbCB0ZW1wb3JhbCBwYXR0ZXJucywgY3J1Y2lhbCBmb3IgZGVtYW5kIGZvcmVjYXN0aW5nLiBVc2VkIFByb3BoZXQgYW5kIEFSSU1BIG1vZGVscyB0byBmb3JlY2FzdCBzdXBwbHkgYW5kIGRlbWFuZCBhdCBSb3Zlci4gQ29uZHVjdGVkIGV4dGVuc2l2ZSBiYWNrdGVzdGluZyBhbmQgbW9kZWwgdmFsaWRhdGlvbiB0byBlbnN1cmUgcm9idXN0IHBlcmZvcm1hbmNlLiJ9LCB7ImlkIjogIm1hcmtvdl9jaGFpbl9tb2RlbHMiLCAibGFiZWwiOiAiTWFya292IENoYWluIE1vZGVscyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxNCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjIsICJlbmQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAic3RhdGlzdGljcyIsICJweXRob24iLCAic3VwcGx5X2RlbWFuZF9mb3JlY2FzdCJdLCAiZGVzY3JpcHRpb24iOiAiU3RvY2hhc3RpYyBwcm9jZXNzZXMgZm9yIG1vZGVsaW5nIHNlcXVlbnRpYWwgYmVoYXZpb3IgYW5kIHN0YXRlIHRyYW5zaXRpb25zLiBUaGUgc3VwcGx5IGZ1bm5lbCBhdCBSb3ZlciB3YXMgbW9kZWxlZCBhcyBhIE1hcmtvdiBDaGFpbiwgYWxsb3dpbmcgdXMgdG8gYWNjdXJhdGVseSBmb3JlY2FzdCB0aGUgYW1vdW50IG9mIHN1cHBseSBpbiBhIG1hcmtldCB0byB0YWNrbGUgdGhlIGZvcmVjYXN0ZWQgZGVtYW5kLiJ9LCB7ImlkIjogImxlYXJuX3RvX3JhbmsiLCAibGFiZWwiOiAiTGVhcm4gdG8gUmFuayIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiA3LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyNH0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAiZXhwZXJpZW5jZUxldmVsIjogImludGVyZXN0ZWQiLCAicGFyZW50X25vZGUiOiBbInJlY29tbWVuZGF0aW9uX3N5c3RlbXMiLCAicHl0aG9uIiwgImNsYXNzaWZpY2F0aW9uIl0sICJkZXNjcmlwdGlvbiI6ICJNYWNoaW5lIGxlYXJuaW5nIHRlY2huaXF1ZXMgZm9yIG9yZGVyaW5nIGFuZCByYW5raW5nIGl0ZW1zIGluIHJlY29tbWVuZGF0aW9uIHN5c3RlbXMuIEkgbGVhcm50IGFib3V0IHRoaXMgZHVyaW5nIG15IGxhc3QgZmV3IG1vbnRocyBhdCBSb3ZlciwgYW5kIHdvdWxkIGxvdmUgdG8gYmUgYWJsZSB0byB3b3JrIG9uIHRoaXMgaW4gbW9yZSBkZXB0aCBpbiB0aGUgZnV0dXJlLiJ9LCB7ImlkIjogImFnZW50X2Jhc2VkX21vZGVsbGluZyIsICJsYWJlbCI6ICJBZ2VudCBCYXNlZCBNb2RlbGxpbmciLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIzfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYm90dG9tX3VwX2FwcHJvYWNoIiwgInB5dGhvbiIsICJlcGlkZW1pY19zaW11bGF0aW9uIiwgImRlY2lzaW9uX21ha2luZ19hZ2VudHMiXSwgImRlc2NyaXB0aW9uIjogIlNpbXVsYXRpbmcgY29tcGxleCBzeXN0ZW1zIGJ5IG1vZGVsaW5nIGluZGl2aWR1YWwgYWdlbnRzIGFuZCB0aGVpciBpbnRlcmFjdGlvbnMuIn0sIHsiaWQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJsYWJlbCI6ICJFeHBlcmltZW50YWwgRGVzaWduIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDE1LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJzdGF0aXN0aWNzIiwgImJheWVzaWFuX3N0YXRpc3RpY3MiLCAibWFya2V0cGxhY2VfaW5mbGF0aW9uX3JlY3MiXSwgImRlc2NyaXB0aW9uIjogIlN0YXRpc3RpY2FsIHByaW5jaXBsZXMgZm9yIGRlc2lnbmluZyB2YWxpZCBleHBlcmltZW50cyBhbmQgY29udHJvbGxpbmcgZm9yIGNvbmZvdW5kaW5nIGZhY3RvcnMuIFNvbWV0aW1lcyB0aGUgZXhwZXJpbWVudGFsIGRlc2lnbiBpbiB0ZWNoIHByb2R1Y3RzIGNhbiBiZSBzdHJhaWdodGZvcndhcmQgd2hlcmUgeW91IHNpbXBseSByYW5kb21pemUgdXNlcnMgaW50byB0cmVhdG1lbnQgYW5kIGNvbnRyb2wgZ3JvdXBzLCBidXQgb2Z0ZW4gdGhlcmUgYXJlIGNvbXBsaWNhdGlvbnMgbGlrZSBpbnRlcmZlcmVuY2UgYmV0d2VlbiB1c2VycywgYW5kL29yIGZlZWRiYWNrIGxvb3BzIGluIHBsYXkgdGhhdCBuZWVkIHRvIGJlIGFjY291bnRlZCBmb3IgaW4gdGhlIGRlc2lnbmluZyBvZiB0aGUgZXhwZXJpbWVudC4gSSBoYXZlIGV4cGVyaWVuY2UgZGVhbGluZyB3aXRoIHRoZXNlIGNvbXBsZXhpdGllcyBpbiByZWFsLXdvcmxkIEEvQiB0ZXN0cy4ifSwgeyJpZCI6ICJleHBlcmltZW50YXRpb24iLCAibGFiZWwiOiAiRXhwZXJpbWVudGF0aW9uIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDE0LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJleHBlcmltZW50YWxfZGVzaWduIiwgInN0YXRpc3RpY3MiLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJBL0IgdGVzdGluZyBhbmQgY2F1c2FsIGluZmVyZW5jZSBpbiBwcm9kdWN0IGNoYW5nZXMgYXMgd2VsbCBhcyBhbGdvcml0aG0gY2hhbmdlcyBmb3IgbWVhc3VyaW5nIHByb2R1Y3QgaW1wYWN0IGFuZCBtYWtpbmcgZGF0YS1kcml2ZW4gZGVjaXNpb25zLiJ9LCB7ImlkIjogImJheWVzaWFuX3N0YXRpc3RpY3MiLCAibGFiZWwiOiAiQmF5ZXNpYW4gU3RhdGlzdGljcyIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxMSwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJzdGF0aXN0aWNzIiwgImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAibHR2X21vZGVsaW5nIl0sICJkZXNjcmlwdGlvbiI6ICJQcm9iYWJpbGlzdGljIGFwcHJvYWNoIHRvIGluZmVyZW5jZSB0aGF0IGluY29ycG9yYXRlcyBwcmlvciBrbm93bGVkZ2UgYW5kIHVwZGF0ZXMgYmVsaWVmcyB3aXRoIGV2aWRlbmNlLiJ9LCB7ImlkIjogImxhdGV4IiwgImxhYmVsIjogIkxhVGVYIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDUsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDExfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImJpdHNfZWR1Y2F0aW9uIiwgInF1YW50dW1fZm91bmRhdGlvbnMiLCAicHVibGljYXRpb25zIiwgImNvbmZlcmVuY2VzIl0sICJkZXNjcmlwdGlvbiI6ICJEb2N1bWVudCBwcmVwYXJhdGlvbiBzeXN0ZW0gZm9yIGFjYWRlbWljIHdyaXRpbmcgYW5kIG1hdGhlbWF0aWNhbCB0eXBlc2V0dGluZy4ifSwgeyJpZCI6ICJtYXRoZW1hdGljYSIsICJsYWJlbCI6ICJNYXRoZW1hdGljYSIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiA2LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAxMn0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJiaXRzX2VkdWNhdGlvbiIsICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJjb21wbGV4X2FuYWx5c2lzIl0sICJkZXNjcmlwdGlvbiI6ICJDb21wdXRhdGlvbmFsIHNvZnR3YXJlIGZvciBzeW1ib2xpYyBtYXRoZW1hdGljcyBhbmQgbnVtZXJpY2FsIGFuYWx5c2lzLiJ9LCB7ImlkIjogInB5dGhvbiIsICJsYWJlbCI6ICJQeXRob24iLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTEsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE1fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInVvZmFfZWR1Y2F0aW9uIiwgImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAicm92ZXJfZXhwZXJpZW5jZSIsICJsaW5lYXJfYWxnZWJyYSJdLCAiZGVzY3JpcHRpb24iOiAiUHJpbWFyeSBwcm9ncmFtbWluZyBsYW5ndWFnZSBmb3IgZGF0YSBzY2llbmNlLCBtYWNoaW5lIGxlYXJuaW5nLCBhbmQgc2NpZW50aWZpYyBjb21wdXRpbmcuIn0sIHsiaWQiOiAic3FsIiwgImxhYmVsIjogIlNRTCIsICJsYXllciI6ICJ0b29sa2l0IiwgInNpemUiOiAxMSwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJyb3Zlcl9leHBlcmllbmNlIiwgImRhdGFfZW5naW5lZXJpbmciXSwgImRlc2NyaXB0aW9uIjogIkRhdGFiYXNlIHF1ZXJ5IGxhbmd1YWdlIGVzc2VudGlhbCBmb3IgZGF0YSBleHRyYWN0aW9uIGFuZCBtYW5pcHVsYXRpb24uIEkgdXNlZCBTUUwgZXh0ZW5zaXZlbHkgaW4gbXkgcm9sZXMgYXQgUm92ZXIgYW5kIFR1cm5vIGZvciBxdWVyeWluZyBsYXJnZSBkYXRhc2V0cywgYnVpbGRpbmcgRVRMIHBpcGVsaW5lcywgYW5kIHBlcmZvcm1pbmcgZGF0YSBhbmFseXNpcyB0byBpbmZvcm0gYnVzaW5lc3MgZGVjaXNpb25zLiJ9LCB7ImlkIjogImdpdCIsICJsYWJlbCI6ICJHaXQiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE4fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInVvZmFfZWR1Y2F0aW9uIiwgInB5dGhvbiIsICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIl0sICJkZXNjcmlwdGlvbiI6ICJWZXJzaW9uIGNvbnRyb2wgc3lzdGVtIGZvciBjb2xsYWJvcmF0aXZlIHNvZnR3YXJlIGRldmVsb3BtZW50IGFuZCBjb2RlIG1hbmFnZW1lbnQuIEkndmUgdXNlZCBHaXQgZXh0ZW5zaXZlbHkgdGhyb3VnaG91dCBteSByZXNlYXJjaCBhbmQgZGF0YSBzY2llbmNlIHByb2plY3RzIHRvIG1hbmFnZSBjb2RlIHZlcnNpb25zLCBjb2xsYWJvcmF0ZSB3aXRoIG90aGVycywgYW5kIG1haW50YWluIHJlcHJvZHVjaWJpbGl0eS4ifSwgeyJpZCI6ICJhd3NfZ2NwIiwgImxhYmVsIjogIkFXUy9HQ1AiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTEsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJweXRob24iLCAiZGF0YV9lbmdpbmVlcmluZyJdLCAiZGVzY3JpcHRpb24iOiAiQ2xvdWQgY29tcHV0aW5nIHBsYXRmb3JtcyBmb3Igc2NhbGFibGUgZGF0YSBwcm9jZXNzaW5nIGFuZCBtYWNoaW5lIGxlYXJuaW5nIGRlcGxveW1lbnQuIEkgdXNlZCBBV1MgYXQgUm92ZXIgYW5kIEdDUCBhdCBUdXJubywgZm9yIHZhcmlvdXMgdXNlIGNhc2VzIGluIHRoZSBEYXRhIFNjaWVuY2Ugd29ya2Zsb3dzLiJ9LCB7ImlkIjogImRhZ3N0ZXJfYWlyZmxvdyIsICJsYWJlbCI6ICJEYWdzdGVyL0FpcmZsb3ciLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJweXRob24iLCAiZGF0YV9lbmdpbmVlcmluZyJdLCAiZGVzY3JpcHRpb24iOiAiV29ya2Zsb3cgb3JjaGVzdHJhdGlvbiB0b29scyBmb3IgbWFuYWdpbmcgY29tcGxleCBkYXRhIHBpcGVsaW5lcyBhbmQgRVRMIHByb2Nlc3Nlcy4gSSd2ZSB1c2VkIERhZ3N0ZXIgZXh0ZW5zaXZlbHkgYXQgVHVybm8gdG8gYnVpbGQgYW5kIG1haW50YWluIGRhdGEgcGlwZWxpbmVzIHRoYXQgcmVxdWlyZSBib3RoIFNRTC1saWtlLCBweXRob24gYmFzZWQgcHJvY2Vzc2luZyBhbmQgZW5kIHVwIGluIE1MIG1vZGVscyB0aGF0IGFyZSBkZXBsb3llZCB0byBwcm9kdWN0aW9uLiJ9LCB7ImlkIjogImRidCIsICJsYWJlbCI6ICJEQlQiLCAibGF5ZXIiOiAidG9vbGtpdCIsICJzaXplIjogMTMsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJzcWwiLCAiZGF0YV9lbmdpbmVlcmluZyJdLCAiZGVzY3JpcHRpb24iOiAiRGF0YSB0cmFuc2Zvcm1hdGlvbiB0b29sIGZvciBidWlsZGluZyByZWxpYWJsZSBkYXRhIG1vZGVscyBhbmQgYW5hbHl0aWNzIHdvcmtmbG93cy4gTXkgZXhwZXJpZW5jZSB3aXRoIERCVCBpcyBleHRlbnNpdmUsIGhhdmluZyB1c2VkIGl0IGF0IGJvdGggUm92ZXIgYW5kIFR1cm5vIHRvIGNyZWF0ZSBtb2R1bGFyLCB0ZXN0YWJsZSBkYXRhIHRyYW5zZm9ybWF0aW9ucyB0aGF0IGZvcm0gdGhlIGJhY2tib25lIG9mIG91ciBhbmFseXRpY3MgYW5kIG1hY2hpbmUgbGVhcm5pbmcgcGlwZWxpbmVzLiJ9LCB7ImlkIjogInRhYmxlYXVfbW9kZSIsICJsYWJlbCI6ICJUYWJsZWF1L01vZGUvUGVyaXNjb3BlIiwgImxheWVyIjogInRvb2xraXQiLCAic2l6ZSI6IDcsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIxfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJ0dXJub19leHBlcmllbmNlIiwgInNxbCIsICJzdGF0aXN0aWNzIl0sICJkZXNjcmlwdGlvbiI6ICJCdXNpbmVzcyBpbnRlbGxpZ2VuY2UgYW5kIGRhdGEgdmlzdWFsaXphdGlvbiBwbGF0Zm9ybXMgZm9yIGNyZWF0aW5nIGRhc2hib2FyZHMgYW5kIHJlcG9ydHMuIEkgdXNlZCBQZXJpc2NvcGUgYW5kIE1vZGUgYXQgUm92ZXIsIGFuZCBUYWJsZWF1IGF0IFR1cm5vIHRvIGJ1aWxkIGludGVyYWN0aXZlIGRhc2hib2FyZHMgdGhhdCBwcm92aWRlZCBpbnNpZ2h0cyBpbnRvIGtleSBidXNpbmVzcyBtZXRyaWNzIGFuZCBzdXBwb3J0ZWQgZGF0YS1kcml2ZW4gZGVjaXNpb24tbWFraW5nIGFjcm9zcyB0ZWFtcy4ifSwgeyJpZCI6ICJpc2FpX3Byb2plY3QiLCAibGFiZWwiOiAiSXNBSSIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMSwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIiwgInB5dGhvbiIsICJjbGFzc2lmaWNhdGlvbiIsICJmb3VyaWVyX2xhcGxhY2UiLCAiY2x1c3RlcmluZ19hbGdvcml0aG1zIl0sICJkZXNjcmlwdGlvbiI6ICJBcyBhIGNhcm5hdGljIG11c2ljIGVudGh1c2lhc3QsIEkgd2FudGVkIHRvIGJ1aWxkIGEgbW9kZWwgdGhhdCBjYW4gaWRlbnRpZnkgdGhlIFJhZ2FtIG9mIGFueSBnaXZlbiBjbGlwIG9mIG11c2ljLiBJIGJ1aWx0IElzQUksIGEgTWFjaGluZSBsZWFybmluZyBwcm9qZWN0IGZvciBpZGVudGlmeWluZyBTb3V0aCBJbmRpYW4gY2xhc3NpY2FsIG11c2ljIHJhZ2FtcyBmcm9tIGF1ZGlvLCBhY2hpZXZpbmcgNzUlIGFjY3VyYWN5IHVzaW5nIFJOTnMgYW5kIExTVE1zLiJ9LCB7ImlkIjogImVwaWRlbWljX3NpbXVsYXRpb24iLCAibGFiZWwiOiAiU2ltdWxhdGluZyBhbiBFcGlkZW1pYyIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiA4LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMSwgImVuZCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAicHl0aG9uIiwgImJvdHRvbV91cF9hcHByb2FjaCJdLCAiZGVzY3JpcHRpb24iOiAiTXkgZmlyc3QgQWdlbnQtYmFzZWQgbW9kZWxpbmcgcHJvamVjdCwgd2hlcmUgSSBzaW11bGF0ZWQgZGlzZWFzZSBzcHJlYWQgZHluYW1pY3MgZHVyaW5nIHRoZSBDT1ZJRC0xOSBwYW5kZW1pYy4gVGhpcyB3YXMgbXkgZmlyc3QgT2JqZWN0IE9yaWVudGVkIFByb2dyYW1taW5nIGV4ZXJjaXNlIGFzIHdlbGwuIn0sIHsiaWQiOiAic3VwcGx5X2RlbWFuZF9mb3JlY2FzdCIsICJsYWJlbCI6ICJNYXJrZXQgU3VwcGx5LURlbWFuZCBCYWxhbmNlIEZvcmVjYXN0IiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDEyLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMiwgImVuZCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJtYXJrb3ZfY2hhaW5fbW9kZWxzIiwgImdlb3NwYXRpYWxfYW5hbHlzaXMiXSwgImRlc2NyaXB0aW9uIjogIkFzIGEgbWFya2V0cGxhY2UgdGhhdCByZXF1aXJlcyBzdXBwbHkgYW5kIGRlbWFuZCB0byBiZSBpbiBwcm94aW1pdHkgb2Ygb25lIGFub3RoZXIgYXQgUm92ZXIsIG1hbmFnaW5nIHRoZSBzdXBwbHktZGVtYW5kIGJhbGFuY2UgYWNyb3NzIHRoZSBtYXJrZXRwbGFjZSByZXF1aXJlZCBicmVha2luZyBpdCBkb3duIGludG8gbWFuYWdlYWJsZSBtYXJrZXRzLiBBIHdheSBvZiBkb2luZyB0aGlzIHdhcyB0byB1c2UgaW5kZXBlbmRlbnQgbWFya2V0IHN1cHBseSBmb3JlY2FzdCAoVGltZSBzZXJpZXMgRm9yZWNhc3RzICsgTWFya292IENoYWluIE1vZGVscykgYW5kIG1hcmtldCBkZW1hbmQgZm9yZWNhc3QgKFRpbWUgc2VyaWVzIEZvcmVjYXN0cykgbW9kZWxzIHRoYXQgY29tZSB0b2dldGhlciB0byByZXBvcnQgbWFya2V0IGhlYWx0aC4gSSBidWlsdCBhbmQgbWFpbnRhaW5lZCB0aGVzZSBtb2RlbHMgRm9yZWNhc3RpbmcgbW9kZWxzIHRvIHJlY29tbWVuZCBhY3Rpb25zIHRvIGhlbHAgb3B0aW1pemUgbWFya2V0cGxhY2UgYmFsYW5jZSBhY3Jvc3MgZ2xvYmFsIG1hcmtldHMuIn0sIHsiaWQiOiAiZGF0YV9lbmdpbmVlcmluZyIsICJsYWJlbCI6ICJEYXRhIEVuZ2luZWVyaW5nIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDExLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMn0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAicHl0aG9uIiwgInNxbCIsICJhd3NfZ2NwIiwgImRhZ3N0ZXJfYWlyZmxvdyIsICJkYnQiXSwgImRlc2NyaXB0aW9uIjogIkVUTCBwaXBlbGluZSBkZXZlbG9wbWVudCBhbmQgZGF0YSBpbmZyYXN0cnVjdHVyZSBmb3IgYm90aCByZWFsLXRpbWUgYW5hbHl0aWNzIGFuZCByZXBvcnRpbmcgc3lzdGVtcy4gSSBhbHNvIGxlZCB0aGUgZGF0YSBzY2llbmNlIHRlYW0gaW4gYSBjcm9zcy1mdW5jdGlvbmFsIGVmZm9ydCBpbiBwcm92aWRpbmcgcmVhbC10aW1lIGluc2lnaHRzIHRvIHVzZXJzIG9uIHRoZSBSb3ZlciBwbGF0Zm9ybS4ifSwgeyJpZCI6ICJtYXJrZXRwbGFjZV9pbmZsYXRpb25fcmVjcyIsICJsYWJlbCI6ICJNYXJrZXRwbGFjZSBJbmZsYXRpb24gJiBSZWNvbW1lbmRhdGlvbiBTeXN0ZW1zIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDEzLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMiwgImVuZCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAiZ2FtZV90aGVvcnkiLCAicHJpY2luZ19lbGFzdGljaXR5Il0sICJkZXNjcmlwdGlvbiI6ICJEZXNpZ25lZCBhbiBleHBlcmltZW50IHRvIG1lYXN1cmUgdGhlIGltcGFjdCBvZiByZWNvbW1lbmRhdGlvbiBzeXN0ZW1zIHRoYXQgZGlmZmVyZW50aWFsbHkgcHJpY2VkIHNlcnZpY2UgcHJvdmlkZXJzIG9uIGxvbmctdGVybSBtYXJrZXRwbGFjZSBpbmZsYXRpb24uIEdpdmVuIHRoZSBuYXR1cmUgb2YgaW50ZXJhY3Rpb24gYmV0d2VlbiB2YXJpb3VzIHVzZXJzLCBJIGRlc2lnbmVkIGEgZnJhbWV3b3JrIHRvIHNwbGl0IHVzZXJzIGJhc2VkIG9uIHRoZWlyIGdlb2dyYXBoeSwgYW5kIHN0dWR5IHRoZSBpbXBhY3Qgb2YgcmVjb21tZW5kYXRpb25zIG9uIG1hcmtldHBsYWNlIGluZmxhdGlvbi4ifSwgeyJpZCI6ICJnZW9fc3BsaXRfZXhwZXJpbWVudGF0aW9uIiwgImxhYmVsIjogIkdlbyBTcGxpdCBFeHBlcmltZW50YXRpb24gRnJhbWV3b3JrIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDEwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMywgImVuZCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJleHBlcmltZW50YWxfZGVzaWduIiwgInN0YXRpc3RpY3MiLCAiZ2Vvc3BhdGlhbF9hbmFseXNpcyJdLCAiZGVzY3JpcHRpb24iOiAiSSBoZWxwZWQgY3JlYXRlIHRoZSBmcmFtZXdvcmsgZm9yIGRlc2lnbmluZyBhbmQgYW5hbHl6aW5nIGdlby1zcGxpdCBleHBlcmltZW50cyBhdCBSb3Zlciwgd2hpY2ggYXJlIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIG1hcmtldHBsYWNlIGV4cGVyaW1lbnRzIHdoZXJlIGludGVyZmVyZW5jZSBiZXR3ZWVuIHVzZXJzIGNhbiBiaWFzIHJlc3VsdHMuIn0sIHsiaWQiOiAiZmluYW5jaWFsX21vZGVsbGluZyIsICJsYWJlbCI6ICJGaW5hbmNpYWwgTW9kZWxsaW5nIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDcsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJzdGF0aXN0aWNzIiwgInJlZ3Jlc3Npb24iLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJRdWFudGl0YXRpdmUgbW9kZWxzIGZvciBidXNpbmVzcyBzdHJhdGVneSwgcHJpY2luZyBvcHRpbWl6YXRpb24sIGFuZCByZXZlbnVlIGZvcmVjYXN0aW5nLiBJIHdhcyBpbnZvbHZlZCBpbiBzdHJhdGVnaWMgZmluYW5jaWFsIHBsYW5uaW5nIGF0IGJvdGggUm92ZXIgYW5kIFR1cm5vLCBidWlsZGluZyBtb2RlbHMgdG8gZm9yZWNhc3QgcmV2ZW51ZSwgb3B0aW1pemUgcHJpY2luZyBzdHJhdGVnaWVzLCBhbmQgZXZhbHVhdGUgdGhlIGZpbmFuY2lhbCBpbXBhY3Qgb2YgdmFyaW91cyBidXNpbmVzcyBpbml0aWF0aXZlcy4ifSwgeyJpZCI6ICJnZW9zcGF0aWFsX2FuYWx5c2lzIiwgImxhYmVsIjogIkdlb3NwYXRpYWwgRGF0YSBBbmFseXNpcyIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiAxMCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJ0dXJub19leHBlcmllbmNlIiwgInB5dGhvbiIsICJjbHVzdGVyaW5nX2FsZ29yaXRobXMiXSwgImRlc2NyaXB0aW9uIjogIkxvY2F0aW9uLWJhc2VkIGFuYWx5dGljcyBmb3IgbWFya2V0IGV4cGFuc2lvbiBhbmQgc3VwcGx5LWRlbWFuZCBvcHRpbWl6YXRpb24uIEkgYnVpbHQgZ2Vvc3BhdGlhbCBkYXRhIHBpcGVsaW5lcyBhbmQgYW5hbHlzaXMgZnJhbWV3b3JrcyB0byB1bmRlcnN0YW5kIG1hcmtldCBkeW5hbWljcyBhbmQgb3B0aW1pemUgc3VwcGx5IGRpc3RyaWJ1dGlvbiBhY3Jvc3MgZGlmZmVyZW50IHJlZ2lvbnMsIGF0IGJvdGggUm92ZXIgYW5kIFR1cm5vLiJ9LCB7ImlkIjogInByaWNpbmdfZWxhc3RpY2l0eSIsICJsYWJlbCI6ICJQcmljaW5nLCBQcmljZSBFbGFzdGljaXR5IiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDEyLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMn0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJ0dXJub19leHBlcmllbmNlIiwgImdhbWVfdGhlb3J5IiwgImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAicmVncmVzc2lvbiJdLCAiZGVzY3JpcHRpb24iOiAiRWNvbm9taWMgbW9kZWxpbmcgb2YgcHJpY2Ugc2Vuc2l0aXZpdHkgYW5kIGRlbWFuZCByZXNwb25zZSBpbiBtYXJrZXRwbGFjZSBlbnZpcm9ubWVudHMuIEF0IFJvdmVyLCBJIGluc3RydW1lbnRlZCBhIGNvdXBsZSBvZiBleHBlcmltZW50cyByZWxhdGVkIHRvIHByaWNpbmcgYW5kIHByaWNlIGVsYXN0aWNpdHksIGFuZCBhdCBUdXJubywgbWFkZSByZWNvbW1lbmRhdGlvbnMgZm9yIGhvdyB0byBkZXNpZ24gcHJpY2luZyBleHBlcmltZW50cyJ9LCB7ImlkIjogInRhbV9hbmFseXNpcyIsICJsYWJlbCI6ICJUQU0iLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogNiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsidHVybm9fZXhwZXJpZW5jZSIsICJzdGF0aXN0aWNzIiwgImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJUb3RhbCBBZGRyZXNzYWJsZSBNYXJrZXQgYW5hbHlzaXMgZm9yIHN0cmF0ZWdpYyBleHBhbnNpb24gYW5kIG1hcmtldCBvcHBvcnR1bml0eSBhc3Nlc3NtZW50LiBBdCBUdXJubywgdXNpbmcgYSBjb21iaW5hdGlvbiBvZiBwdWJsaWMgZGF0YXNldHMsIGFuZCBtb2RlbGxpbmcsIEkgZXN0aW1hdGVkIHRoZSBUQU0gZm9yIFR1cm5vIGJ5IGxvY2FsIHJlZ2lvbiBpbiBhIGZldyBjb3VudHJpZXMuIn0sIHsiaWQiOiAibHR2X21vZGVsaW5nIiwgImxhYmVsIjogIkxUViIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiA3LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyNH0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJ0dXJub19leHBlcmllbmNlIiwgInJlZ3Jlc3Npb24iLCAidGltZV9zZXJpZXNfZm9yZWNhc3RpbmciLCAiYmF5ZXNpYW5fc3RhdGlzdGljcyJdLCAiZGVzY3JpcHRpb24iOiAiQ3VzdG9tZXIgTGlmZXRpbWUgVmFsdWUgcHJlZGljdGlvbiBtb2RlbHMgZm9yIG9wdGltaXppbmcgYWNxdWlzaXRpb24gY29zdHMgYW5kIG1hcmtldGluZyBzcGVuZC4gSSBidWlsdCBvdXQgZnJvbSBzY3JhdGNoIGEgZnJhbWV3b3JrIGZvciB1bmRlcnN0YW5kaW5nIHRoZSBMaWZldGltZSBWYWx1ZSBvZiBhIGN1c3RvbWVyIGF0IFR1cm5vLCB3aGljaCB0aGVuIGhlbHBlZCBpbmZvcm0gbWFya2V0aW5nIHNwZW5kIGRlY2lzaW9ucy4ifSwgeyJpZCI6ICJsbG1zX3Byb2R1Y3QiLCAibGFiZWwiOiAiTGFyZ2UgTGFuZ3VhZ2UgTW9kZWxzIGluIFByb2R1Y3QiLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImxhcmdlX2xhbmd1YWdlX21vZGVscyIsICJyb3Zlcl9leHBlcmllbmNlIiwgInR1cm5vX2V4cGVyaWVuY2UiLCAicHl0aG9uIiwgInNlbWFudGljX3NlYXJjaCJdLCAiZGVzY3JpcHRpb24iOiAiSSd2ZSB1c2VkIHRvb2xzIGxpa2UgTGFuZ2NoYWluIHRvIGJ1aWxkIGludGVybmFsIHRvb2xzIHRoYXQgZmVlZCBpbnRvLCBhbmQgb3B0aW1pemUgYnVzaW5lc3MgcHJvY2Vzc2VzIHRoYXQgaW52b2x2ZSBhIGxvdCBvZiBodW1hbiBqdWRnZW1lbnQgYXQgYm90aCBSb3ZlciBhbmQgVHVybm8uIFRoaXMgaGFzIHJlcXVpcmVkIGNyZWF0aW5nIHN0cnVjdHVyZWQgUkFHIHBpcGVsaW5lcyB0aGF0IGNvbWJpbmUgdGV4dCBhbG9uZyB3aXRoIHN0cnVjdHVyZWQgZGF0YSB0byBvYnRhaW4gc3RydWN0dXJlZCBvdXRwdXQuIn0sIHsiaWQiOiAibWxfcHJvZHVjdGlvbiIsICJsYWJlbCI6ICJNTCBpbiBQcm9kdWN0aW9uIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDEyLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsidGVjaG5pY2FsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJvdmVyX2V4cGVyaWVuY2UiLCAidHVybm9fZXhwZXJpZW5jZSIsICJweXRob24iLCAiYXdzX2djcCIsICJkYWdzdGVyX2FpcmZsb3ciLCAiZXhwZXJpbWVudGFsX2Rlc2lnbiJdLCAiZGVzY3JpcHRpb24iOiAiRW5kLXRvLWVuZCBtYWNoaW5lIGxlYXJuaW5nIGlkZWF0aW9uLCBmZWF0dXJlIGVuZ2luZWVyaW5nLCB0cmFpbmluZywgZGVwbG95bWVudCwgbW9uaXRvcmluZywgdGVzdGluZywgYW5kIG1haW50ZW5hbmNlIGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLiBJJ3ZlIGJlZW4gaW52b2x2ZWQgaW4gdGhpcyBhdCBib3RoIFJvdmVyIGFuZCBUdXJubywgd2hlcmUgSSBidWlsdCBhbmQgZGVwbG95ZWQgTUwgbW9kZWxzIHRvIHByb2R1Y3Rpb24sIHNldCB1cCBtb25pdG9yaW5nIHN5c3RlbXMgdG8gdHJhY2sgbW9kZWwgcGVyZm9ybWFuY2UsIGFuZCBpbXBsZW1lbnRlZCBwcm9jZXNzZXMgZm9yIHJlZ3VsYXIgbW9kZWwgcmV0cmFpbmluZyBhbmQgdXBkYXRlcy4ifSwgeyJpZCI6ICJyZWluZm9yY2VtZW50X2xlYXJuaW5nIiwgImxhYmVsIjogIlJlaW5mb3JjZW1lbnQgTGVhcm5pbmciLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsic3RhbmZvcmRfYWlfY2VydCIsICJib3R0b21fdXBfYXBwcm9hY2giLCAiZ2FtZV90aGVvcnkiLCAiZGVjaXNpb25fbWFraW5nX2FnZW50cyJdLCAiZGVzY3JpcHRpb24iOiAiTXkgZmFzY2luYXRpb24gZm9yIHVuZGVyc3RhbmRpbmcgb3B0aW1hbCBkZWNpc2lvbiBtYWtpbmcgYnkgYWdlbnRzIHVuZGVyIHVuY2VydGFpbnR5IGlzIHdoYXQgYnJpbmdzIG1lIHRvIFJlaW5mb3JjZW1lbnQgTGVhcm5pbmcuIEkgZmluZCB0aGlzIHRvIGJlIHNvbWV3aGF0IG1pZC13YXkgYmV0d2VlbiB0aGUgYm90dG9tLXVwIGFwcHJvYWNoIChmcm9tIG15IHBoeXNpY3MgZGF5cykgdG8gdGhlIHRvcC1kb3duIGFwcHJvYWNoIChmcm9tIG15IHRpbWUgYXMgYSBkYXRhIHNjaWVudGlzdCkgdG8gbGVhcm4gYWJvdXQgZW1lcmdlbnQgYmVoYXZpb3Igd2l0aCBwcmFjdGljYWwgYXBwbGljYXRpb25zIGluIGdhbWUgdGhlb3J5IGFuZCBtYXJrZXRwbGFjZSBkeW5hbWljcy4ifSwgeyJpZCI6ICJkZWNpc2lvbl9tYWtpbmdfYWdlbnRzIiwgImxhYmVsIjogIkRlY2lzaW9uIE1ha2luZyBpbiBBZ2VudHMiLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTQsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIzfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZ2FtZV90aGVvcnkiLCAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAiYm90dG9tX3VwX2FwcHJvYWNoIl0sICJkZXNjcmlwdGlvbiI6ICJJJ20gaW50cmlndWVkIGJ5IHRoZSBwYXJhbGxlbHMgYmV0d2VlbiBteSBib3R0b20tdXAgcGh5c2ljcyBhcHByb2FjaCBhbmQgaG93IGluZGl2aWR1YWwgcmF0aW9uYWwgYWdlbnRzIG1ha2UgZGVjaXNpb25zIHRoYXQgbGVhZCB0byBjb21wbGV4IGVtZXJnZW50IG1hcmtldCBiZWhhdmlvcnMuIn0sIHsiaWQiOiAiYXVjdGlvbnNfZGVzaWduIiwgImxhYmVsIjogIkF1Y3Rpb25zICYgQXVjdGlvbiBEZXNpZ24iLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIzfSwgImF1ZGllbmNlIjogWyJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZ2FtZV90aGVvcnkiLCAiZGVjaXNpb25fbWFraW5nX2FnZW50cyIsICJtYXJrZXRwbGFjZXMiLCAicHJpY2luZ19lbGFzdGljaXR5Il0sICJkZXNjcmlwdGlvbiI6ICJJJ20gZHJhd24gdG8gdGhlIG1hdGhlbWF0aWNhbCBlbGVnYW5jZSBvZiBtZWNoYW5pc20gZGVzaWduIGFuZCBpdHMgcHJhY3RpY2FsIGFwcGxpY2F0aW9ucyBpbiBvcHRpbWl6aW5nIG1hcmtldHBsYWNlIG91dGNvbWVzIC0gYSBwZXJmZWN0IGJsZW5kIG9mIGdhbWUgdGhlb3J5IGFuZCByZWFsLXdvcmxkIGltcGFjdC4ifSwgeyJpZCI6ICJzdGFuZm9yZF9haV9jZXJ0IiwgImxhYmVsIjogIlN0YW5mb3JkIEFJIENlcnRpZmljYXRlIiwgImxheWVyIjogImRhdGEiLCAic2l6ZSI6IDE0LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyNH0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJ2YW5jb3V2ZXIiLCAibGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzIiwgInJlaW5mb3JjZW1lbnRfbGVhcm5pbmciLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJJJ20gcHVyc3VpbmcgdGhpcyB0byBkZWVwZW4gbXkgdW5kZXJzdGFuZGluZyBvZiBjdXR0aW5nLWVkZ2UgQUkgdGVjaG5pcXVlcyBhbmQgbWFpbnRhaW4gY29ubmVjdGlvbiB0byBhY2FkZW1pYyByaWdvciB3aGlsZSBhcHBseWluZyBNTCBpbiBpbmR1c3RyeSBzZXR0aW5ncy4gSSdtIG9wZW4gdG8gd2hlcmUgdGhpcyB0YWtlcyBtZSBpbiB0aGUgZnV0dXJlLiJ9LCB7ImlkIjogImxhcmdlX2xhbmd1YWdlX21vZGVscyIsICJsYWJlbCI6ICJMYXJnZSBMYW5ndWFnZSBNb2RlbHMiLCAibGF5ZXIiOiAiZGF0YSIsICJzaXplIjogMTMsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIzfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJzdGFuZm9yZF9haV9jZXJ0IiwgInB5dGhvbiIsICJzZW1hbnRpY19zZWFyY2giLCAibGxtc19wcm9kdWN0Il0sICJkZXNjcmlwdGlvbiI6ICJFeGNpdGVkIGJ5IHRoZWlyIHBvdGVudGlhbCB0byB0cmFuc2Zvcm0gaG93IHdlIGludGVyYWN0IHdpdGggZGF0YSBhbmQgYXV0b21hdGUgY29tcGxleCByZWFzb25pbmcgdGFza3MsIGhhdmluZyBzZWVuIHRoZWlyIHByYWN0aWNhbCBpbXBhY3QgaW4gcHJvZHVjdGlvbiBzeXN0ZW1zIGF0IFJvdmVyIGFuZCBUdXJuby4gSSdtIGludGVyZXN0ZWQgaW4gYWdlbnRpYyBBSSBhbmQgd291bGQgbG92ZSB0byBleHBsb3JlIGhvdyBtZW1vcnktYXVnbWVudGVkIExMTXMgY2FuIGJlIHVzZWQgdG8gYnVpbGQgbW9yZSBhdXRvbm9tb3VzIHN5c3RlbXMuIn0sIHsiaWQiOiAic2VtYW50aWNfc2VhcmNoIiwgImxhYmVsIjogIlNlbWFudGljIFNlYXJjaCIsICJsYXllciI6ICJkYXRhIiwgInNpemUiOiAxMiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJsYXJnZV9sYW5ndWFnZV9tb2RlbHMiLCAiY2x1c3RlcmluZ19hbGdvcml0aG1zIiwgInJlY29tbWVuZGF0aW9uX3N5c3RlbXMiXSwgImRlc2NyaXB0aW9uIjogIkludGVyZXN0ZWQgaW4gaG93IHZlY3RvciBlbWJlZGRpbmdzIGNhcHR1cmUgbWVhbmluZyBhbmQgZW5hYmxlIG1vcmUgaW50ZWxsaWdlbnQgaW5mb3JtYXRpb24gcmV0cmlldmFsLCBicmlkZ2luZyBteSBhcHByZWNpYXRpb24gZm9yIG1hdGhlbWF0aWNhbCByZXByZXNlbnRhdGlvbnMgd2l0aCBwcmFjdGljYWwgc2VhcmNoIGFwcGxpY2F0aW9ucy4ifSwgeyJpZCI6ICJtb2xlY3VsYXJfZHluYW1pY3MiLCAibGFiZWwiOiAiTW9sZWN1bGFyIER5bmFtaWNzIiwgImxheWVyIjogImFwcGxpY2F0aW9ucyIsICJzaXplIjogNywgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiZHJ1Z19kaXNjb3ZlcnkiLCAicHl0aG9uIiwgImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJwZXJ0dXJiYXRpb25fdGhlb3J5Il0sICJkZXNjcmlwdGlvbiI6ICJBdHRyYWN0ZWQgdG8gaG93IGNvbXB1dGF0aW9uYWwgcGh5c2ljcyBtZXRob2RzIEkga25vdyBjYW4gYWNjZWxlcmF0ZSBkcnVnIGRpc2NvdmVyeSwgcG90ZW50aWFsbHkgcmVkdWNpbmcgcmVsaWFuY2Ugb24gYW5pbWFsIHRlc3Rpbmcgd2hpbGUgbGV2ZXJhZ2luZyBteSBtYXRoZW1hdGljYWwgcGh5c2ljcyBiYWNrZ3JvdW5kLiJ9LCB7ImlkIjogImRydWdfZGlzY292ZXJ5IiwgImxhYmVsIjogIkRydWcgRGlzY292ZXJ5IiwgImxheWVyIjogImFwcGxpY2F0aW9ucyIsICJzaXplIjogNywgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjF9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzIiwgImJpdHNfZWR1Y2F0aW9uIiwgIm1vbGVjdWxhcl9keW5hbWljcyIsICJweXRob24iXSwgImRlc2NyaXB0aW9uIjogIk1vdGl2YXRlZCBieSB0aGUgcG90ZW50aWFsIHRvIGFwcGx5IE1MIHRlY2huaXF1ZXMgdG8gYWNjZWxlcmF0ZSBwaGFybWFjZXV0aWNhbCBkZXZlbG9wbWVudCB3aGlsZSBzdXBwb3J0aW5nIG1vcmUgaHVtYW5lIHJlc2VhcmNoIG1ldGhvZHMsIGNvbWJpbmluZyBteSBwaGFybWFjeSBiYWNrZ3JvdW5kIHdpdGggY3VycmVudCBkYXRhIHNjaWVuY2Ugc2tpbGxzLiJ9LCB7ImlkIjogIm51Y2xlYXJfZnVzaW9uIiwgImxhYmVsIjogIk51Y2xlYXIgRnVzaW9uIiwgImxheWVyIjogImFwcGxpY2F0aW9ucyIsICJzaXplIjogNywgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjB9LCAiYXVkaWVuY2UiOiBbInRlY2huaWNhbCIsICJjdXJyZW50Il0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJjbGltYXRlX3RlY2giLCAiZGlmZmVyZW50aWFsX2dlb21ldHJ5IiwgInBlcnR1cmJhdGlvbl90aGVvcnkiLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJGYXNjaW5hdGVkIGJ5IHRoZSBpbnRlcnNlY3Rpb24gb2YgZnVuZGFtZW50YWwgcGh5c2ljcyBhbmQgY2xpbWF0ZSBzb2x1dGlvbnMsIHdoZXJlIG15IHRoZW9yZXRpY2FsIHBoeXNpY3MgYmFja2dyb3VuZCBjb3VsZCBjb250cmlidXRlIHRvIG9uZSBvZiBodW1hbml0eSdzIG1vc3QgaW1wb3J0YW50IGVuZXJneSBjaGFsbGVuZ2VzLiJ9LCB7ImlkIjogIm9yZ2FuX29uX2NoaXAiLCAibGFiZWwiOiAiT3JnYW4gb24gYSBDaGlwIiwgImxheWVyIjogImFwcGxpY2F0aW9ucyIsICJzaXplIjogNiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTl9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzIiwgImJpdHNfZWR1Y2F0aW9uIiwgInB5dGhvbiJdLCAiZGVzY3JpcHRpb24iOiAiRHJhd24gdG8gdGhpcyB0ZWNobm9sb2d5IGFzIGEgaHVtYW5lIGFsdGVybmF0aXZlIHRvIGFuaW1hbCB0ZXN0aW5nIHRoYXQgYWxpZ25zIHdpdGggbXkgdmVnYW4gdmFsdWVzIHdoaWxlIG9mZmVyaW5nIG9wcG9ydHVuaXRpZXMgdG8gYXBwbHkgZGF0YSBhbmFseXNpcyB0byBiaW9sb2dpY2FsIHN5c3RlbXMuIEF0IHRoaXMgcG9pbnQsIGdpdmVuIG15IHNraWxscywgSSBkb24ndCB5ZXQgc2VlIGhvdyBJIGNvdWxkIGJlIG9mIHZhbHVlIGluIHRoaXMgYXJlYSwgYnV0IEkgd291bGQgbG92ZSB0byBleHBsb3JlIGhvdyBJIGNvdWxkIGNvbnRyaWJ1dGUuIn0sIHsiaWQiOiAiYWx0ZXJuYXRpdmVfcHJvdGVpbnMiLCAibGFiZWwiOiAiQWx0ZXJuYXRpdmUgUHJvdGVpbnMiLCAibGF5ZXIiOiAiYXBwbGljYXRpb25zIiwgInNpemUiOiA2LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsidmVnYW4iLCAiY2xpbWF0ZV90ZWNoIl0sICJkZXNjcmlwdGlvbiI6ICJJbnRlcmVzdGVkIGluIHRoZSBpbnRlcnNlY3Rpb24gb2YgZm9vZCB0ZWNobm9sb2d5IGFuZCBzdXN0YWluYWJpbGl0eSwgc2VlaW5nIHBvdGVudGlhbCBhcHBsaWNhdGlvbnMgZm9yIG9wdGltaXphdGlvbiBhbmQgcHJvY2VzcyBtb2RlbGluZyB0aGF0IGFsaWduIHdpdGggZW52aXJvbm1lbnRhbCBhbmQgZXRoaWNhbCB2YWx1ZXMuIn0sIHsiaWQiOiAibWFya2V0cGxhY2VzIiwgImxhYmVsIjogIk1hcmtldHBsYWNlcyIsICJsYXllciI6ICJhcHBsaWNhdGlvbnMiLCAic2l6ZSI6IDE0LCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCIsICJ0ZWNobmljYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsicm92ZXJfZXhwZXJpZW5jZSIsICJ0dXJub19leHBlcmllbmNlIiwgImdhbWVfdGhlb3J5IiwgInJlY29tbWVuZGF0aW9uX3N5c3RlbXMiXSwgImRlc2NyaXB0aW9uIjogIkNhcHRpdmF0ZWQgYnkgdGhlIGNvbXBsZXggZHluYW1pY3Mgb2YgdHdvLXNpZGVkIG1hcmtldHMgYW5kIGhvdyBnYW1lIHRoZW9yeSwgZWNvbm9taWNzLCBhbmQgTUwgY2FuIG9wdGltaXplIG91dGNvbWVzIGZvciBhbGwgcGFydGljaXBhbnRzIC0gbXkgcHJpbWFyeSBhcmVhIG9mIGFwcGxpZWQgZXhwZXJ0aXNlLiJ9LCB7ImlkIjogImdhbWluZyIsICJsYWJlbCI6ICJHYW1pbmciLCAibGF5ZXIiOiAiYXBwbGljYXRpb25zIiwgInNpemUiOiAxMSwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjN9LCAiYXVkaWVuY2UiOiBbImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInJlaW5mb3JjZW1lbnRfbGVhcm5pbmciLCAiYWdlbnRfYmFzZWRfbW9kZWxsaW5nIiwgInB5dGhvbiJdLCAiZGVzY3JpcHRpb24iOiAiSW50cmlndWVkIGJ5IGhvdyByZWluZm9yY2VtZW50IGxlYXJuaW5nIGFuZCBhZ2VudC1iYXNlZCBtb2RlbGluZyBjb3VsZCBlbmhhbmNlIGdhbWUgQUkgYW5kIHByb2NlZHVyYWwgY29udGVudCBnZW5lcmF0aW9uLCBhcHBseWluZyB0ZWNobmlxdWVzIEkgdXNlIGluIG1hcmtldHBsYWNlIG9wdGltaXphdGlvbi4ifSwgeyJpZCI6ICJjbGltYXRlX3RlY2giLCAibGFiZWwiOiAiQ2xpbWF0ZSBUZWNoIiwgImxheWVyIjogImFwcGxpY2F0aW9ucyIsICJzaXplIjogNiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMjN9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiLCAiY3VycmVudCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsibnVjbGVhcl9mdXNpb24iLCAiYWx0ZXJuYXRpdmVfcHJvdGVpbnMiLCAicHl0aG9uIl0sICJkZXNjcmlwdGlvbiI6ICJNb3RpdmF0ZWQgYnkgdGhlIHVyZ2VudCBuZWVkIHRvIGFwcGx5IHF1YW50aXRhdGl2ZSBtZXRob2RzIHRvIGVudmlyb25tZW50YWwgY2hhbGxlbmdlcywgc2VlaW5nIG9wcG9ydHVuaXRpZXMgdG8gY29udHJpYnV0ZSBteSBhbmFseXRpY2FsIHNraWxscyB0byBtZWFuaW5nZnVsIGNsaW1hdGUgc29sdXRpb25zLiJ9LCB7ImlkIjogImNoZW5uYWkiLCAibGFiZWwiOiAiQ2hlbm5haSIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogOCwgInRpbWVzcGFuIjogeyJzdGFydCI6IDE5OTEsICJlbmQiOiAyMDA5fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogbnVsbCwgImRlc2NyaXB0aW9uIjogIkJpcnRocGxhY2UgaW4gVGFtaWwgTmFkdSwgSW5kaWEsIHdoZXJlIHRoZSBqb3VybmV5IGJlZ2FuLiJ9LCB7ImlkIjogImh5ZGVyYWJhZCIsICJsYWJlbCI6ICJIeWRlcmFiYWQiLCAibGF5ZXIiOiAicGVyc29uYWwiLCAic2l6ZSI6IDEwLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAwOSwgImVuZCI6IDIwMTR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbImNoZW5uYWkiLCAiYml0c19lZHVjYXRpb24iXSwgImRlc2NyaXB0aW9uIjogIlVuZGVyZ3JhZHVhdGUgVW5pdmVyc2l0eSB5ZWFycyBhdCBCSVRTIFBpbGFuaSwgc3R1ZHlpbmcgcGh5c2ljcyBhbmQgcGhhcm1hY3kgaW4gdGhlIG91dHNraXJ0cyBvZiBIeWRlcmFiYWQuIn0sIHsiaWQiOiAibXVuaWNoIiwgImxhYmVsIjogIk11bmljaCIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDEzLCAiZW5kIjogMjAxNH0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsiaHlkZXJhYmFkIiwgImRldGxlZl9kdXJyIiwgImZhc2NpbmF0aW9uX2xlYXJuaW5nIl0sICJkZXNjcmlwdGlvbiI6ICJNYXN0ZXIncyB0aGVzaXMgeWVhciBpbiBHZXJtYW55LCB3b3JraW5nIHdpdGggRGV0bGVmIERcdTAwZmNyciBhbmQgZXhwbG9yaW5nIEV1cm9wZWFuIGFjYWRlbWljIGN1bHR1cmUuIEkgbG92ZSB0aGlzIGNpdHkhIn0sIHsiaWQiOiAidHVjc29uIiwgImxhYmVsIjogIlR1Y3NvbiIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogMTIsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE1LCAiZW5kIjogMjAyMX0sICJhdWRpZW5jZSI6IFsiZ2VuZXJhbCJdLCAic3Vibm9kZSI6IHRydWUsICJwYXJlbnRfbm9kZSI6IFsibXVuaWNoIiwgInVvZmFfZWR1Y2F0aW9uIiwgInNhbV9ncmFsbGEiLCAidmVnYW4iXSwgImRlc2NyaXB0aW9uIjogIlBoRCB5ZWFycyBpbiBBcml6b25hIGRlc2VydCwgZGV2ZWxvcGluZyBleHBlcnRpc2UgaW4gYmxhY2sgaG9sZSBwaHlzaWNzIGFuZCBncmF2aXRhdGlvbmFsIHRoZW9yeS4ifSwgeyJpZCI6ICJzZWF0dGxlIiwgImxhYmVsIjogIlNlYXR0bGUiLCAibGF5ZXIiOiAicGVyc29uYWwiLCAic2l6ZSI6IDEzLCAidGltZXNwYW4iOiB7InN0YXJ0IjogMjAyMSwgImVuZCI6IDIwMjR9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInR1Y3NvbiIsICJyb3Zlcl9leHBlcmllbmNlIiwgImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiXSwgImRlc2NyaXB0aW9uIjogIlRyYW5zaXRpb24gdG8gZGF0YSBzY2llbmNlIGluZHVzdHJ5IGluIHRoZSBQYWNpZmljIE5vcnRod2VzdCwgbGVhcm5pbmcgbWFya2V0cGxhY2UgZHluYW1pY3MgYXQgUm92ZXIuIn0sIHsiaWQiOiAidmFuY291dmVyIiwgImxhYmVsIjogIlZhbmNvdXZlciIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogMTQsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDI0fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInNlYXR0bGUiLCAidHVybm9fZXhwZXJpZW5jZSIsICJzdGFuZm9yZF9haV9jZXJ0Il0sICJkZXNjcmlwdGlvbiI6ICJDdXJyZW50IGhvbWUgaW4gQ2FuYWRhLCBhcHBseWluZyBNTCBhbmQgZ2FtZSB0aGVvcnkgdG8gcGFya2luZyBtYXJrZXRwbGFjZXMgd2hpbGUgcHVyc3VpbmcgYWR2YW5jZWQgQUkgc3R1ZGllcy4ifSwgeyJpZCI6ICJzY2hudWNraSIsICJsYWJlbCI6ICJTY2hudWNraSIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogMTUsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDE4fSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIl0sICJzdWJub2RlIjogdHJ1ZSwgInBhcmVudF9ub2RlIjogWyJ0dWNzb24iLCAic2VhdHRsZSIsICJ2YW5jb3V2ZXIiXSwgImRlc2NyaXB0aW9uIjogIk15IGJlYXV0aWZ1bCBzb3VsLWRvZyB3aG9zZSBuZWVkIGZvciBvdXRkb29yIGFkdmVudHVyZXMgaW5mbHVlbmNlZCBsaWZlIGRlY2lzaW9ucywgaW5jbHVkaW5nIHRoZSBtb3ZlIHRvIHBldC1mcmllbmRseSBTZWF0dGxlLCBhbmQgbGF0ZXIgVmFuY291dmVyLiJ9LCB7ImlkIjogInZlZ2FuIiwgImxhYmVsIjogIlZlZ2FuIiwgImxheWVyIjogInBlcnNvbmFsIiwgInNpemUiOiAxMiwgInRpbWVzcGFuIjogeyJzdGFydCI6IDIwMTV9LCAiYXVkaWVuY2UiOiBbImdlbmVyYWwiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInR1Y3NvbiIsICJhbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMiLCAiYWx0ZXJuYXRpdmVfcHJvdGVpbnMiXSwgImRlc2NyaXB0aW9uIjogIkkgYWRvcHRlZCBhIHZlZ2FuIGxpZmVzdHlsZSBpbiAyMDE1LCBkcml2ZW4gYnkgZXRoaWNhbCBjb25zaWRlcmF0aW9ucyByZWdhcmRpbmcgYW5pbWFsIHdlbGZhcmUgd2hlbiBJIGxlYXJudCBhYm91dCBob3cgZGFpcnkgYW5pbWFscyB3ZXJlIHRyZWF0ZWQuIn0sIHsiaWQiOiAiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzIiwgImxhYmVsIjogIkFsdGVybmF0aXZlcyB0byBBbmltYWwgVGVzdGluZyIsICJsYXllciI6ICJwZXJzb25hbCIsICJzaXplIjogMTAsICJ0aW1lc3BhbiI6IHsic3RhcnQiOiAyMDIyfSwgImF1ZGllbmNlIjogWyJnZW5lcmFsIiwgImN1cnJlbnQiXSwgInN1Ym5vZGUiOiB0cnVlLCAicGFyZW50X25vZGUiOiBbInZlZ2FuIiwgImRydWdfZGlzY292ZXJ5IiwgIm9yZ2FuX29uX2NoaXAiXSwgImRlc2NyaXB0aW9uIjogIlBlcnNvbmFsIGludGVyZXN0IGluIGRldmVsb3BpbmcgaHVtYW5lIHJlc2VhcmNoIG1ldGhvZHMsIGNvbm5lY3RpbmcgdG8gb3JnYW4tb24tY2hpcCBhbmQgZHJ1ZyBkaXNjb3ZlcnkgdGVjaG5vbG9naWVzLiJ9XSwgImxpbmtzIjogW3sic291cmNlIjogImJpdHNfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJtYWduZXRpY19tb25vcG9sZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1tYWduZXRpY19tb25vcG9sZXMifSwgeyJzb3VyY2UiOiAiY2FsY3VsdXMiLCAidGFyZ2V0IjogIm1hZ25ldGljX21vbm9wb2xlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNhbGN1bHVzLW1hZ25ldGljX21vbm9wb2xlcyJ9LCB7InNvdXJjZSI6ICJsaW5lYXJfYWxnZWJyYSIsICJ0YXJnZXQiOiAibWFnbmV0aWNfbW9ub3BvbGVzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGluZWFyX2FsZ2VicmEtbWFnbmV0aWNfbW9ub3BvbGVzIn0sIHsic291cmNlIjogImNvbXBsZXhfYW5hbHlzaXMiLCAidGFyZ2V0IjogIm1hZ25ldGljX21vbm9wb2xlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNvbXBsZXhfYW5hbHlzaXMtbWFnbmV0aWNfbW9ub3BvbGVzIn0sIHsic291cmNlIjogImJpdHNfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYml0c19lZHVjYXRpb24tcXVhbnR1bV9mb3VuZGF0aW9ucyJ9LCB7InNvdXJjZSI6ICJtdW5pY2giLCAidGFyZ2V0IjogInF1YW50dW1fZm91bmRhdGlvbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtdW5pY2gtcXVhbnR1bV9mb3VuZGF0aW9ucyJ9LCB7InNvdXJjZSI6ICJkZXRsZWZfZHVyciIsICJ0YXJnZXQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRldGxlZl9kdXJyLXF1YW50dW1fZm91bmRhdGlvbnMifSwgeyJzb3VyY2UiOiAicGhpbG9zb3BoeV9waHlzaWNzIiwgInRhcmdldCI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGhpbG9zb3BoeV9waHlzaWNzLXF1YW50dW1fZm91bmRhdGlvbnMifSwgeyJzb3VyY2UiOiAiYm90dG9tX3VwX2FwcHJvYWNoIiwgInRhcmdldCI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYm90dG9tX3VwX2FwcHJvYWNoLXF1YW50dW1fZm91bmRhdGlvbnMifSwgeyJzb3VyY2UiOiAiaW52aXRlZF90YWxrcyIsICJ0YXJnZXQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImludml0ZWRfdGFsa3MtcXVhbnR1bV9mb3VuZGF0aW9ucyJ9LCB7InNvdXJjZSI6ICJtYXN0ZXJzX3RoZXNpc19sbXUiLCAidGFyZ2V0IjogInF1YW50dW1fZm91bmRhdGlvbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtYXN0ZXJzX3RoZXNpc19sbXUtcXVhbnR1bV9mb3VuZGF0aW9ucyJ9LCB7InNvdXJjZSI6ICJsYXRleCIsICJ0YXJnZXQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxhdGV4LXF1YW50dW1fZm91bmRhdGlvbnMifSwgeyJzb3VyY2UiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJ0YXJnZXQiOiAiZGV0bGVmX2R1cnIiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJxdWFudHVtX2ZvdW5kYXRpb25zLWRldGxlZl9kdXJyIn0sIHsic291cmNlIjogIm11bmljaCIsICJ0YXJnZXQiOiAiZGV0bGVmX2R1cnIiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtdW5pY2gtZGV0bGVmX2R1cnIifSwgeyJzb3VyY2UiOiAibWFzdGVyc190aGVzaXNfbG11IiwgInRhcmdldCI6ICJkZXRsZWZfZHVyciIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm1hc3RlcnNfdGhlc2lzX2xtdS1kZXRsZWZfZHVyciJ9LCB7InNvdXJjZSI6ICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAidGFyZ2V0IjogImRldGxlZl9kdXJyIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGhpbG9zb3BoeV9waHlzaWNzLWRldGxlZl9kdXJyIn0sIHsic291cmNlIjogImJvdHRvbV91cF9hcHByb2FjaCIsICJ0YXJnZXQiOiAiZGV0bGVmX2R1cnIiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtZGV0bGVmX2R1cnIifSwgeyJzb3VyY2UiOiAiZGV0bGVmX2R1cnIiLCAidGFyZ2V0IjogInJlbm9ybWFsaXphdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRldGxlZl9kdXJyLXJlbm9ybWFsaXphdGlvbiJ9LCB7InNvdXJjZSI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInRhcmdldCI6ICJyZW5vcm1hbGl6YXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJxdWFudHVtX2ZvdW5kYXRpb25zLXJlbm9ybWFsaXphdGlvbiJ9LCB7InNvdXJjZSI6ICJjb21wbGV4X2FuYWx5c2lzIiwgInRhcmdldCI6ICJyZW5vcm1hbGl6YXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLXJlbm9ybWFsaXphdGlvbiJ9LCB7InNvdXJjZSI6ICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJ0YXJnZXQiOiAicmVub3JtYWxpemF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3BlY2lhbF9mdW5jdGlvbnMtcmVub3JtYWxpemF0aW9uIn0sIHsic291cmNlIjogImZvdXJpZXJfbGFwbGFjZSIsICJ0YXJnZXQiOiAicmVub3JtYWxpemF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZm91cmllcl9sYXBsYWNlLXJlbm9ybWFsaXphdGlvbiJ9LCB7InNvdXJjZSI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgInRhcmdldCI6ICJyZW5vcm1hbGl6YXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5LXJlbm9ybWFsaXphdGlvbiJ9LCB7InNvdXJjZSI6ICJyZW5vcm1hbGl6YXRpb24iLCAidGFyZ2V0IjogInNlbGZfZm9yY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyZW5vcm1hbGl6YXRpb24tc2VsZl9mb3JjZSJ9LCB7InNvdXJjZSI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAidGFyZ2V0IjogInNlbGZfZm9yY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnktc2VsZl9mb3JjZSJ9LCB7InNvdXJjZSI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgInRhcmdldCI6ICJzZWxmX2ZvcmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGVydHVyYmF0aW9uX3RoZW9yeS1zZWxmX2ZvcmNlIn0sIHsic291cmNlIjogInNwZWNpYWxfZnVuY3Rpb25zIiwgInRhcmdldCI6ICJzZWxmX2ZvcmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3BlY2lhbF9mdW5jdGlvbnMtc2VsZl9mb3JjZSJ9LCB7InNvdXJjZSI6ICJtYXRoZW1hdGljYSIsICJ0YXJnZXQiOiAic2VsZl9mb3JjZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm1hdGhlbWF0aWNhLXNlbGZfZm9yY2UifSwgeyJzb3VyY2UiOiAic2VsZl9mb3JjZSIsICJ0YXJnZXQiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzZWxmX2ZvcmNlLWJsYWNrX2hvbGVfc3RhYmlsaXR5In0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInVvZmFfZWR1Y2F0aW9uLWJsYWNrX2hvbGVfc3RhYmlsaXR5In0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic2FtX2dyYWxsYS1ibGFja19ob2xlX3N0YWJpbGl0eSJ9LCB7InNvdXJjZSI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAidGFyZ2V0IjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LWJsYWNrX2hvbGVfc3RhYmlsaXR5In0sIHsic291cmNlIjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAidGFyZ2V0IjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGVydHVyYmF0aW9uX3RoZW9yeS1ibGFja19ob2xlX3N0YWJpbGl0eSJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLWJsYWNrX2hvbGVfc3RhYmlsaXR5In0sIHsic291cmNlIjogIm1hdGhlbWF0aWNhIiwgInRhcmdldCI6ICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm1hdGhlbWF0aWNhLWJsYWNrX2hvbGVfc3RhYmlsaXR5In0sIHsic291cmNlIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInRhcmdldCI6ICJidHpfYmxhY2tfaG9sZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5LWJ0el9ibGFja19ob2xlIn0sIHsic291cmNlIjogImNvbXBsZXhfYW5hbHlzaXMiLCAidGFyZ2V0IjogImJ0el9ibGFja19ob2xlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY29tcGxleF9hbmFseXNpcy1idHpfYmxhY2tfaG9sZSJ9LCB7InNvdXJjZSI6ICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJ0YXJnZXQiOiAiYnR6X2JsYWNrX2hvbGUiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzcGVjaWFsX2Z1bmN0aW9ucy1idHpfYmxhY2tfaG9sZSJ9LCB7InNvdXJjZSI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAidGFyZ2V0IjogImJ0el9ibGFja19ob2xlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LWJ0el9ibGFja19ob2xlIn0sIHsic291cmNlIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInRhcmdldCI6ICJhcmV0YWtpc19pbnN0YWJpbGl0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5LWFyZXRha2lzX2luc3RhYmlsaXR5In0sIHsic291cmNlIjogImJ0el9ibGFja19ob2xlIiwgInRhcmdldCI6ICJhcmV0YWtpc19pbnN0YWJpbGl0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJ0el9ibGFja19ob2xlLWFyZXRha2lzX2luc3RhYmlsaXR5In0sIHsic291cmNlIjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAidGFyZ2V0IjogImFyZXRha2lzX2luc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGVydHVyYmF0aW9uX3RoZW9yeS1hcmV0YWtpc19pbnN0YWJpbGl0eSJ9LCB7InNvdXJjZSI6ICJmb3VyaWVyX2xhcGxhY2UiLCAidGFyZ2V0IjogImFyZXRha2lzX2luc3RhYmlsaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZm91cmllcl9sYXBsYWNlLWFyZXRha2lzX2luc3RhYmlsaXR5In0sIHsic291cmNlIjogImFyZXRha2lzX2luc3RhYmlsaXR5IiwgInRhcmdldCI6ICJwX3JuYWRzNSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImFyZXRha2lzX2luc3RhYmlsaXR5LXBfcm5hZHM1In0sIHsic291cmNlIjogImFkc19jZnQiLCAidGFyZ2V0IjogInBfcm5hZHM1IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYWRzX2NmdC1wX3JuYWRzNSJ9LCB7InNvdXJjZSI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAidGFyZ2V0IjogInBfcm5hZHM1IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LXBfcm5hZHM1In0sIHsic291cmNlIjogInBfcm5hZHM1IiwgInRhcmdldCI6ICJjcml0aWNhbF9waGVub21lbmFfc2NhbGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInBfcm5hZHM1LWNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIn0sIHsic291cmNlIjogImJvdHRvbV91cF9hcHByb2FjaCIsICJ0YXJnZXQiOiAiY3JpdGljYWxfcGhlbm9tZW5hX3NjYWxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtY3JpdGljYWxfcGhlbm9tZW5hX3NjYWxpbmcifSwgeyJzb3VyY2UiOiAiYWRzX2NmdCIsICJ0YXJnZXQiOiAiY3JpdGljYWxfcGhlbm9tZW5hX3NjYWxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJhZHNfY2Z0LWNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogImNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3RhdGlzdGljcy1jcml0aWNhbF9waGVub21lbmFfc2NhbGluZyJ9LCB7InNvdXJjZSI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAidGFyZ2V0IjogImNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYWdlbnRfYmFzZWRfbW9kZWxsaW5nLWNyaXRpY2FsX3BoZW5vbWVuYV9zY2FsaW5nIn0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJzYW1fZ3JhbGxhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidW9mYV9lZHVjYXRpb24tc2FtX2dyYWxsYSJ9LCB7InNvdXJjZSI6ICJzZWxmX2ZvcmNlIiwgInRhcmdldCI6ICJzYW1fZ3JhbGxhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic2VsZl9mb3JjZS1zYW1fZ3JhbGxhIn0sIHsic291cmNlIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInRhcmdldCI6ICJzYW1fZ3JhbGxhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHktc2FtX2dyYWxsYSJ9LCB7InNvdXJjZSI6ICJ0dWNzb24iLCAidGFyZ2V0IjogInNhbV9ncmFsbGEiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dWNzb24tc2FtX2dyYWxsYSJ9LCB7InNvdXJjZSI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAidGFyZ2V0IjogInNhbV9ncmFsbGEiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnktc2FtX2dyYWxsYSJ9LCB7InNvdXJjZSI6ICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJ0YXJnZXQiOiAiYWRzX2NmdCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5LWFkc19jZnQifSwgeyJzb3VyY2UiOiAicF9ybmFkczUiLCAidGFyZ2V0IjogImFkc19jZnQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwX3JuYWRzNS1hZHNfY2Z0In0sIHsic291cmNlIjogImNvbXBsZXhfYW5hbHlzaXMiLCAidGFyZ2V0IjogImFkc19jZnQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLWFkc19jZnQifSwgeyJzb3VyY2UiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5IiwgInRhcmdldCI6ICJhZHNfY2Z0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LWFkc19jZnQifSwgeyJzb3VyY2UiOiAiZGV0bGVmX2R1cnIiLCAidGFyZ2V0IjogImJvdHRvbV91cF9hcHByb2FjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRldGxlZl9kdXJyLWJvdHRvbV91cF9hcHByb2FjaCJ9LCB7InNvdXJjZSI6ICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAidGFyZ2V0IjogImJvdHRvbV91cF9hcHByb2FjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInBoaWxvc29waHlfcGh5c2ljcy1ib3R0b21fdXBfYXBwcm9hY2gifSwgeyJzb3VyY2UiOiAiYWdlbnRfYmFzZWRfbW9kZWxsaW5nIiwgInRhcmdldCI6ICJib3R0b21fdXBfYXBwcm9hY2giLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmctYm90dG9tX3VwX2FwcHJvYWNoIn0sIHsic291cmNlIjogInJlaW5mb3JjZW1lbnRfbGVhcm5pbmciLCAidGFyZ2V0IjogImJvdHRvbV91cF9hcHByb2FjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlaW5mb3JjZW1lbnRfbGVhcm5pbmctYm90dG9tX3VwX2FwcHJvYWNoIn0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInRvcF9kb3duX2FwcHJvYWNoIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZS10b3BfZG93bl9hcHByb2FjaCJ9LCB7InNvdXJjZSI6ICJzdGF0aXN0aWNzIiwgInRhcmdldCI6ICJ0b3BfZG93bl9hcHByb2FjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtdG9wX2Rvd25fYXBwcm9hY2gifSwgeyJzb3VyY2UiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJ0YXJnZXQiOiAidG9wX2Rvd25fYXBwcm9hY2giLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJleHBlcmltZW50YWxfZGVzaWduLXRvcF9kb3duX2FwcHJvYWNoIn0sIHsic291cmNlIjogInF1YW50dW1fZm91bmRhdGlvbnMiLCAidGFyZ2V0IjogInBoaWxvc29waHlfcGh5c2ljcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInF1YW50dW1fZm91bmRhdGlvbnMtcGhpbG9zb3BoeV9waHlzaWNzIn0sIHsic291cmNlIjogImRldGxlZl9kdXJyIiwgInRhcmdldCI6ICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkZXRsZWZfZHVyci1waGlsb3NvcGh5X3BoeXNpY3MifSwgeyJzb3VyY2UiOiAibXVuaWNoIiwgInRhcmdldCI6ICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtdW5pY2gtcGhpbG9zb3BoeV9waHlzaWNzIn0sIHsic291cmNlIjogImJpdHNfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJwaGlsb3NvcGh5X3BoeXNpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1waGlsb3NvcGh5X3BoeXNpY3MifSwgeyJzb3VyY2UiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHkiLCAidGFyZ2V0IjogInB1YmxpY2F0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5LXB1YmxpY2F0aW9ucyJ9LCB7InNvdXJjZSI6ICJhcmV0YWtpc19pbnN0YWJpbGl0eSIsICJ0YXJnZXQiOiAicHVibGljYXRpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYXJldGFraXNfaW5zdGFiaWxpdHktcHVibGljYXRpb25zIn0sIHsic291cmNlIjogImJ0el9ibGFja19ob2xlIiwgInRhcmdldCI6ICJwdWJsaWNhdGlvbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJidHpfYmxhY2tfaG9sZS1wdWJsaWNhdGlvbnMifSwgeyJzb3VyY2UiOiAicF9ybmFkczUiLCAidGFyZ2V0IjogInB1YmxpY2F0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInBfcm5hZHM1LXB1YmxpY2F0aW9ucyJ9LCB7InNvdXJjZSI6ICJsYXRleCIsICJ0YXJnZXQiOiAicHVibGljYXRpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGF0ZXgtcHVibGljYXRpb25zIn0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogInB1YmxpY2F0aW9ucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNhbV9ncmFsbGEtcHVibGljYXRpb25zIn0sIHsic291cmNlIjogInB1YmxpY2F0aW9ucyIsICJ0YXJnZXQiOiAiY29uZmVyZW5jZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwdWJsaWNhdGlvbnMtY29uZmVyZW5jZXMifSwgeyJzb3VyY2UiOiAiaW52aXRlZF90YWxrcyIsICJ0YXJnZXQiOiAiY29uZmVyZW5jZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJpbnZpdGVkX3RhbGtzLWNvbmZlcmVuY2VzIn0sIHsic291cmNlIjogImxhdGV4IiwgInRhcmdldCI6ICJjb25mZXJlbmNlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxhdGV4LWNvbmZlcmVuY2VzIn0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJjb25mZXJlbmNlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInVvZmFfZWR1Y2F0aW9uLWNvbmZlcmVuY2VzIn0sIHsic291cmNlIjogImNvbmZlcmVuY2VzIiwgInRhcmdldCI6ICJpbnZpdGVkX3RhbGtzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY29uZmVyZW5jZXMtaW52aXRlZF90YWxrcyJ9LCB7InNvdXJjZSI6ICJwdWJsaWNhdGlvbnMiLCAidGFyZ2V0IjogImludml0ZWRfdGFsa3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwdWJsaWNhdGlvbnMtaW52aXRlZF90YWxrcyJ9LCB7InNvdXJjZSI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInRhcmdldCI6ICJpbnZpdGVkX3RhbGtzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucy1pbnZpdGVkX3RhbGtzIn0sIHsic291cmNlIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInRhcmdldCI6ICJpbnZpdGVkX3RhbGtzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHktaW52aXRlZF90YWxrcyJ9LCB7InNvdXJjZSI6ICJiaXRzX2VkdWNhdGlvbiIsICJ0YXJnZXQiOiAidW9mYV9lZHVjYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi11b2ZhX2VkdWNhdGlvbiJ9LCB7InNvdXJjZSI6ICJ0dWNzb24iLCAidGFyZ2V0IjogInVvZmFfZWR1Y2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVjc29uLXVvZmFfZWR1Y2F0aW9uIn0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogInVvZmFfZWR1Y2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic2FtX2dyYWxsYS11b2ZhX2VkdWNhdGlvbiJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogInVvZmFfZWR1Y2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLXVvZmFfZWR1Y2F0aW9uIn0sIHsic291cmNlIjogImh5ZGVyYWJhZCIsICJ0YXJnZXQiOiAiYml0c19lZHVjYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJoeWRlcmFiYWQtYml0c19lZHVjYXRpb24ifSwgeyJzb3VyY2UiOiAiY2FsY3VsdXMiLCAidGFyZ2V0IjogImJpdHNfZWR1Y2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2FsY3VsdXMtYml0c19lZHVjYXRpb24ifSwgeyJzb3VyY2UiOiAibGluZWFyX2FsZ2VicmEiLCAidGFyZ2V0IjogImJpdHNfZWR1Y2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGluZWFyX2FsZ2VicmEtYml0c19lZHVjYXRpb24ifSwgeyJzb3VyY2UiOiAiY29tcGxleF9hbmFseXNpcyIsICJ0YXJnZXQiOiAiYml0c19lZHVjYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLWJpdHNfZWR1Y2F0aW9uIn0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJncmFkdWF0ZV9yZXNlYXJjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInVvZmFfZWR1Y2F0aW9uLWdyYWR1YXRlX3Jlc2VhcmNoIn0sIHsic291cmNlIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5IiwgInRhcmdldCI6ICJncmFkdWF0ZV9yZXNlYXJjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJsYWNrX2hvbGVfc3RhYmlsaXR5LWdyYWR1YXRlX3Jlc2VhcmNoIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiZ3JhZHVhdGVfcmVzZWFyY2giLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZ3JhZHVhdGVfcmVzZWFyY2gifSwgeyJzb3VyY2UiOiAibWF0aGVtYXRpY2EiLCAidGFyZ2V0IjogImdyYWR1YXRlX3Jlc2VhcmNoIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibWF0aGVtYXRpY2EtZ3JhZHVhdGVfcmVzZWFyY2gifSwgeyJzb3VyY2UiOiAiZGV0bGVmX2R1cnIiLCAidGFyZ2V0IjogIm1hc3RlcnNfdGhlc2lzX2xtdSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRldGxlZl9kdXJyLW1hc3RlcnNfdGhlc2lzX2xtdSJ9LCB7InNvdXJjZSI6ICJtdW5pY2giLCAidGFyZ2V0IjogIm1hc3RlcnNfdGhlc2lzX2xtdSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm11bmljaC1tYXN0ZXJzX3RoZXNpc19sbXUifSwgeyJzb3VyY2UiOiAicXVhbnR1bV9mb3VuZGF0aW9ucyIsICJ0YXJnZXQiOiAibWFzdGVyc190aGVzaXNfbG11IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicXVhbnR1bV9mb3VuZGF0aW9ucy1tYXN0ZXJzX3RoZXNpc19sbXUifSwgeyJzb3VyY2UiOiAibGF0ZXgiLCAidGFyZ2V0IjogIm1hc3RlcnNfdGhlc2lzX2xtdSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxhdGV4LW1hc3RlcnNfdGhlc2lzX2xtdSJ9LCB7InNvdXJjZSI6ICJ1b2ZhX2VkdWNhdGlvbiIsICJ0YXJnZXQiOiAidGVhY2hpbmdfdW9mYSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInVvZmFfZWR1Y2F0aW9uLXRlYWNoaW5nX3VvZmEifSwgeyJzb3VyY2UiOiAidHVjc29uIiwgInRhcmdldCI6ICJ0ZWFjaGluZ191b2ZhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVjc29uLXRlYWNoaW5nX3VvZmEifSwgeyJzb3VyY2UiOiAiY2FsY3VsdXMiLCAidGFyZ2V0IjogInRlYWNoaW5nX3VvZmEiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjYWxjdWx1cy10ZWFjaGluZ191b2ZhIn0sIHsic291cmNlIjogImxpbmVhcl9hbGdlYnJhIiwgInRhcmdldCI6ICJ0ZWFjaGluZ191b2ZhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGluZWFyX2FsZ2VicmEtdGVhY2hpbmdfdW9mYSJ9LCB7InNvdXJjZSI6ICJtdW5pY2giLCAidGFyZ2V0IjogImZhc2NpbmF0aW9uX2xlYXJuaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibXVuaWNoLWZhc2NpbmF0aW9uX2xlYXJuaW5nIn0sIHsic291cmNlIjogInBoaWxvc29waHlfcGh5c2ljcyIsICJ0YXJnZXQiOiAiZmFzY2luYXRpb25fbGVhcm5pbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwaGlsb3NvcGh5X3BoeXNpY3MtZmFzY2luYXRpb25fbGVhcm5pbmcifSwgeyJzb3VyY2UiOiAiYm90dG9tX3VwX2FwcHJvYWNoIiwgInRhcmdldCI6ICJmYXNjaW5hdGlvbl9sZWFybmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJvdHRvbV91cF9hcHByb2FjaC1mYXNjaW5hdGlvbl9sZWFybmluZyJ9LCB7InNvdXJjZSI6ICJ2YW5jb3V2ZXIiLCAidGFyZ2V0IjogInR1cm5vX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ2YW5jb3V2ZXItdHVybm9fZXhwZXJpZW5jZSJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJ0dXJub19leHBlcmllbmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS10dXJub19leHBlcmllbmNlIn0sIHsic291cmNlIjogInJlY29tbWVuZGF0aW9uX3N5c3RlbXMiLCAidGFyZ2V0IjogInR1cm5vX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zLXR1cm5vX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAiZ2FtZV90aGVvcnkiLCAidGFyZ2V0IjogInR1cm5vX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJnYW1lX3RoZW9yeS10dXJub19leHBlcmllbmNlIn0sIHsic291cmNlIjogIm1hcmtldHBsYWNlcyIsICJ0YXJnZXQiOiAidHVybm9fZXhwZXJpZW5jZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm1hcmtldHBsYWNlcy10dXJub19leHBlcmllbmNlIn0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInJvdmVyX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlLXJvdmVyX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAic2VhdHRsZSIsICJ0YXJnZXQiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNlYXR0bGUtcm92ZXJfZXhwZXJpZW5jZSJ9LCB7InNvdXJjZSI6ICJzY2hudWNraSIsICJ0YXJnZXQiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNjaG51Y2tpLXJvdmVyX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAibWFya2V0cGxhY2VzIiwgInRhcmdldCI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibWFya2V0cGxhY2VzLXJvdmVyX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLXJvdmVyX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAic3FsIiwgInRhcmdldCI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3FsLXJvdmVyX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAidW9mYV9lZHVjYXRpb24iLCAidGFyZ2V0IjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ1b2ZhX2VkdWNhdGlvbi1kYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1kYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGF0aXN0aWNzLWRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAidG9wX2Rvd25fYXBwcm9hY2giLCAidGFyZ2V0IjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0b3BfZG93bl9hcHByb2FjaC1kYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIn0sIHsic291cmNlIjogInNlYXR0bGUiLCAidGFyZ2V0IjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzZWF0dGxlLWRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UifSwgeyJzb3VyY2UiOiAiYmxhY2tfaG9sZV9zdGFiaWxpdHkiLCAidGFyZ2V0IjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJibGFja19ob2xlX3N0YWJpbGl0eS1wZXJ0dXJiYXRpb25fdGhlb3J5In0sIHsic291cmNlIjogImNvbXBsZXhfYW5hbHlzaXMiLCAidGFyZ2V0IjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLXBlcnR1cmJhdGlvbl90aGVvcnkifSwgeyJzb3VyY2UiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5IiwgInRhcmdldCI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LXBlcnR1cmJhdGlvbl90aGVvcnkifSwgeyJzb3VyY2UiOiAiZm91cmllcl9sYXBsYWNlIiwgInRhcmdldCI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZm91cmllcl9sYXBsYWNlLXBlcnR1cmJhdGlvbl90aGVvcnkifSwgeyJzb3VyY2UiOiAiYml0c19lZHVjYXRpb24iLCAidGFyZ2V0IjogImNvbXBsZXhfYW5hbHlzaXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1jb21wbGV4X2FuYWx5c2lzIn0sIHsic291cmNlIjogImNhbGN1bHVzIiwgInRhcmdldCI6ICJjb21wbGV4X2FuYWx5c2lzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2FsY3VsdXMtY29tcGxleF9hbmFseXNpcyJ9LCB7InNvdXJjZSI6ICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJ0YXJnZXQiOiAiY29tcGxleF9hbmFseXNpcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNwZWNpYWxfZnVuY3Rpb25zLWNvbXBsZXhfYW5hbHlzaXMifSwgeyJzb3VyY2UiOiAiZm91cmllcl9sYXBsYWNlIiwgInRhcmdldCI6ICJjb21wbGV4X2FuYWx5c2lzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZm91cmllcl9sYXBsYWNlLWNvbXBsZXhfYW5hbHlzaXMifSwgeyJzb3VyY2UiOiAiY29tcGxleF9hbmFseXNpcyIsICJ0YXJnZXQiOiAic3BlY2lhbF9mdW5jdGlvbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLXNwZWNpYWxfZnVuY3Rpb25zIn0sIHsic291cmNlIjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAidGFyZ2V0IjogInNwZWNpYWxfZnVuY3Rpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicGVydHVyYmF0aW9uX3RoZW9yeS1zcGVjaWFsX2Z1bmN0aW9ucyJ9LCB7InNvdXJjZSI6ICJtYXRoZW1hdGljYSIsICJ0YXJnZXQiOiAic3BlY2lhbF9mdW5jdGlvbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtYXRoZW1hdGljYS1zcGVjaWFsX2Z1bmN0aW9ucyJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogInNwZWNpYWxfZnVuY3Rpb25zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLXNwZWNpYWxfZnVuY3Rpb25zIn0sIHsic291cmNlIjogImNvbXBsZXhfYW5hbHlzaXMiLCAidGFyZ2V0IjogImZvdXJpZXJfbGFwbGFjZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNvbXBsZXhfYW5hbHlzaXMtZm91cmllcl9sYXBsYWNlIn0sIHsic291cmNlIjogInBlcnR1cmJhdGlvbl90aGVvcnkiLCAidGFyZ2V0IjogImZvdXJpZXJfbGFwbGFjZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInBlcnR1cmJhdGlvbl90aGVvcnktZm91cmllcl9sYXBsYWNlIn0sIHsic291cmNlIjogImlzYWlfcHJvamVjdCIsICJ0YXJnZXQiOiAiZm91cmllcl9sYXBsYWNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiaXNhaV9wcm9qZWN0LWZvdXJpZXJfbGFwbGFjZSJ9LCB7InNvdXJjZSI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJ0YXJnZXQiOiAiZm91cmllcl9sYXBsYWNlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidGltZV9zZXJpZXNfZm9yZWNhc3RpbmctZm91cmllcl9sYXBsYWNlIn0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ1b2ZhX2VkdWNhdGlvbi1kaWZmZXJlbnRpYWxfZ2VvbWV0cnkifSwgeyJzb3VyY2UiOiAibGluZWFyX2FsZ2VicmEiLCAidGFyZ2V0IjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxpbmVhcl9hbGdlYnJhLWRpZmZlcmVudGlhbF9nZW9tZXRyeSJ9LCB7InNvdXJjZSI6ICJjYWxjdWx1cyIsICJ0YXJnZXQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2FsY3VsdXMtZGlmZmVyZW50aWFsX2dlb21ldHJ5In0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNhbV9ncmFsbGEtZGlmZmVyZW50aWFsX2dlb21ldHJ5In0sIHsic291cmNlIjogImJpdHNfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJjYWxjdWx1cyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJpdHNfZWR1Y2F0aW9uLWNhbGN1bHVzIn0sIHsic291cmNlIjogIm1hZ25ldGljX21vbm9wb2xlcyIsICJ0YXJnZXQiOiAiY2FsY3VsdXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtYWduZXRpY19tb25vcG9sZXMtY2FsY3VsdXMifSwgeyJzb3VyY2UiOiAiY29tcGxleF9hbmFseXNpcyIsICJ0YXJnZXQiOiAiY2FsY3VsdXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb21wbGV4X2FuYWx5c2lzLWNhbGN1bHVzIn0sIHsic291cmNlIjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJ0YXJnZXQiOiAiY2FsY3VsdXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnktY2FsY3VsdXMifSwgeyJzb3VyY2UiOiAiYml0c19lZHVjYXRpb24iLCAidGFyZ2V0IjogImxpbmVhcl9hbGdlYnJhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYml0c19lZHVjYXRpb24tbGluZWFyX2FsZ2VicmEifSwgeyJzb3VyY2UiOiAiY2FsY3VsdXMiLCAidGFyZ2V0IjogImxpbmVhcl9hbGdlYnJhIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2FsY3VsdXMtbGluZWFyX2FsZ2VicmEifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJsaW5lYXJfYWxnZWJyYSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1saW5lYXJfYWxnZWJyYSJ9LCB7InNvdXJjZSI6ICJjbGFzc2lmaWNhdGlvbiIsICJ0YXJnZXQiOiAibGluZWFyX2FsZ2VicmEiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjbGFzc2lmaWNhdGlvbi1saW5lYXJfYWxnZWJyYSJ9LCB7InNvdXJjZSI6ICJyZWdyZXNzaW9uIiwgInRhcmdldCI6ICJsaW5lYXJfYWxnZWJyYSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlZ3Jlc3Npb24tbGluZWFyX2FsZ2VicmEifSwgeyJzb3VyY2UiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAic3RhdGlzdGljcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2Utc3RhdGlzdGljcyJ9LCB7InNvdXJjZSI6ICJleHBlcmltZW50YWxfZGVzaWduIiwgInRhcmdldCI6ICJzdGF0aXN0aWNzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbi1zdGF0aXN0aWNzIn0sIHsic291cmNlIjogImJheWVzaWFuX3N0YXRpc3RpY3MiLCAidGFyZ2V0IjogInN0YXRpc3RpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiYXllc2lhbl9zdGF0aXN0aWNzLXN0YXRpc3RpY3MifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJzdGF0aXN0aWNzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLXN0YXRpc3RpY3MifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZ2FtZV90aGVvcnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLWdhbWVfdGhlb3J5In0sIHsic291cmNlIjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMiLCAidGFyZ2V0IjogImdhbWVfdGhlb3J5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGVjaXNpb25fbWFraW5nX2FnZW50cy1nYW1lX3RoZW9yeSJ9LCB7InNvdXJjZSI6ICJhdWN0aW9uc19kZXNpZ24iLCAidGFyZ2V0IjogImdhbWVfdGhlb3J5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYXVjdGlvbnNfZGVzaWduLWdhbWVfdGhlb3J5In0sIHsic291cmNlIjogIm1hcmtldHBsYWNlcyIsICJ0YXJnZXQiOiAiZ2FtZV90aGVvcnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtYXJrZXRwbGFjZXMtZ2FtZV90aGVvcnkifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAicmVjb21tZW5kYXRpb25fc3lzdGVtcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtcmVjb21tZW5kYXRpb25fc3lzdGVtcyJ9LCB7InNvdXJjZSI6ICJ0dXJub19leHBlcmllbmNlIiwgInRhcmdldCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVybm9fZXhwZXJpZW5jZS1yZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAicmVjb21tZW5kYXRpb25fc3lzdGVtcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1yZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIn0sIHsic291cmNlIjogImNsYXNzaWZpY2F0aW9uIiwgInRhcmdldCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2xhc3NpZmljYXRpb24tcmVjb21tZW5kYXRpb25fc3lzdGVtcyJ9LCB7InNvdXJjZSI6ICJsZWFybl90b19yYW5rIiwgInRhcmdldCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGVhcm5fdG9fcmFuay1yZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIn0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImNsdXN0ZXJpbmdfYWxnb3JpdGhtcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UtY2x1c3RlcmluZ19hbGdvcml0aG1zIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiY2x1c3RlcmluZ19hbGdvcml0aG1zIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLWNsdXN0ZXJpbmdfYWxnb3JpdGhtcyJ9LCB7InNvdXJjZSI6ICJnZW9zcGF0aWFsX2FuYWx5c2lzIiwgInRhcmdldCI6ICJjbHVzdGVyaW5nX2FsZ29yaXRobXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJnZW9zcGF0aWFsX2FuYWx5c2lzLWNsdXN0ZXJpbmdfYWxnb3JpdGhtcyJ9LCB7InNvdXJjZSI6ICJzZW1hbnRpY19zZWFyY2giLCAidGFyZ2V0IjogImNsdXN0ZXJpbmdfYWxnb3JpdGhtcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNlbWFudGljX3NlYXJjaC1jbHVzdGVyaW5nX2FsZ29yaXRobXMifSwgeyJzb3VyY2UiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiY2xhc3NpZmljYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlLWNsYXNzaWZpY2F0aW9uIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiY2xhc3NpZmljYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tY2xhc3NpZmljYXRpb24ifSwgeyJzb3VyY2UiOiAibGluZWFyX2FsZ2VicmEiLCAidGFyZ2V0IjogImNsYXNzaWZpY2F0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGluZWFyX2FsZ2VicmEtY2xhc3NpZmljYXRpb24ifSwgeyJzb3VyY2UiOiAic3RhdGlzdGljcyIsICJ0YXJnZXQiOiAiY2xhc3NpZmljYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGF0aXN0aWNzLWNsYXNzaWZpY2F0aW9uIn0sIHsic291cmNlIjogImlzYWlfcHJvamVjdCIsICJ0YXJnZXQiOiAiY2xhc3NpZmljYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJpc2FpX3Byb2plY3QtY2xhc3NpZmljYXRpb24ifSwgeyJzb3VyY2UiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAicmVncmVzc2lvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UtcmVncmVzc2lvbiJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogInJlZ3Jlc3Npb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tcmVncmVzc2lvbiJ9LCB7InNvdXJjZSI6ICJsaW5lYXJfYWxnZWJyYSIsICJ0YXJnZXQiOiAicmVncmVzc2lvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxpbmVhcl9hbGdlYnJhLXJlZ3Jlc3Npb24ifSwgeyJzb3VyY2UiOiAic3RhdGlzdGljcyIsICJ0YXJnZXQiOiAicmVncmVzc2lvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtcmVncmVzc2lvbiJ9LCB7InNvdXJjZSI6ICJwcmljaW5nX2VsYXN0aWNpdHkiLCAidGFyZ2V0IjogInJlZ3Jlc3Npb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwcmljaW5nX2VsYXN0aWNpdHktcmVncmVzc2lvbiJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtdGltZV9zZXJpZXNfZm9yZWNhc3RpbmcifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi10aW1lX3Nlcmllc19mb3JlY2FzdGluZyJ9LCB7InNvdXJjZSI6ICJzdGF0aXN0aWNzIiwgInRhcmdldCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtdGltZV9zZXJpZXNfZm9yZWNhc3RpbmcifSwgeyJzb3VyY2UiOiAiZm91cmllcl9sYXBsYWNlIiwgInRhcmdldCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImZvdXJpZXJfbGFwbGFjZS10aW1lX3Nlcmllc19mb3JlY2FzdGluZyJ9LCB7InNvdXJjZSI6ICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0IiwgInRhcmdldCI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN1cHBseV9kZW1hbmRfZm9yZWNhc3QtdGltZV9zZXJpZXNfZm9yZWNhc3RpbmcifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAibWFya292X2NoYWluX21vZGVscyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtbWFya292X2NoYWluX21vZGVscyJ9LCB7InNvdXJjZSI6ICJzdGF0aXN0aWNzIiwgInRhcmdldCI6ICJtYXJrb3ZfY2hhaW5fbW9kZWxzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3RhdGlzdGljcy1tYXJrb3ZfY2hhaW5fbW9kZWxzIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAibWFya292X2NoYWluX21vZGVscyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1tYXJrb3ZfY2hhaW5fbW9kZWxzIn0sIHsic291cmNlIjogInN1cHBseV9kZW1hbmRfZm9yZWNhc3QiLCAidGFyZ2V0IjogIm1hcmtvdl9jaGFpbl9tb2RlbHMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0LW1hcmtvdl9jaGFpbl9tb2RlbHMifSwgeyJzb3VyY2UiOiAicmVjb21tZW5kYXRpb25fc3lzdGVtcyIsICJ0YXJnZXQiOiAibGVhcm5fdG9fcmFuayIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlY29tbWVuZGF0aW9uX3N5c3RlbXMtbGVhcm5fdG9fcmFuayJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImxlYXJuX3RvX3JhbmsiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tbGVhcm5fdG9fcmFuayJ9LCB7InNvdXJjZSI6ICJjbGFzc2lmaWNhdGlvbiIsICJ0YXJnZXQiOiAibGVhcm5fdG9fcmFuayIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNsYXNzaWZpY2F0aW9uLWxlYXJuX3RvX3JhbmsifSwgeyJzb3VyY2UiOiAiYm90dG9tX3VwX2FwcHJvYWNoIiwgInRhcmdldCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtYWdlbnRfYmFzZWRfbW9kZWxsaW5nIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiYWdlbnRfYmFzZWRfbW9kZWxsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLWFnZW50X2Jhc2VkX21vZGVsbGluZyJ9LCB7InNvdXJjZSI6ICJlcGlkZW1pY19zaW11bGF0aW9uIiwgInRhcmdldCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJlcGlkZW1pY19zaW11bGF0aW9uLWFnZW50X2Jhc2VkX21vZGVsbGluZyJ9LCB7InNvdXJjZSI6ICJkZWNpc2lvbl9tYWtpbmdfYWdlbnRzIiwgInRhcmdldCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkZWNpc2lvbl9tYWtpbmdfYWdlbnRzLWFnZW50X2Jhc2VkX21vZGVsbGluZyJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJleHBlcmltZW50YWxfZGVzaWduIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1leHBlcmltZW50YWxfZGVzaWduIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGF0aXN0aWNzLWV4cGVyaW1lbnRhbF9kZXNpZ24ifSwgeyJzb3VyY2UiOiAiYmF5ZXNpYW5fc3RhdGlzdGljcyIsICJ0YXJnZXQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJheWVzaWFuX3N0YXRpc3RpY3MtZXhwZXJpbWVudGFsX2Rlc2lnbiJ9LCB7InNvdXJjZSI6ICJtYXJrZXRwbGFjZV9pbmZsYXRpb25fcmVjcyIsICJ0YXJnZXQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogIm1hcmtldHBsYWNlX2luZmxhdGlvbl9yZWNzLWV4cGVyaW1lbnRhbF9kZXNpZ24ifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZXhwZXJpbWVudGF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1leHBlcmltZW50YXRpb24ifSwgeyJzb3VyY2UiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJ0YXJnZXQiOiAiZXhwZXJpbWVudGF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbi1leHBlcmltZW50YXRpb24ifSwgeyJzb3VyY2UiOiAic3RhdGlzdGljcyIsICJ0YXJnZXQiOiAiZXhwZXJpbWVudGF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAic3RhdGlzdGljcy1leHBlcmltZW50YXRpb24ifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJleHBlcmltZW50YXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZXhwZXJpbWVudGF0aW9uIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogImJheWVzaWFuX3N0YXRpc3RpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGF0aXN0aWNzLWJheWVzaWFuX3N0YXRpc3RpY3MifSwgeyJzb3VyY2UiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJ0YXJnZXQiOiAiYmF5ZXNpYW5fc3RhdGlzdGljcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImV4cGVyaW1lbnRhbF9kZXNpZ24tYmF5ZXNpYW5fc3RhdGlzdGljcyJ9LCB7InNvdXJjZSI6ICJsdHZfbW9kZWxpbmciLCAidGFyZ2V0IjogImJheWVzaWFuX3N0YXRpc3RpY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJsdHZfbW9kZWxpbmctYmF5ZXNpYW5fc3RhdGlzdGljcyJ9LCB7InNvdXJjZSI6ICJiaXRzX2VkdWNhdGlvbiIsICJ0YXJnZXQiOiAibGF0ZXgiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1sYXRleCJ9LCB7InNvdXJjZSI6ICJxdWFudHVtX2ZvdW5kYXRpb25zIiwgInRhcmdldCI6ICJsYXRleCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInF1YW50dW1fZm91bmRhdGlvbnMtbGF0ZXgifSwgeyJzb3VyY2UiOiAicHVibGljYXRpb25zIiwgInRhcmdldCI6ICJsYXRleCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB1YmxpY2F0aW9ucy1sYXRleCJ9LCB7InNvdXJjZSI6ICJjb25mZXJlbmNlcyIsICJ0YXJnZXQiOiAibGF0ZXgiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjb25mZXJlbmNlcy1sYXRleCJ9LCB7InNvdXJjZSI6ICJiaXRzX2VkdWNhdGlvbiIsICJ0YXJnZXQiOiAibWF0aGVtYXRpY2EiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1tYXRoZW1hdGljYSJ9LCB7InNvdXJjZSI6ICJzcGVjaWFsX2Z1bmN0aW9ucyIsICJ0YXJnZXQiOiAibWF0aGVtYXRpY2EiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzcGVjaWFsX2Z1bmN0aW9ucy1tYXRoZW1hdGljYSJ9LCB7InNvdXJjZSI6ICJibGFja19ob2xlX3N0YWJpbGl0eSIsICJ0YXJnZXQiOiAibWF0aGVtYXRpY2EiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJibGFja19ob2xlX3N0YWJpbGl0eS1tYXRoZW1hdGljYSJ9LCB7InNvdXJjZSI6ICJjb21wbGV4X2FuYWx5c2lzIiwgInRhcmdldCI6ICJtYXRoZW1hdGljYSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNvbXBsZXhfYW5hbHlzaXMtbWF0aGVtYXRpY2EifSwgeyJzb3VyY2UiOiAidW9mYV9lZHVjYXRpb24iLCAidGFyZ2V0IjogInB5dGhvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInVvZmFfZWR1Y2F0aW9uLXB5dGhvbiJ9LCB7InNvdXJjZSI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJweXRob24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlLXB5dGhvbiJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJweXRob24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLXB5dGhvbiJ9LCB7InNvdXJjZSI6ICJsaW5lYXJfYWxnZWJyYSIsICJ0YXJnZXQiOiAicHl0aG9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGluZWFyX2FsZ2VicmEtcHl0aG9uIn0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInNxbCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2Utc3FsIn0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInNxbCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2Utc3FsIn0sIHsic291cmNlIjogImRhdGFfZW5naW5lZXJpbmciLCAidGFyZ2V0IjogInNxbCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfZW5naW5lZXJpbmctc3FsIn0sIHsic291cmNlIjogInVvZmFfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJnaXQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ1b2ZhX2VkdWNhdGlvbi1naXQifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJnaXQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZ2l0In0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImdpdCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UtZ2l0In0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImF3c19nY3AiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLWF3c19nY3AifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiYXdzX2djcCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtYXdzX2djcCJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImF3c19nY3AiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tYXdzX2djcCJ9LCB7InNvdXJjZSI6ICJkYXRhX2VuZ2luZWVyaW5nIiwgInRhcmdldCI6ICJhd3NfZ2NwIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGF0YV9lbmdpbmVlcmluZy1hd3NfZ2NwIn0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImRhZ3N0ZXJfYWlyZmxvdyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtZGFnc3Rlcl9haXJmbG93In0sIHsic291cmNlIjogInR1cm5vX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImRhZ3N0ZXJfYWlyZmxvdyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtZGFnc3Rlcl9haXJmbG93In0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiZGFnc3Rlcl9haXJmbG93IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLWRhZ3N0ZXJfYWlyZmxvdyJ9LCB7InNvdXJjZSI6ICJkYXRhX2VuZ2luZWVyaW5nIiwgInRhcmdldCI6ICJkYWdzdGVyX2FpcmZsb3ciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkYXRhX2VuZ2luZWVyaW5nLWRhZ3N0ZXJfYWlyZmxvdyJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJkYnQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLWRidCJ9LCB7InNvdXJjZSI6ICJ0dXJub19leHBlcmllbmNlIiwgInRhcmdldCI6ICJkYnQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLWRidCJ9LCB7InNvdXJjZSI6ICJzcWwiLCAidGFyZ2V0IjogImRidCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNxbC1kYnQifSwgeyJzb3VyY2UiOiAiZGF0YV9lbmdpbmVlcmluZyIsICJ0YXJnZXQiOiAiZGJ0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGF0YV9lbmdpbmVlcmluZy1kYnQifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAidGFibGVhdV9tb2RlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS10YWJsZWF1X21vZGUifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAidGFibGVhdV9tb2RlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVybm9fZXhwZXJpZW5jZS10YWJsZWF1X21vZGUifSwgeyJzb3VyY2UiOiAic3FsIiwgInRhcmdldCI6ICJ0YWJsZWF1X21vZGUiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzcWwtdGFibGVhdV9tb2RlIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogInRhYmxlYXVfbW9kZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtdGFibGVhdV9tb2RlIn0sIHsic291cmNlIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImlzYWlfcHJvamVjdCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UtaXNhaV9wcm9qZWN0In0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiaXNhaV9wcm9qZWN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLWlzYWlfcHJvamVjdCJ9LCB7InNvdXJjZSI6ICJjbGFzc2lmaWNhdGlvbiIsICJ0YXJnZXQiOiAiaXNhaV9wcm9qZWN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2xhc3NpZmljYXRpb24taXNhaV9wcm9qZWN0In0sIHsic291cmNlIjogImZvdXJpZXJfbGFwbGFjZSIsICJ0YXJnZXQiOiAiaXNhaV9wcm9qZWN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZm91cmllcl9sYXBsYWNlLWlzYWlfcHJvamVjdCJ9LCB7InNvdXJjZSI6ICJjbHVzdGVyaW5nX2FsZ29yaXRobXMiLCAidGFyZ2V0IjogImlzYWlfcHJvamVjdCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImNsdXN0ZXJpbmdfYWxnb3JpdGhtcy1pc2FpX3Byb2plY3QifSwgeyJzb3VyY2UiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZXBpZGVtaWNfc2ltdWxhdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhdGFfaW5jdWJhdG9yX2V4cGVyaWVuY2UtZXBpZGVtaWNfc2ltdWxhdGlvbiJ9LCB7InNvdXJjZSI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAidGFyZ2V0IjogImVwaWRlbWljX3NpbXVsYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmctZXBpZGVtaWNfc2ltdWxhdGlvbiJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImVwaWRlbWljX3NpbXVsYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZXBpZGVtaWNfc2ltdWxhdGlvbiJ9LCB7InNvdXJjZSI6ICJib3R0b21fdXBfYXBwcm9hY2giLCAidGFyZ2V0IjogImVwaWRlbWljX3NpbXVsYXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtZXBpZGVtaWNfc2ltdWxhdGlvbiJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1zdXBwbHlfZGVtYW5kX2ZvcmVjYXN0In0sIHsic291cmNlIjogInRpbWVfc2VyaWVzX2ZvcmVjYXN0aW5nIiwgInRhcmdldCI6ICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidGltZV9zZXJpZXNfZm9yZWNhc3Rpbmctc3VwcGx5X2RlbWFuZF9mb3JlY2FzdCJ9LCB7InNvdXJjZSI6ICJtYXJrb3ZfY2hhaW5fbW9kZWxzIiwgInRhcmdldCI6ICJzdXBwbHlfZGVtYW5kX2ZvcmVjYXN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibWFya292X2NoYWluX21vZGVscy1zdXBwbHlfZGVtYW5kX2ZvcmVjYXN0In0sIHsic291cmNlIjogImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAidGFyZ2V0IjogInN1cHBseV9kZW1hbmRfZm9yZWNhc3QiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJnZW9zcGF0aWFsX2FuYWx5c2lzLXN1cHBseV9kZW1hbmRfZm9yZWNhc3QifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZGF0YV9lbmdpbmVlcmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtZGF0YV9lbmdpbmVlcmluZyJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImRhdGFfZW5naW5lZXJpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZGF0YV9lbmdpbmVlcmluZyJ9LCB7InNvdXJjZSI6ICJzcWwiLCAidGFyZ2V0IjogImRhdGFfZW5naW5lZXJpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzcWwtZGF0YV9lbmdpbmVlcmluZyJ9LCB7InNvdXJjZSI6ICJhd3NfZ2NwIiwgInRhcmdldCI6ICJkYXRhX2VuZ2luZWVyaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYXdzX2djcC1kYXRhX2VuZ2luZWVyaW5nIn0sIHsic291cmNlIjogImRhZ3N0ZXJfYWlyZmxvdyIsICJ0YXJnZXQiOiAiZGF0YV9lbmdpbmVlcmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhZ3N0ZXJfYWlyZmxvdy1kYXRhX2VuZ2luZWVyaW5nIn0sIHsic291cmNlIjogImRidCIsICJ0YXJnZXQiOiAiZGF0YV9lbmdpbmVlcmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRidC1kYXRhX2VuZ2luZWVyaW5nIn0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogIm1hcmtldHBsYWNlX2luZmxhdGlvbl9yZWNzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1tYXJrZXRwbGFjZV9pbmZsYXRpb25fcmVjcyJ9LCB7InNvdXJjZSI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgInRhcmdldCI6ICJtYXJrZXRwbGFjZV9pbmZsYXRpb25fcmVjcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlY29tbWVuZGF0aW9uX3N5c3RlbXMtbWFya2V0cGxhY2VfaW5mbGF0aW9uX3JlY3MifSwgeyJzb3VyY2UiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbiIsICJ0YXJnZXQiOiAibWFya2V0cGxhY2VfaW5mbGF0aW9uX3JlY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJleHBlcmltZW50YWxfZGVzaWduLW1hcmtldHBsYWNlX2luZmxhdGlvbl9yZWNzIn0sIHsic291cmNlIjogImdhbWVfdGhlb3J5IiwgInRhcmdldCI6ICJtYXJrZXRwbGFjZV9pbmZsYXRpb25fcmVjcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdhbWVfdGhlb3J5LW1hcmtldHBsYWNlX2luZmxhdGlvbl9yZWNzIn0sIHsic291cmNlIjogInByaWNpbmdfZWxhc3RpY2l0eSIsICJ0YXJnZXQiOiAibWFya2V0cGxhY2VfaW5mbGF0aW9uX3JlY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwcmljaW5nX2VsYXN0aWNpdHktbWFya2V0cGxhY2VfaW5mbGF0aW9uX3JlY3MifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZ2VvX3NwbGl0X2V4cGVyaW1lbnRhdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2UtZ2VvX3NwbGl0X2V4cGVyaW1lbnRhdGlvbiJ9LCB7InNvdXJjZSI6ICJleHBlcmltZW50YWxfZGVzaWduIiwgInRhcmdldCI6ICJnZW9fc3BsaXRfZXhwZXJpbWVudGF0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZXhwZXJpbWVudGFsX2Rlc2lnbi1nZW9fc3BsaXRfZXhwZXJpbWVudGF0aW9uIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogImdlb19zcGxpdF9leHBlcmltZW50YXRpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGF0aXN0aWNzLWdlb19zcGxpdF9leHBlcmltZW50YXRpb24ifSwgeyJzb3VyY2UiOiAiZ2Vvc3BhdGlhbF9hbmFseXNpcyIsICJ0YXJnZXQiOiAiZ2VvX3NwbGl0X2V4cGVyaW1lbnRhdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdlb3NwYXRpYWxfYW5hbHlzaXMtZ2VvX3NwbGl0X2V4cGVyaW1lbnRhdGlvbiJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJmaW5hbmNpYWxfbW9kZWxsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1maW5hbmNpYWxfbW9kZWxsaW5nIn0sIHsic291cmNlIjogInR1cm5vX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImZpbmFuY2lhbF9tb2RlbGxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLWZpbmFuY2lhbF9tb2RlbGxpbmcifSwgeyJzb3VyY2UiOiAic3RhdGlzdGljcyIsICJ0YXJnZXQiOiAiZmluYW5jaWFsX21vZGVsbGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtZmluYW5jaWFsX21vZGVsbGluZyJ9LCB7InNvdXJjZSI6ICJyZWdyZXNzaW9uIiwgInRhcmdldCI6ICJmaW5hbmNpYWxfbW9kZWxsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicmVncmVzc2lvbi1maW5hbmNpYWxfbW9kZWxsaW5nIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAiZmluYW5jaWFsX21vZGVsbGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1maW5hbmNpYWxfbW9kZWxsaW5nIn0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLWdlb3NwYXRpYWxfYW5hbHlzaXMifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAiZ2Vvc3BhdGlhbF9hbmFseXNpcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtZ2Vvc3BhdGlhbF9hbmFseXNpcyJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZ2Vvc3BhdGlhbF9hbmFseXNpcyJ9LCB7InNvdXJjZSI6ICJjbHVzdGVyaW5nX2FsZ29yaXRobXMiLCAidGFyZ2V0IjogImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjbHVzdGVyaW5nX2FsZ29yaXRobXMtZ2Vvc3BhdGlhbF9hbmFseXNpcyJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJwcmljaW5nX2VsYXN0aWNpdHkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLXByaWNpbmdfZWxhc3RpY2l0eSJ9LCB7InNvdXJjZSI6ICJ0dXJub19leHBlcmllbmNlIiwgInRhcmdldCI6ICJwcmljaW5nX2VsYXN0aWNpdHkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLXByaWNpbmdfZWxhc3RpY2l0eSJ9LCB7InNvdXJjZSI6ICJnYW1lX3RoZW9yeSIsICJ0YXJnZXQiOiAicHJpY2luZ19lbGFzdGljaXR5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZ2FtZV90aGVvcnktcHJpY2luZ19lbGFzdGljaXR5In0sIHsic291cmNlIjogImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAidGFyZ2V0IjogInByaWNpbmdfZWxhc3RpY2l0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImV4cGVyaW1lbnRhbF9kZXNpZ24tcHJpY2luZ19lbGFzdGljaXR5In0sIHsic291cmNlIjogInJlZ3Jlc3Npb24iLCAidGFyZ2V0IjogInByaWNpbmdfZWxhc3RpY2l0eSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlZ3Jlc3Npb24tcHJpY2luZ19lbGFzdGljaXR5In0sIHsic291cmNlIjogInR1cm5vX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInRhbV9hbmFseXNpcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtdGFtX2FuYWx5c2lzIn0sIHsic291cmNlIjogInN0YXRpc3RpY3MiLCAidGFyZ2V0IjogInRhbV9hbmFseXNpcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YXRpc3RpY3MtdGFtX2FuYWx5c2lzIn0sIHsic291cmNlIjogImdlb3NwYXRpYWxfYW5hbHlzaXMiLCAidGFyZ2V0IjogInRhbV9hbmFseXNpcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdlb3NwYXRpYWxfYW5hbHlzaXMtdGFtX2FuYWx5c2lzIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAidGFtX2FuYWx5c2lzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicHl0aG9uLXRhbV9hbmFseXNpcyJ9LCB7InNvdXJjZSI6ICJ0dXJub19leHBlcmllbmNlIiwgInRhcmdldCI6ICJsdHZfbW9kZWxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLWx0dl9tb2RlbGluZyJ9LCB7InNvdXJjZSI6ICJyZWdyZXNzaW9uIiwgInRhcmdldCI6ICJsdHZfbW9kZWxpbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyZWdyZXNzaW9uLWx0dl9tb2RlbGluZyJ9LCB7InNvdXJjZSI6ICJ0aW1lX3Nlcmllc19mb3JlY2FzdGluZyIsICJ0YXJnZXQiOiAibHR2X21vZGVsaW5nIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidGltZV9zZXJpZXNfZm9yZWNhc3RpbmctbHR2X21vZGVsaW5nIn0sIHsic291cmNlIjogImJheWVzaWFuX3N0YXRpc3RpY3MiLCAidGFyZ2V0IjogImx0dl9tb2RlbGluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJheWVzaWFuX3N0YXRpc3RpY3MtbHR2X21vZGVsaW5nIn0sIHsic291cmNlIjogImxhcmdlX2xhbmd1YWdlX21vZGVscyIsICJ0YXJnZXQiOiAibGxtc19wcm9kdWN0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzLWxsbXNfcHJvZHVjdCJ9LCB7InNvdXJjZSI6ICJyb3Zlcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJsbG1zX3Byb2R1Y3QiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLWxsbXNfcHJvZHVjdCJ9LCB7InNvdXJjZSI6ICJ0dXJub19leHBlcmllbmNlIiwgInRhcmdldCI6ICJsbG1zX3Byb2R1Y3QiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dXJub19leHBlcmllbmNlLWxsbXNfcHJvZHVjdCJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImxsbXNfcHJvZHVjdCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1sbG1zX3Byb2R1Y3QifSwgeyJzb3VyY2UiOiAic2VtYW50aWNfc2VhcmNoIiwgInRhcmdldCI6ICJsbG1zX3Byb2R1Y3QiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzZW1hbnRpY19zZWFyY2gtbGxtc19wcm9kdWN0In0sIHsic291cmNlIjogInJvdmVyX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogIm1sX3Byb2R1Y3Rpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyb3Zlcl9leHBlcmllbmNlLW1sX3Byb2R1Y3Rpb24ifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAibWxfcHJvZHVjdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtbWxfcHJvZHVjdGlvbiJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogIm1sX3Byb2R1Y3Rpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tbWxfcHJvZHVjdGlvbiJ9LCB7InNvdXJjZSI6ICJhd3NfZ2NwIiwgInRhcmdldCI6ICJtbF9wcm9kdWN0aW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYXdzX2djcC1tbF9wcm9kdWN0aW9uIn0sIHsic291cmNlIjogImRhZ3N0ZXJfYWlyZmxvdyIsICJ0YXJnZXQiOiAibWxfcHJvZHVjdGlvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRhZ3N0ZXJfYWlyZmxvdy1tbF9wcm9kdWN0aW9uIn0sIHsic291cmNlIjogImV4cGVyaW1lbnRhbF9kZXNpZ24iLCAidGFyZ2V0IjogIm1sX3Byb2R1Y3Rpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJleHBlcmltZW50YWxfZGVzaWduLW1sX3Byb2R1Y3Rpb24ifSwgeyJzb3VyY2UiOiAic3RhbmZvcmRfYWlfY2VydCIsICJ0YXJnZXQiOiAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YW5mb3JkX2FpX2NlcnQtcmVpbmZvcmNlbWVudF9sZWFybmluZyJ9LCB7InNvdXJjZSI6ICJib3R0b21fdXBfYXBwcm9hY2giLCAidGFyZ2V0IjogInJlaW5mb3JjZW1lbnRfbGVhcm5pbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtcmVpbmZvcmNlbWVudF9sZWFybmluZyJ9LCB7InNvdXJjZSI6ICJnYW1lX3RoZW9yeSIsICJ0YXJnZXQiOiAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdhbWVfdGhlb3J5LXJlaW5mb3JjZW1lbnRfbGVhcm5pbmcifSwgeyJzb3VyY2UiOiAiZGVjaXNpb25fbWFraW5nX2FnZW50cyIsICJ0YXJnZXQiOiAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMtcmVpbmZvcmNlbWVudF9sZWFybmluZyJ9LCB7InNvdXJjZSI6ICJnYW1lX3RoZW9yeSIsICJ0YXJnZXQiOiAiZGVjaXNpb25fbWFraW5nX2FnZW50cyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdhbWVfdGhlb3J5LWRlY2lzaW9uX21ha2luZ19hZ2VudHMifSwgeyJzb3VyY2UiOiAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJ0YXJnZXQiOiAiZGVjaXNpb25fbWFraW5nX2FnZW50cyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlaW5mb3JjZW1lbnRfbGVhcm5pbmctZGVjaXNpb25fbWFraW5nX2FnZW50cyJ9LCB7InNvdXJjZSI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAidGFyZ2V0IjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmctZGVjaXNpb25fbWFraW5nX2FnZW50cyJ9LCB7InNvdXJjZSI6ICJib3R0b21fdXBfYXBwcm9hY2giLCAidGFyZ2V0IjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJib3R0b21fdXBfYXBwcm9hY2gtZGVjaXNpb25fbWFraW5nX2FnZW50cyJ9LCB7InNvdXJjZSI6ICJnYW1lX3RoZW9yeSIsICJ0YXJnZXQiOiAiYXVjdGlvbnNfZGVzaWduIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZ2FtZV90aGVvcnktYXVjdGlvbnNfZGVzaWduIn0sIHsic291cmNlIjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMiLCAidGFyZ2V0IjogImF1Y3Rpb25zX2Rlc2lnbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRlY2lzaW9uX21ha2luZ19hZ2VudHMtYXVjdGlvbnNfZGVzaWduIn0sIHsic291cmNlIjogIm1hcmtldHBsYWNlcyIsICJ0YXJnZXQiOiAiYXVjdGlvbnNfZGVzaWduIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibWFya2V0cGxhY2VzLWF1Y3Rpb25zX2Rlc2lnbiJ9LCB7InNvdXJjZSI6ICJwcmljaW5nX2VsYXN0aWNpdHkiLCAidGFyZ2V0IjogImF1Y3Rpb25zX2Rlc2lnbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInByaWNpbmdfZWxhc3RpY2l0eS1hdWN0aW9uc19kZXNpZ24ifSwgeyJzb3VyY2UiOiAidmFuY291dmVyIiwgInRhcmdldCI6ICJzdGFuZm9yZF9haV9jZXJ0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidmFuY291dmVyLXN0YW5mb3JkX2FpX2NlcnQifSwgeyJzb3VyY2UiOiAibGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzIiwgInRhcmdldCI6ICJzdGFuZm9yZF9haV9jZXJ0IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzLXN0YW5mb3JkX2FpX2NlcnQifSwgeyJzb3VyY2UiOiAicmVpbmZvcmNlbWVudF9sZWFybmluZyIsICJ0YXJnZXQiOiAic3RhbmZvcmRfYWlfY2VydCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlaW5mb3JjZW1lbnRfbGVhcm5pbmctc3RhbmZvcmRfYWlfY2VydCJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogInN0YW5mb3JkX2FpX2NlcnQiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tc3RhbmZvcmRfYWlfY2VydCJ9LCB7InNvdXJjZSI6ICJzdGFuZm9yZF9haV9jZXJ0IiwgInRhcmdldCI6ICJsYXJnZV9sYW5ndWFnZV9tb2RlbHMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzdGFuZm9yZF9haV9jZXJ0LWxhcmdlX2xhbmd1YWdlX21vZGVscyJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImxhcmdlX2xhbmd1YWdlX21vZGVscyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1sYXJnZV9sYW5ndWFnZV9tb2RlbHMifSwgeyJzb3VyY2UiOiAic2VtYW50aWNfc2VhcmNoIiwgInRhcmdldCI6ICJsYXJnZV9sYW5ndWFnZV9tb2RlbHMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzZW1hbnRpY19zZWFyY2gtbGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzIn0sIHsic291cmNlIjogImxsbXNfcHJvZHVjdCIsICJ0YXJnZXQiOiAibGFyZ2VfbGFuZ3VhZ2VfbW9kZWxzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibGxtc19wcm9kdWN0LWxhcmdlX2xhbmd1YWdlX21vZGVscyJ9LCB7InNvdXJjZSI6ICJsYXJnZV9sYW5ndWFnZV9tb2RlbHMiLCAidGFyZ2V0IjogInNlbWFudGljX3NlYXJjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImxhcmdlX2xhbmd1YWdlX21vZGVscy1zZW1hbnRpY19zZWFyY2gifSwgeyJzb3VyY2UiOiAiY2x1c3RlcmluZ19hbGdvcml0aG1zIiwgInRhcmdldCI6ICJzZW1hbnRpY19zZWFyY2giLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjbHVzdGVyaW5nX2FsZ29yaXRobXMtc2VtYW50aWNfc2VhcmNoIn0sIHsic291cmNlIjogInJlY29tbWVuZGF0aW9uX3N5c3RlbXMiLCAidGFyZ2V0IjogInNlbWFudGljX3NlYXJjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJlY29tbWVuZGF0aW9uX3N5c3RlbXMtc2VtYW50aWNfc2VhcmNoIn0sIHsic291cmNlIjogImRydWdfZGlzY292ZXJ5IiwgInRhcmdldCI6ICJtb2xlY3VsYXJfZHluYW1pY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkcnVnX2Rpc2NvdmVyeS1tb2xlY3VsYXJfZHluYW1pY3MifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJtb2xlY3VsYXJfZHluYW1pY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tbW9sZWN1bGFyX2R5bmFtaWNzIn0sIHsic291cmNlIjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJ0YXJnZXQiOiAibW9sZWN1bGFyX2R5bmFtaWNzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGlmZmVyZW50aWFsX2dlb21ldHJ5LW1vbGVjdWxhcl9keW5hbWljcyJ9LCB7InNvdXJjZSI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5IiwgInRhcmdldCI6ICJtb2xlY3VsYXJfZHluYW1pY3MiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5LW1vbGVjdWxhcl9keW5hbWljcyJ9LCB7InNvdXJjZSI6ICJhbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMiLCAidGFyZ2V0IjogImRydWdfZGlzY292ZXJ5IiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzLWRydWdfZGlzY292ZXJ5In0sIHsic291cmNlIjogImJpdHNfZWR1Y2F0aW9uIiwgInRhcmdldCI6ICJkcnVnX2Rpc2NvdmVyeSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJpdHNfZWR1Y2F0aW9uLWRydWdfZGlzY292ZXJ5In0sIHsic291cmNlIjogIm1vbGVjdWxhcl9keW5hbWljcyIsICJ0YXJnZXQiOiAiZHJ1Z19kaXNjb3ZlcnkiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJtb2xlY3VsYXJfZHluYW1pY3MtZHJ1Z19kaXNjb3ZlcnkifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJkcnVnX2Rpc2NvdmVyeSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1kcnVnX2Rpc2NvdmVyeSJ9LCB7InNvdXJjZSI6ICJjbGltYXRlX3RlY2giLCAidGFyZ2V0IjogIm51Y2xlYXJfZnVzaW9uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2xpbWF0ZV90ZWNoLW51Y2xlYXJfZnVzaW9uIn0sIHsic291cmNlIjogImRpZmZlcmVudGlhbF9nZW9tZXRyeSIsICJ0YXJnZXQiOiAibnVjbGVhcl9mdXNpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJkaWZmZXJlbnRpYWxfZ2VvbWV0cnktbnVjbGVhcl9mdXNpb24ifSwgeyJzb3VyY2UiOiAicGVydHVyYmF0aW9uX3RoZW9yeSIsICJ0YXJnZXQiOiAibnVjbGVhcl9mdXNpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJwZXJ0dXJiYXRpb25fdGhlb3J5LW51Y2xlYXJfZnVzaW9uIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAibnVjbGVhcl9mdXNpb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tbnVjbGVhcl9mdXNpb24ifSwgeyJzb3VyY2UiOiAiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzIiwgInRhcmdldCI6ICJvcmdhbl9vbl9jaGlwIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzLW9yZ2FuX29uX2NoaXAifSwgeyJzb3VyY2UiOiAiYml0c19lZHVjYXRpb24iLCAidGFyZ2V0IjogIm9yZ2FuX29uX2NoaXAiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJiaXRzX2VkdWNhdGlvbi1vcmdhbl9vbl9jaGlwIn0sIHsic291cmNlIjogInB5dGhvbiIsICJ0YXJnZXQiOiAib3JnYW5fb25fY2hpcCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1vcmdhbl9vbl9jaGlwIn0sIHsic291cmNlIjogInZlZ2FuIiwgInRhcmdldCI6ICJhbHRlcm5hdGl2ZV9wcm90ZWlucyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInZlZ2FuLWFsdGVybmF0aXZlX3Byb3RlaW5zIn0sIHsic291cmNlIjogImNsaW1hdGVfdGVjaCIsICJ0YXJnZXQiOiAiYWx0ZXJuYXRpdmVfcHJvdGVpbnMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJjbGltYXRlX3RlY2gtYWx0ZXJuYXRpdmVfcHJvdGVpbnMifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAibWFya2V0cGxhY2VzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAicm92ZXJfZXhwZXJpZW5jZS1tYXJrZXRwbGFjZXMifSwgeyJzb3VyY2UiOiAidHVybm9fZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAibWFya2V0cGxhY2VzIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVybm9fZXhwZXJpZW5jZS1tYXJrZXRwbGFjZXMifSwgeyJzb3VyY2UiOiAiZ2FtZV90aGVvcnkiLCAidGFyZ2V0IjogIm1hcmtldHBsYWNlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImdhbWVfdGhlb3J5LW1hcmtldHBsYWNlcyJ9LCB7InNvdXJjZSI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zIiwgInRhcmdldCI6ICJtYXJrZXRwbGFjZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyZWNvbW1lbmRhdGlvbl9zeXN0ZW1zLW1hcmtldHBsYWNlcyJ9LCB7InNvdXJjZSI6ICJyZWluZm9yY2VtZW50X2xlYXJuaW5nIiwgInRhcmdldCI6ICJnYW1pbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJyZWluZm9yY2VtZW50X2xlYXJuaW5nLWdhbWluZyJ9LCB7InNvdXJjZSI6ICJhZ2VudF9iYXNlZF9tb2RlbGxpbmciLCAidGFyZ2V0IjogImdhbWluZyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImFnZW50X2Jhc2VkX21vZGVsbGluZy1nYW1pbmcifSwgeyJzb3VyY2UiOiAicHl0aG9uIiwgInRhcmdldCI6ICJnYW1pbmciLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJweXRob24tZ2FtaW5nIn0sIHsic291cmNlIjogIm51Y2xlYXJfZnVzaW9uIiwgInRhcmdldCI6ICJjbGltYXRlX3RlY2giLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJudWNsZWFyX2Z1c2lvbi1jbGltYXRlX3RlY2gifSwgeyJzb3VyY2UiOiAiYWx0ZXJuYXRpdmVfcHJvdGVpbnMiLCAidGFyZ2V0IjogImNsaW1hdGVfdGVjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImFsdGVybmF0aXZlX3Byb3RlaW5zLWNsaW1hdGVfdGVjaCJ9LCB7InNvdXJjZSI6ICJweXRob24iLCAidGFyZ2V0IjogImNsaW1hdGVfdGVjaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInB5dGhvbi1jbGltYXRlX3RlY2gifSwgeyJzb3VyY2UiOiAiY2hlbm5haSIsICJ0YXJnZXQiOiAiaHlkZXJhYmFkIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiY2hlbm5haS1oeWRlcmFiYWQifSwgeyJzb3VyY2UiOiAiYml0c19lZHVjYXRpb24iLCAidGFyZ2V0IjogImh5ZGVyYWJhZCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImJpdHNfZWR1Y2F0aW9uLWh5ZGVyYWJhZCJ9LCB7InNvdXJjZSI6ICJoeWRlcmFiYWQiLCAidGFyZ2V0IjogIm11bmljaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImh5ZGVyYWJhZC1tdW5pY2gifSwgeyJzb3VyY2UiOiAiZGV0bGVmX2R1cnIiLCAidGFyZ2V0IjogIm11bmljaCIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRldGxlZl9kdXJyLW11bmljaCJ9LCB7InNvdXJjZSI6ICJmYXNjaW5hdGlvbl9sZWFybmluZyIsICJ0YXJnZXQiOiAibXVuaWNoIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZmFzY2luYXRpb25fbGVhcm5pbmctbXVuaWNoIn0sIHsic291cmNlIjogIm11bmljaCIsICJ0YXJnZXQiOiAidHVjc29uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAibXVuaWNoLXR1Y3NvbiJ9LCB7InNvdXJjZSI6ICJ1b2ZhX2VkdWNhdGlvbiIsICJ0YXJnZXQiOiAidHVjc29uIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidW9mYV9lZHVjYXRpb24tdHVjc29uIn0sIHsic291cmNlIjogInNhbV9ncmFsbGEiLCAidGFyZ2V0IjogInR1Y3NvbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNhbV9ncmFsbGEtdHVjc29uIn0sIHsic291cmNlIjogInZlZ2FuIiwgInRhcmdldCI6ICJ0dWNzb24iLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ2ZWdhbi10dWNzb24ifSwgeyJzb3VyY2UiOiAidHVjc29uIiwgInRhcmdldCI6ICJzZWF0dGxlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAidHVjc29uLXNlYXR0bGUifSwgeyJzb3VyY2UiOiAicm92ZXJfZXhwZXJpZW5jZSIsICJ0YXJnZXQiOiAic2VhdHRsZSIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInJvdmVyX2V4cGVyaWVuY2Utc2VhdHRsZSJ9LCB7InNvdXJjZSI6ICJkYXRhX2luY3ViYXRvcl9leHBlcmllbmNlIiwgInRhcmdldCI6ICJzZWF0dGxlIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiZGF0YV9pbmN1YmF0b3JfZXhwZXJpZW5jZS1zZWF0dGxlIn0sIHsic291cmNlIjogInNlYXR0bGUiLCAidGFyZ2V0IjogInZhbmNvdXZlciIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInNlYXR0bGUtdmFuY291dmVyIn0sIHsic291cmNlIjogInR1cm5vX2V4cGVyaWVuY2UiLCAidGFyZ2V0IjogInZhbmNvdXZlciIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1cm5vX2V4cGVyaWVuY2UtdmFuY291dmVyIn0sIHsic291cmNlIjogInN0YW5mb3JkX2FpX2NlcnQiLCAidGFyZ2V0IjogInZhbmNvdXZlciIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInN0YW5mb3JkX2FpX2NlcnQtdmFuY291dmVyIn0sIHsic291cmNlIjogInR1Y3NvbiIsICJ0YXJnZXQiOiAic2NobnVja2kiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ0dWNzb24tc2NobnVja2kifSwgeyJzb3VyY2UiOiAic2VhdHRsZSIsICJ0YXJnZXQiOiAic2NobnVja2kiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJzZWF0dGxlLXNjaG51Y2tpIn0sIHsic291cmNlIjogInZhbmNvdXZlciIsICJ0YXJnZXQiOiAic2NobnVja2kiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ2YW5jb3V2ZXItc2NobnVja2kifSwgeyJzb3VyY2UiOiAidHVjc29uIiwgInRhcmdldCI6ICJ2ZWdhbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogInR1Y3Nvbi12ZWdhbiJ9LCB7InNvdXJjZSI6ICJhbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMiLCAidGFyZ2V0IjogInZlZ2FuIiwgInN0cmVuZ3RoIjogMC41LCAiaWQiOiAiYW5pbWFsX3Rlc3RpbmdfYWx0ZXJuYXRpdmVzLXZlZ2FuIn0sIHsic291cmNlIjogImFsdGVybmF0aXZlX3Byb3RlaW5zIiwgInRhcmdldCI6ICJ2ZWdhbiIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImFsdGVybmF0aXZlX3Byb3RlaW5zLXZlZ2FuIn0sIHsic291cmNlIjogInZlZ2FuIiwgInRhcmdldCI6ICJhbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJ2ZWdhbi1hbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMifSwgeyJzb3VyY2UiOiAiZHJ1Z19kaXNjb3ZlcnkiLCAidGFyZ2V0IjogImFuaW1hbF90ZXN0aW5nX2FsdGVybmF0aXZlcyIsICJzdHJlbmd0aCI6IDAuNSwgImlkIjogImRydWdfZGlzY292ZXJ5LWFuaW1hbF90ZXN0aW5nX2FsdGVybmF0aXZlcyJ9LCB7InNvdXJjZSI6ICJvcmdhbl9vbl9jaGlwIiwgInRhcmdldCI6ICJhbmltYWxfdGVzdGluZ19hbHRlcm5hdGl2ZXMiLCAic3RyZW5ndGgiOiAwLjUsICJpZCI6ICJvcmdhbl9vbl9jaGlwLWFuaW1hbF90ZXN0aW5nX2FsdGVybmF0aXZlcyJ9XX0=');
                const configStr = atob('eyJ3aWR0aCI6IDEyMDAsICJoZWlnaHQiOiAiNzV2aCIsICJoZXJvX21vZGUiOiB0cnVlLCAidGl0bGVfb3ZlcmxheSI6ICJBcnVuJ3MgS25vd2xlZGdlIEdyYXBoIiwgInRoZW1lIjogeyJwcmltYXJ5Q29sb3IiOiAiIzI3ODBlMyIsICJzZWNvbmRhcnlDb2xvciI6ICIjM2ZiNjE4IiwgImFjY2VudENvbG9yIjogIiNmZmRkM2MiLCAiZGFuZ2VyQ29sb3IiOiAiI2ZmMDAzOSIsICJtdXRlZENvbG9yIjogIiM4NjhlOTYiLCAiYmFja2dyb3VuZENvbG9yIjogIiNmZmZmZmYiLCAic3VyZmFjZUNvbG9yIjogIiNmOGY5ZmEiLCAidGV4dFByaW1hcnkiOiAiIzIxMjUyOSIsICJ0ZXh0U2Vjb25kYXJ5IjogIiM0OTUwNTciLCAiZm9udEZhbWlseSI6ICJzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sICdTZWdvZSBVSScsIFJvYm90bywgc2Fucy1zZXJpZiIsICJmb250U2l6ZUJhc2UiOiAxNH0sICJub2RlQ29sb3JzIjogeyJwaHlzaWNzIjogIiMyNzgwZTMiLCAiZGF0YSI6ICIjM2ZiNjE4IiwgInRvb2xraXQiOiAiI2ZmZGQzYyIsICJhcHBsaWNhdGlvbnMiOiAiI2ZmMDAzOSIsICJwZXJzb25hbCI6ICIjNjEzZDdjIn0sICJsYXllcnMiOiBbeyJpZCI6ICJwaHlzaWNzIiwgIm5hbWUiOiAiUGh5c2ljcyIsICJjb2xvciI6ICIjMjc4MGUzIn0sIHsiaWQiOiAiZGF0YSIsICJuYW1lIjogIkRhdGEgJiBBSSIsICJjb2xvciI6ICIjM2ZiNjE4In0sIHsiaWQiOiAidG9vbGtpdCIsICJuYW1lIjogIlRvb2xraXQiLCAiY29sb3IiOiAiI2ZmZGQzYyJ9LCB7ImlkIjogImFwcGxpY2F0aW9ucyIsICJuYW1lIjogIkFwcGxpY2F0aW9ucyIsICJjb2xvciI6ICIjZmYwMDM5In0sIHsiaWQiOiAicGVyc29uYWwiLCAibmFtZSI6ICJQZXJzb25hbCIsICJjb2xvciI6ICIjNjEzZDdjIn1dLCAidGltZWxpbmUiOiB7ImVuYWJsZWQiOiB0cnVlLCAic3RhcnQiOiAyMDA5LCAiZW5kIjogMjAyNX0sICJmZWF0dXJlcyI6IHsic2hvd01pbmlNYXAiOiB0cnVlLCAic2hvd1RpbWVsaW5lIjogdHJ1ZSwgInNob3dMZWdlbmQiOiB0cnVlLCAiZW5hYmxlSG92ZXIiOiB0cnVlLCAiZW5hYmxlRHJhZyI6IHRydWV9LCAic2ltdWxhdGlvbiI6IHsibGlua0Rpc3RhbmNlIjogMjAwLCAiY2hhcmdlU3RyZW5ndGgiOiAtMzAwLCAiY29sbGlzaW9uUmFkaXVzIjogNjAsICJsaW5rU3RyZW5ndGgiOiAwLjI1LCAiY2VudGVyU3RyZW5ndGgiOiAwLjUsICJjaGFyZ2VEaXN0YW5jZU1heCI6IDUwMCwgInZlbG9jaXR5RGVjYXkiOiAwLjh9fQ==');
                const data = JSON.parse(dataStr);
                const config = JSON.parse(configStr);

                // Apply Quarto dark mode theme if active
                function applyQuartoTheme() {
                    const isDarkMode = document.documentElement.classList.contains('quarto-dark');

                    if (isDarkMode) {
                        // Dark mode theme
                        config.theme = {
                            ...config.theme,
                            backgroundColor: '#1f1f1f',
                            surfaceColor: '#262626',
                            textPrimary: '#e9ecef',
                            textSecondary: '#adb5bd',
                            textMuted: '#6c757d',
                            borderColor: '#404040',
                            mutedColor: '#6c757d'
                        };

                        // Update hero section background if in hero mode
                        if (config.hero_mode) {
                            const heroSection = document.querySelector('.hero-section');
                            if (heroSection) {
                                heroSection.style.background = '#1f1f1f';
                            }
                        }
                    } else {
                        // Light mode theme (default)
                        config.theme = {
                            ...config.theme,
                            backgroundColor: '#ffffff',
                            surfaceColor: '#f8f9fa',
                            textPrimary: '#212529',
                            textSecondary: '#495057',
                            textMuted: '#868e96',
                            borderColor: '#dee2e6',
                            mutedColor: '#868e96'
                        };

                        // Update hero section background if in hero mode
                        if (config.hero_mode) {
                            const heroSection = document.querySelector('.hero-section');
                            if (heroSection) {
                                heroSection.style.background = '#f9f9f9';
                            }
                        }
                    }
                }

                applyQuartoTheme();

                const container = document.getElementById('kg_c86fdab8');
                const wrapper = document.getElementById('kg_c86fdab8_wrapper');
                container.innerHTML = ''; // Clear loading message

                // Fix dimensions for hero mode - convert viewport units to pixels
                if (config.hero_mode) {
                    const rect = wrapper.getBoundingClientRect();
                    config.width = rect.width;
                    config.height = rect.height;
                    console.log(`Hero mode dimensions: ${config.width} x ${config.height}`);
                }
                
                console.log('Creating KnowledgeGraphExplorer...');
                const graph = new KnowledgeGraphExplorer(container, data, config);
                window.kg_c86fdab8 = graph;
                
                console.log('Graph created, adding UI controls to wrapper...');

                // Add UI controls to the wrapper, not the graph container
                setTimeout(() => {
                    try {
                        const uiControls = new UIControlsManager(config);
                        // Merge data and config for UI controls
                        const dataWithConfig = Object.assign({}, data, {
                            layers: config.layers,
                            timeline: config.timeline
                        });
                        uiControls.initialize(wrapper, graph, dataWithConfig);
                        window['kg_c86fdab8_ui'] = uiControls;
                        console.log('UI controls added to wrapper successfully');
                    } catch (uiError) {
                        console.error('UI Controls failed:', uiError);
                    }
                }, 500);

                // Listen for Quarto theme changes and update graph accordingly
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.attributeName === 'class' && mutation.target === document.documentElement) {
                            applyQuartoTheme();
                            if (graph && graph.updateConfig) {
                                graph.updateConfig({ theme: config.theme });
                            }
                        }
                    });
                });
                observer.observe(document.documentElement, {
                    attributes: true,
                    attributeFilter: ['class']
                });

                // Setup title overlay interaction detection if present
                const titleOverlay = document.getElementById('kg_c86fdab8_title_overlay');
                if (titleOverlay) {
                    let titleHidden = false;

                    function hideTitleOverlay() {
                        if (!titleHidden) {
                            titleHidden = true;
                            titleOverlay.style.transition = 'opacity 0.8s ease-out';
                            titleOverlay.style.opacity = '0';
                            setTimeout(() => {
                                titleOverlay.style.display = 'none';
                            }, 800);
                        }
                    }

                    // Only hide title on meaningful graph interactions
                    container.addEventListener('click', hideTitleOverlay);
                    container.addEventListener('touchstart', hideTitleOverlay);
                    container.addEventListener('wheel', hideTitleOverlay); // For zoom

                    // Hide on graph interaction events (not passive events like mousemove)
                    graph.on('zoom', hideTitleOverlay);
                    graph.on('nodeClick', hideTitleOverlay);
                    graph.on('audienceChange', hideTitleOverlay);

                    // Hide on drag start (meaningful interaction)
                    let isDragging = false;
                    container.addEventListener('mousedown', () => {
                        isDragging = false;
                    });
                    container.addEventListener('mousemove', (e) => {
                        if (e.buttons > 0) { // Mouse button is pressed during move
                            if (!isDragging) {
                                isDragging = true;
                                hideTitleOverlay();
                            }
                        }
                    });
                }
                
                console.log('Graph initialized successfully');
            } catch (error) {
                console.error('Graph initialization failed:', error);
                document.getElementById('kg_c86fdab8').innerHTML = 
                    '<div style="padding: 20px; color: red;">Graph failed to load: ' + error.message + '</div>';
            }
        }

        // Wait for D3 and DOM
        if (typeof d3 !== 'undefined' && document.readyState === 'complete') {
            initGraph();
        } else {
            window.addEventListener('load', function() {
                setTimeout(initGraph, 200);
            });
        }
        </script>
        

<script>
// Manually add title overlay after graph loads
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
        const wrapper = document.querySelector('.kg-hero-wrapper');
        if (wrapper && !document.querySelector('.kg-hero-intro')) {
            // Create enhanced overlay with photo, name, and description
            const overlay = document.createElement('div');
            overlay.className = 'kg-hero-intro';
            overlay.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.9); z-index: 100; text-align: center; pointer-events: none; opacity: 0; transition: opacity 0.8s ease-out, transform 0.8s ease-out;';

            // Profile picture
            const profileImg = document.createElement('img');
            profileImg.src = 'profile.jpg';
            profileImg.alt = 'Arun Ravishankar';
            profileImg.style.cssText = 'width: 300px; height: 300px; border-radius: 50%; object-fit: cover; margin-bottom: 1.5rem; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15); border: 3px solid rgba(255, 255, 255, 0.9);';

            // Name
            const name = document.createElement('h1');
            name.textContent = "Arun Ravishankar";
            name.style.cssText = 'font-size: 3rem; font-weight: 300; color: #495057; margin: 0 0 1rem 0; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); letter-spacing: 0.5px;';

            // Description/invitation
            const description = document.createElement('p');
            description.textContent = "Explore this interactive knowledge graph to discover my journey across physics, data science, and AI";
            description.style.cssText = 'font-size: 1.2rem; font-weight: 400; color: #666; margin: 0; max-width: 500px; line-height: 1.5; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);';

            overlay.appendChild(profileImg);
            overlay.appendChild(name);
            overlay.appendChild(description);
            wrapper.appendChild(overlay);

            // Fade in the title with scale effect after a delay
            setTimeout(() => {
                overlay.style.opacity = '1';
                overlay.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 500);

            // Setup interaction detection to hide title
            let titleHidden = false;
            const container = wrapper.querySelector('[id^="kg_"]');

            function hideTitleOverlay() {
                if (!titleHidden && overlay) {
                    titleHidden = true;
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        if (overlay.parentNode) {
                            overlay.parentNode.removeChild(overlay);
                        }
                    }, 800);
                }
            }

            if (container) {
                // Hide on meaningful interactions
                container.addEventListener('click', hideTitleOverlay);
                container.addEventListener('touchstart', hideTitleOverlay);
                container.addEventListener('wheel', hideTitleOverlay);

                // Hide on drag
                let isDragging = false;
                container.addEventListener('mousedown', () => {
                    isDragging = false;
                });
                container.addEventListener('mousemove', (e) => {
                    if (e.buttons > 0) {
                        if (!isDragging) {
                            isDragging = true;
                            hideTitleOverlay();
                        }
                    }
                });
            }

            // Also try to hook into the graph instance if available
            setTimeout(() => {
                const graphInstance = window[wrapper.id.replace('_wrapper', '')];
                if (graphInstance && graphInstance.on) {
                    graphInstance.on('nodeClick', hideTitleOverlay);
                    graphInstance.on('zoom', hideTitleOverlay);
                    graphInstance.on('audienceChange', hideTitleOverlay);
                }
            }, 2000);
        }
    }, 1000);
});
</script>

</div>
<div class="about-content-section">
<section id="about-me" class="level2">
<h2 class="anchored" data-anchor-id="about-me">About Me</h2>
<p>I get excited about figuring things out, which has taken me on a rather wandering path across continents and disciplines.</p>
<p>If we’re going by standard buckets, I’d call myself a theoretical physicist-turned-data scientist, but my interests are all over the place, so I’d rather not be stuck with that label.</p>
<div class="social-links">
<p>Connect with me: <a href="https://bsky.app/profile/arunravishankar.bsky.social">Bluesky</a> • <a href="https://www.linkedin.com/in/arunravishankar/">LinkedIn</a> • <a href="https://github.com/arunravishankar">GitHub</a> • <a href="mailto:arunravishankar@gmail.com">Email</a></p>
</div>
</section>
<section id="the-journey" class="level2">
<h2 class="anchored" data-anchor-id="the-journey">The Journey</h2>
<p>Curiosity about the quantum foundations took me from India to Munich, where I worked with the late <a href="https://www.mathematik.uni-muenchen.de/~duerr/">Detlef Dürr</a> on Bohmian mechanics. His research group was full of people who were inquisitive, and deeply cared about the work they did. This was where I started looking at systems with the bottom-up approach — figuring out how to formulate a theory that ontologically describes how nature works at a fundamental level, with the constraints of having to describe known phenomena.</p>
<p>I went to Tucson planning to work with <a href="https://sgralla.arizona.edu/">Sam Gralla</a> on the self-force problem, but ended up getting sucked into <a href="https://inspirehep.net/authors/1798223">black hole physics</a> instead. The PhD years in Arizona were intense in ways I didn’t expect. I got really good at sitting with hard problems for months without making progress, then suddenly seeing the path forward. Somewhere along the way, I also started caring about the math itself, not just what it could tell me about black holes.</p>
<p>Then Schnucki showed up with those brown eyes and infinite capacity for love, and suddenly being with her in a place where she could run around freely became a priority. Seattle called — I’m a sucker for gloomy, drizzly weather and the beautiful outdoors. I was fortunate to find my first position outside academia at Rover, working with genuinely amazing people, and everything clicked differently. Instead of “What fundamental dynamics make this happen?” I started asking “What can we actually figure out from messy, real-world data?”. I went from exact solutions and clean equations to thinking in distributions and probabilities. Turns out that adding programming to your toolkit allows you to ask questions that you’d never even think of asking if you didn’t have those techniques under your belt.</p>
<p>Long-term immigration stability brought me to Vancouver in 2024. Now I’m doing Stanford’s AI program while consulting for Turno (another 2-sided marketplace, because apparently I have a type). These days I’m obsessed with where game theory, reinforcement learning, and economics overlap — it’s this sweet spot where bottom-up and top-down thinking actually play nice together. And yeah, like everyone else, I’m trying to figure out what to do with large language models.</p>
</section>
<section id="education" class="level2">
<h2 class="anchored" data-anchor-id="education">Education</h2>
<p><strong>Stanford University</strong> | Remote<br>
AI Graduate Certificate | Sep 2024 - present</p>
<p><strong>The Data Incubator</strong> | Remote<br>
Data Science Fellowship | Feb 2021 - May 2021</p>
<p><strong>University of Arizona</strong> | Tucson, AZ<br>
PhD in Physics | Aug 2015 - Jul 2021</p>
<p><strong>Ludwig Maximilians University</strong> | Munich, DE<br>
Visiting student for Master’s thesis | Aug 2013 - Jul 2014</p>
<p><strong>Birla Institute of Technology and Sciences</strong> | Hyderabad, India<br>
MSc in Physics &amp; Bachelors in Pharmacy | Aug 2009 - Jul 2014</p>
</section>
<section id="experience" class="level2">
<h2 class="anchored" data-anchor-id="experience">Experience</h2>
<p><strong>Turno</strong> | Vancouver, BC<br>
Data Scientist | Sep 2024 - present</p>
<p><strong>Rover</strong> | Seattle, WA<br>
Data Scientist II &amp; III | Sep 2021 - Sep 2024</p>
<p>If you’re interested in more specifics of what I’ve done professionally, you can find more details on my <a href="https://arunravishankar.github.io/cv/">Resume</a> and on <a href="https://www.linkedin.com/in/arunravishankar/">LinkedIn</a>.</p>
</section>
<section id="interactive-exploration" class="level2">
<h2 class="anchored" data-anchor-id="interactive-exploration">Interactive Exploration</h2>
<p>The graph above shows the interconnected nature of my journey - you can:</p>
<ul>
<li><strong>Hover over nodes</strong> to see the 3D distance-based effects</li>
<li><strong>Click nodes</strong> for detailed descriptions</li>
<li><strong>Use the layer controls</strong> to focus on specific aspects (Education, Research, Industry, Current Focus, Geographic)</li>
<li><strong>Navigate the timeline</strong> to see how things evolved over time</li>
<li><strong>Use the minimap</strong> to quickly jump to different areas</li>
</ul>
<p>Each connection represents how one experience led to or influenced another. The stronger the connection, the more direct the influence. You’ll notice that geographic moves often coincided with major career transitions, and that the bottom-up thinking approach from quantum foundations continues to influence my current work in AI and game theory.</p>
<p>The questions keep changing, but I’m still just as curious about complex systems — whether they’re quantum foundations, black holes, markets, or whatever’s next.</p>
</section>
</div>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/www\.inmylightcone\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>